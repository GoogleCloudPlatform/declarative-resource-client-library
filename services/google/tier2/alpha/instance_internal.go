// Copyright 2021 Google LLC. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package alpha

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"reflect"
	"strings"
	"time"

	"github.com/GoogleCloudPlatform/declarative-resource-client-library/dcl"
	"github.com/GoogleCloudPlatform/declarative-resource-client-library/dcl/operations"
)

func (r *Instance) validate() error {

	if err := dcl.Required(r, "name"); err != nil {
		return err
	}
	if err := dcl.RequiredParameter(r.Project, "Project"); err != nil {
		return err
	}
	if err := dcl.RequiredParameter(r.Location, "Location"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Sku) {
		if err := r.Sku.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessCreateRecipe) {
		if err := r.PreprocessCreateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.InitiateCreateRecipe) {
		if err := r.InitiateCreateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.CreateRecipe) {
		if err := r.CreateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.DeleteRecipe) {
		if err := r.DeleteRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.UpdateRecipe) {
		if err := r.UpdateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessResetRecipe) {
		if err := r.PreprocessResetRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.InitiateResetRecipe) {
		if err := r.InitiateResetRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ResetRecipe) {
		if err := r.ResetRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessRepairRecipe) {
		if err := r.PreprocessRepairRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.InitiateRepairRecipe) {
		if err := r.InitiateRepairRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RepairRecipe) {
		if err := r.RepairRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessDeleteRecipe) {
		if err := r.PreprocessDeleteRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.InitiateDeleteRecipe) {
		if err := r.InitiateDeleteRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdateRecipe) {
		if err := r.PreprocessUpdateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.InitiateUpdateRecipe) {
		if err := r.InitiateUpdateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessFreezeRecipe) {
		if err := r.PreprocessFreezeRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.FreezeRecipe) {
		if err := r.FreezeRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUnfreezeRecipe) {
		if err := r.PreprocessUnfreezeRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.UnfreezeRecipe) {
		if err := r.UnfreezeRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ReadonlyRecipe) {
		if err := r.ReadonlyRecipe.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceSku) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipe) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceCreateRecipe) validate() error {
	return nil
}
func (r *InstanceCreateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceCreateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceCreateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceDeleteRecipe) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceDeleteRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceDeleteRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceUpdateRecipe) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUpdateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUpdateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessResetRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipe) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateResetRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceResetRecipe) validate() error {
	return nil
}
func (r *InstanceResetRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceResetRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceResetRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipe) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceRepairRecipe) validate() error {
	return nil
}
func (r *InstanceRepairRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceRepairRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceRepairRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipe) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipe) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceFreezeRecipe) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceFreezeRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceFreezeRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipe) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUnfreezeRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipe) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReadonlyRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfigs) {
		if err := r.KeyConfigs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyConfig) {
		if err := r.KeyConfig.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) validate() error {
	return nil
}
func (r *InstanceHistory) validate() error {
	return nil
}

func instanceGetURL(userBasePath string, r *Instance) (string, error) {
	params := map[string]interface{}{
		"project":  dcl.ValueOrEmptyString(r.Project),
		"location": dcl.ValueOrEmptyString(r.Location),
		"name":     dcl.ValueOrEmptyString(r.Name),
	}
	return dcl.URL("projects/{{project}}/locations/{{location}}/instances/{{name}}", "https://arcus2tier2.sandbox.googleapis.com/v1alpha2/", userBasePath, params), nil
}

func instanceListURL(userBasePath, project, location string) (string, error) {
	params := map[string]interface{}{
		"project":  project,
		"location": location,
	}
	return dcl.URL("projects/{{project}}/locations/{{location}}/instances", "https://arcus2tier2.sandbox.googleapis.com/v1alpha2/", userBasePath, params), nil

}

func instanceCreateURL(userBasePath, project, location, name string) (string, error) {
	params := map[string]interface{}{
		"project":  project,
		"location": location,
		"name":     name,
	}
	return dcl.URL("projects/{{project}}/locations/{{location}}/instances?instanceId={{name}}", "https://arcus2tier2.sandbox.googleapis.com/v1alpha2/", userBasePath, params), nil

}

func instanceDeleteURL(userBasePath string, r *Instance) (string, error) {
	params := map[string]interface{}{
		"project":  dcl.ValueOrEmptyString(r.Project),
		"location": dcl.ValueOrEmptyString(r.Location),
		"name":     dcl.ValueOrEmptyString(r.Name),
	}
	return dcl.URL("projects/{{project}}/locations/{{location}}/instances/{{name}}", "https://arcus2tier2.sandbox.googleapis.com/v1alpha2/", userBasePath, params), nil
}

// instanceApiOperation represents a mutable operation in the underlying REST
// API such as Create, Update, or Delete.
type instanceApiOperation interface {
	do(context.Context, *Instance, *Client) error
}

// newUpdateInstanceUpdateInstanceRequest creates a request for an
// Instance resource's UpdateInstance update type by filling in the update
// fields based on the intended state of the resource.
func newUpdateInstanceUpdateInstanceRequest(ctx context.Context, f *Instance, c *Client) (map[string]interface{}, error) {
	req := map[string]interface{}{}

	if v := f.Name; !dcl.IsEmptyValueIndirect(v) {
		req["name"] = v
	}
	if v := f.DisplayName; !dcl.IsEmptyValueIndirect(v) {
		req["displayName"] = v
	}
	if v := f.Labels; !dcl.IsEmptyValueIndirect(v) {
		req["labels"] = v
	}
	if v := f.Zone; !dcl.IsEmptyValueIndirect(v) {
		req["zone"] = v
	}
	if v, err := expandInstanceSku(c, f.Sku); err != nil {
		return nil, fmt.Errorf("error expanding Sku into sku: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["sku"] = v
	}
	if v := f.AuthorizedNetworkId; !dcl.IsEmptyValueIndirect(v) {
		req["authorizedNetworkId"] = v
	}
	if v := f.ReservedIPRange; !dcl.IsEmptyValueIndirect(v) {
		req["reservedIpRange"] = v
	}
	if v := f.HostName; !dcl.IsEmptyValueIndirect(v) {
		req["hostName"] = v
	}
	if v := f.PortNumber; !dcl.IsEmptyValueIndirect(v) {
		req["portNumber"] = v
	}
	if v := f.CurrentZone; !dcl.IsEmptyValueIndirect(v) {
		req["currentZone"] = v
	}
	if v := f.CreationTime; !dcl.IsEmptyValueIndirect(v) {
		req["creationTime"] = v
	}
	if v := f.State; !dcl.IsEmptyValueIndirect(v) {
		req["state"] = v
	}
	if v := f.StatusMessage; !dcl.IsEmptyValueIndirect(v) {
		req["statusMessage"] = v
	}
	if v := f.ExtraField; !dcl.IsEmptyValueIndirect(v) {
		req["extraField"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipe(c, f.PreprocessCreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessCreateRecipe into preprocessCreateRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessCreateRecipe"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipe(c, f.InitiateCreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateCreateRecipe into initiateCreateRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["initiateCreateRecipe"] = v
	}
	if v, err := expandInstanceCreateRecipe(c, f.CreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding CreateRecipe into createRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["createRecipe"] = v
	}
	if v, err := expandInstanceDeleteRecipe(c, f.DeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding DeleteRecipe into deleteRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["deleteRecipe"] = v
	}
	if v, err := expandInstanceUpdateRecipe(c, f.UpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding UpdateRecipe into updateRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["updateRecipe"] = v
	}
	if v, err := expandInstancePreprocessResetRecipe(c, f.PreprocessResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessResetRecipe into preprocessResetRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessResetRecipe"] = v
	}
	if v, err := expandInstanceInitiateResetRecipe(c, f.InitiateResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateResetRecipe into initiateResetRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["initiateResetRecipe"] = v
	}
	if v, err := expandInstanceResetRecipe(c, f.ResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ResetRecipe into resetRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["resetRecipe"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipe(c, f.PreprocessRepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessRepairRecipe into preprocessRepairRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessRepairRecipe"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipe(c, f.InitiateRepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateRepairRecipe into initiateRepairRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["initiateRepairRecipe"] = v
	}
	if v, err := expandInstanceRepairRecipe(c, f.RepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding RepairRecipe into repairRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["repairRecipe"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipe(c, f.PreprocessDeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessDeleteRecipe into preprocessDeleteRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessDeleteRecipe"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipe(c, f.InitiateDeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateDeleteRecipe into initiateDeleteRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["initiateDeleteRecipe"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipe(c, f.PreprocessUpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdateRecipe into preprocessUpdateRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessUpdateRecipe"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipe(c, f.InitiateUpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateUpdateRecipe into initiateUpdateRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["initiateUpdateRecipe"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipe(c, f.PreprocessFreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessFreezeRecipe into preprocessFreezeRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessFreezeRecipe"] = v
	}
	if v, err := expandInstanceFreezeRecipe(c, f.FreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding FreezeRecipe into freezeRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["freezeRecipe"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipe(c, f.PreprocessUnfreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUnfreezeRecipe into preprocessUnfreezeRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessUnfreezeRecipe"] = v
	}
	if v, err := expandInstanceUnfreezeRecipe(c, f.UnfreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding UnfreezeRecipe into unfreezeRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["unfreezeRecipe"] = v
	}
	if v, err := expandInstanceReadonlyRecipe(c, f.ReadonlyRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ReadonlyRecipe into readonlyRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["readonlyRecipe"] = v
	}
	if v := f.EnableCallHistory; !dcl.IsEmptyValueIndirect(v) {
		req["enableCallHistory"] = v
	}
	if v, err := expandInstanceHistorySlice(c, f.History); err != nil {
		return nil, fmt.Errorf("error expanding History into history: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["history"] = v
	}
	if v := f.PublicResourceViewOverride; !dcl.IsEmptyValueIndirect(v) {
		req["publicResourceViewOverride"] = v
	}
	return req, nil
}

// marshalUpdateInstanceUpdateInstanceRequest converts the update into
// the final JSON request body.
func marshalUpdateInstanceUpdateInstanceRequest(c *Client, m map[string]interface{}) ([]byte, error) {

	return json.Marshal(m)
}

type updateInstanceUpdateInstanceOperation struct {
	// If the update operation has the REQUIRES_APPLY_OPTIONS trait, this will be populated.
	// Usually it will be nil - this is to prevent us from accidentally depending on apply
	// options, which should usually be unnecessary.
	ApplyOptions []dcl.ApplyOption
}

// do creates a request and sends it to the appropriate URL. In most operations,
// do will transcribe a subset of the resource into a request object and send a
// PUT request to a single URL.

func (op *updateInstanceUpdateInstanceOperation) do(ctx context.Context, r *Instance, c *Client) error {
	_, err := c.GetInstance(ctx, r.urlNormalized())
	if err != nil {
		return err
	}

	u, err := r.updateURL(c.Config.BasePath, "UpdateInstance")
	if err != nil {
		return err
	}
	mask := strings.Join([]string{"name", "displayName", "labels", "zone", "sku", "authorizedNetworkId", "reservedIpRange", "hostName", "portNumber", "currentZone", "creationTime", "state", "statusMessage", "extraField", "preprocessCreateRecipe", "initiateCreateRecipe", "createRecipe", "deleteRecipe", "updateRecipe", "preprocessResetRecipe", "initiateResetRecipe", "resetRecipe", "preprocessRepairRecipe", "initiateRepairRecipe", "repairRecipe", "preprocessDeleteRecipe", "initiateDeleteRecipe", "preprocessUpdateRecipe", "initiateUpdateRecipe", "preprocessFreezeRecipe", "freezeRecipe", "preprocessUnfreezeRecipe", "unfreezeRecipe", "readonlyRecipe", "enableCallHistory", "history", "publicResourceViewOverride"}, ",")
	u, err = dcl.AddQueryParams(u, map[string]string{"updateMask": mask})
	if err != nil {
		return err
	}

	req, err := newUpdateInstanceUpdateInstanceRequest(ctx, r, c)
	if err != nil {
		return err
	}

	c.Config.Logger.Infof("Created update: %#v", req)
	body, err := marshalUpdateInstanceUpdateInstanceRequest(c, req)
	if err != nil {
		return err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "PATCH", u, bytes.NewBuffer(body), c.Config.RetryProvider)
	if err != nil {
		return err
	}

	var o operations.StandardGCPOperation
	if err := dcl.ParseResponse(resp.Response, &o); err != nil {
		return err
	}
	err = o.Wait(ctx, c.Config, "https://arcus2tier2.sandbox.googleapis.com/v1alpha2/", "GET")

	if err != nil {
		return err
	}

	return nil
}

func (c *Client) listInstanceRaw(ctx context.Context, project, location, pageToken string, pageSize int32) ([]byte, error) {
	u, err := instanceListURL(c.Config.BasePath, project, location)
	if err != nil {
		return nil, err
	}

	m := make(map[string]string)
	if pageToken != "" {
		m["pageToken"] = pageToken
	}

	if pageSize != InstanceMaxPage {
		m["pageSize"] = fmt.Sprintf("%v", pageSize)
	}

	u, err = dcl.AddQueryParams(u, m)
	if err != nil {
		return nil, err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "GET", u, &bytes.Buffer{}, c.Config.RetryProvider)
	if err != nil {
		return nil, err
	}
	defer resp.Response.Body.Close()
	return ioutil.ReadAll(resp.Response.Body)
}

type listInstanceOperation struct {
	Instances []map[string]interface{} `json:"instances"`
	Token     string                   `json:"nextPageToken"`
}

func (c *Client) listInstance(ctx context.Context, project, location, pageToken string, pageSize int32) ([]*Instance, string, error) {
	b, err := c.listInstanceRaw(ctx, project, location, pageToken, pageSize)
	if err != nil {
		return nil, "", err
	}

	var m listInstanceOperation
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, "", err
	}

	var l []*Instance
	for _, v := range m.Instances {
		res := flattenInstance(c, v)
		res.Project = &project
		res.Location = &location
		l = append(l, res)
	}

	return l, m.Token, nil
}

func (c *Client) deleteAllInstance(ctx context.Context, f func(*Instance) bool, resources []*Instance) error {
	var errors []string
	for _, res := range resources {
		if f(res) {
			// We do not want deleteAll to fail on a deletion or else it will stop deleting other resources.
			err := c.DeleteInstance(ctx, res)
			if err != nil {
				errors = append(errors, err.Error())
			}
		}
	}
	if len(errors) > 0 {
		return fmt.Errorf("%v", strings.Join(errors, "\n"))
	} else {
		return nil
	}
}

type deleteInstanceOperation struct{}

func (op *deleteInstanceOperation) do(ctx context.Context, r *Instance, c *Client) error {

	_, err := c.GetInstance(ctx, r.urlNormalized())

	if err != nil {
		if dcl.IsNotFound(err) {
			c.Config.Logger.Infof("Instance not found, returning. Original error: %v", err)
			return nil
		}
		c.Config.Logger.Warningf("GetInstance checking for existence. error: %v", err)
		return err
	}

	u, err := instanceDeleteURL(c.Config.BasePath, r.urlNormalized())
	if err != nil {
		return err
	}

	// Delete should never have a body
	body := &bytes.Buffer{}
	resp, err := dcl.SendRequest(ctx, c.Config, "DELETE", u, body, c.Config.RetryProvider)
	if err != nil {
		return err
	}

	// wait for object to be deleted.
	var o operations.StandardGCPOperation
	if err := dcl.ParseResponse(resp.Response, &o); err != nil {
		return err
	}
	if err := o.Wait(ctx, c.Config, "https://arcus2tier2.sandbox.googleapis.com/v1alpha2/", "GET"); err != nil {
		return err
	}

	// we saw a race condition where for some successful delete operation, the Get calls returned resources for a short duration.
	// this is the reason we are adding retry to handle that case.
	maxRetry := 10
	for i := 1; i <= maxRetry; i++ {
		_, err = c.GetInstance(ctx, r.urlNormalized())
		if !dcl.IsNotFound(err) {
			if i == maxRetry {
				return dcl.NotDeletedError{ExistingResource: r}
			}
			time.Sleep(1000 * time.Millisecond)
		} else {
			break
		}
	}
	return nil
}

// Create operations are similar to Update operations, although they do not have
// specific request objects. The Create request object is the json encoding of
// the resource, which is modified by res.marshal to form the base request body.
type createInstanceOperation struct {
	response map[string]interface{}
}

func (op *createInstanceOperation) FirstResponse() (map[string]interface{}, bool) {
	return op.response, len(op.response) > 0
}

func (op *createInstanceOperation) do(ctx context.Context, r *Instance, c *Client) error {
	c.Config.Logger.Infof("Attempting to create %v", r)

	project, location, name := r.createFields()
	u, err := instanceCreateURL(c.Config.BasePath, project, location, name)

	if err != nil {
		return err
	}

	req, err := r.marshal(c)
	if err != nil {
		return err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "POST", u, bytes.NewBuffer(req), c.Config.RetryProvider)
	if err != nil {
		return err
	}
	// wait for object to be created.
	var o operations.StandardGCPOperation
	if err := dcl.ParseResponse(resp.Response, &o); err != nil {
		return err
	}
	if err := o.Wait(ctx, c.Config, "https://arcus2tier2.sandbox.googleapis.com/v1alpha2/", "GET"); err != nil {
		c.Config.Logger.Warningf("Creation failed after waiting for operation: %v", err)
		return err
	}
	c.Config.Logger.Infof("Successfully waited for operation")
	op.response, _ = o.FirstResponse()

	if _, err := c.GetInstance(ctx, r.urlNormalized()); err != nil {
		c.Config.Logger.Warningf("get returned error: %v", err)
		return err
	}

	return nil
}

func (c *Client) getInstanceRaw(ctx context.Context, r *Instance) ([]byte, error) {

	u, err := instanceGetURL(c.Config.BasePath, r.urlNormalized())
	if err != nil {
		return nil, err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "GET", u, &bytes.Buffer{}, c.Config.RetryProvider)
	if err != nil {
		return nil, err
	}
	defer resp.Response.Body.Close()
	b, err := ioutil.ReadAll(resp.Response.Body)
	if err != nil {
		return nil, err
	}

	return b, nil
}

func (c *Client) instanceDiffsForRawDesired(ctx context.Context, rawDesired *Instance, opts ...dcl.ApplyOption) (initial, desired *Instance, diffs []instanceDiff, err error) {
	c.Config.Logger.Info("Fetching initial state...")
	// First, let us see if the user provided a state hint.  If they did, we will start fetching based on that.
	var fetchState *Instance
	if sh := dcl.FetchStateHint(opts); sh != nil {
		if r, ok := sh.(*Instance); !ok {
			c.Config.Logger.Warningf("Initial state hint was of the wrong type; expected Instance, got %T", sh)
		} else {
			fetchState = r
		}
	}
	if fetchState == nil {
		fetchState = rawDesired
	}

	// 1.2: Retrieval of raw initial state from API
	rawInitial, err := c.GetInstance(ctx, fetchState.urlNormalized())
	if rawInitial == nil {
		if !dcl.IsNotFound(err) {
			c.Config.Logger.Warningf("Failed to retrieve whether a Instance resource already exists: %s", err)
			return nil, nil, nil, fmt.Errorf("failed to retrieve Instance resource: %v", err)
		}
		c.Config.Logger.Info("Found that Instance resource did not exist.")
		// Perform canonicalization to pick up defaults.
		desired, err = canonicalizeInstanceDesiredState(rawDesired, rawInitial)
		return nil, desired, nil, err
	}

	c.Config.Logger.Infof("Found initial state for Instance: %v", rawInitial)
	c.Config.Logger.Infof("Initial desired state for Instance: %v", rawDesired)

	// 1.3: Canonicalize raw initial state into initial state.
	initial, err = canonicalizeInstanceInitialState(rawInitial, rawDesired)
	if err != nil {
		return nil, nil, nil, err
	}
	c.Config.Logger.Infof("Canonicalized initial state for Instance: %v", initial)

	// 1.4: Canonicalize raw desired state into desired state.
	desired, err = canonicalizeInstanceDesiredState(rawDesired, rawInitial, opts...)
	if err != nil {
		return nil, nil, nil, err
	}
	c.Config.Logger.Infof("Canonicalized desired state for Instance: %v", desired)

	// 2.1: Comparison of initial and desired state.
	diffs, err = diffInstance(c, desired, initial, opts...)
	return initial, desired, diffs, err
}

func canonicalizeInstanceInitialState(rawInitial, rawDesired *Instance) (*Instance, error) {
	// TODO(magic-modules-eng): write canonicalizer once relevant traits are added.
	return rawInitial, nil
}

/*
* Canonicalizers
*
* These are responsible for converting either a user-specified config or a
* GCP API response to a standard format that can be used for difference checking.
* */

func canonicalizeInstanceDesiredState(rawDesired, rawInitial *Instance, opts ...dcl.ApplyOption) (*Instance, error) {

	if rawInitial == nil {
		// Since the initial state is empty, the desired state is all we have.
		// We canonicalize the remaining nested objects with nil to pick up defaults.
		rawDesired.Sku = canonicalizeInstanceSku(rawDesired.Sku, nil, opts...)
		rawDesired.PreprocessCreateRecipe = canonicalizeInstancePreprocessCreateRecipe(rawDesired.PreprocessCreateRecipe, nil, opts...)
		rawDesired.InitiateCreateRecipe = canonicalizeInstanceInitiateCreateRecipe(rawDesired.InitiateCreateRecipe, nil, opts...)
		rawDesired.CreateRecipe = canonicalizeInstanceCreateRecipe(rawDesired.CreateRecipe, nil, opts...)
		rawDesired.DeleteRecipe = canonicalizeInstanceDeleteRecipe(rawDesired.DeleteRecipe, nil, opts...)
		rawDesired.UpdateRecipe = canonicalizeInstanceUpdateRecipe(rawDesired.UpdateRecipe, nil, opts...)
		rawDesired.PreprocessResetRecipe = canonicalizeInstancePreprocessResetRecipe(rawDesired.PreprocessResetRecipe, nil, opts...)
		rawDesired.InitiateResetRecipe = canonicalizeInstanceInitiateResetRecipe(rawDesired.InitiateResetRecipe, nil, opts...)
		rawDesired.ResetRecipe = canonicalizeInstanceResetRecipe(rawDesired.ResetRecipe, nil, opts...)
		rawDesired.PreprocessRepairRecipe = canonicalizeInstancePreprocessRepairRecipe(rawDesired.PreprocessRepairRecipe, nil, opts...)
		rawDesired.InitiateRepairRecipe = canonicalizeInstanceInitiateRepairRecipe(rawDesired.InitiateRepairRecipe, nil, opts...)
		rawDesired.RepairRecipe = canonicalizeInstanceRepairRecipe(rawDesired.RepairRecipe, nil, opts...)
		rawDesired.PreprocessDeleteRecipe = canonicalizeInstancePreprocessDeleteRecipe(rawDesired.PreprocessDeleteRecipe, nil, opts...)
		rawDesired.InitiateDeleteRecipe = canonicalizeInstanceInitiateDeleteRecipe(rawDesired.InitiateDeleteRecipe, nil, opts...)
		rawDesired.PreprocessUpdateRecipe = canonicalizeInstancePreprocessUpdateRecipe(rawDesired.PreprocessUpdateRecipe, nil, opts...)
		rawDesired.InitiateUpdateRecipe = canonicalizeInstanceInitiateUpdateRecipe(rawDesired.InitiateUpdateRecipe, nil, opts...)
		rawDesired.PreprocessFreezeRecipe = canonicalizeInstancePreprocessFreezeRecipe(rawDesired.PreprocessFreezeRecipe, nil, opts...)
		rawDesired.FreezeRecipe = canonicalizeInstanceFreezeRecipe(rawDesired.FreezeRecipe, nil, opts...)
		rawDesired.PreprocessUnfreezeRecipe = canonicalizeInstancePreprocessUnfreezeRecipe(rawDesired.PreprocessUnfreezeRecipe, nil, opts...)
		rawDesired.UnfreezeRecipe = canonicalizeInstanceUnfreezeRecipe(rawDesired.UnfreezeRecipe, nil, opts...)
		rawDesired.ReadonlyRecipe = canonicalizeInstanceReadonlyRecipe(rawDesired.ReadonlyRecipe, nil, opts...)

		return rawDesired, nil
	}
	if dcl.StringCanonicalize(rawDesired.Name, rawInitial.Name) {
		rawDesired.Name = rawInitial.Name
	}
	if dcl.StringCanonicalize(rawDesired.DisplayName, rawInitial.DisplayName) {
		rawDesired.DisplayName = rawInitial.DisplayName
	}
	if dcl.IsZeroValue(rawDesired.Labels) {
		rawDesired.Labels = rawInitial.Labels
	}
	if dcl.StringCanonicalize(rawDesired.Zone, rawInitial.Zone) {
		rawDesired.Zone = rawInitial.Zone
	}
	rawDesired.Sku = canonicalizeInstanceSku(rawDesired.Sku, rawInitial.Sku, opts...)
	if dcl.StringCanonicalize(rawDesired.AuthorizedNetworkId, rawInitial.AuthorizedNetworkId) {
		rawDesired.AuthorizedNetworkId = rawInitial.AuthorizedNetworkId
	}
	if dcl.StringCanonicalize(rawDesired.ReservedIPRange, rawInitial.ReservedIPRange) {
		rawDesired.ReservedIPRange = rawInitial.ReservedIPRange
	}
	if dcl.StringCanonicalize(rawDesired.HostName, rawInitial.HostName) {
		rawDesired.HostName = rawInitial.HostName
	}
	if dcl.IsZeroValue(rawDesired.PortNumber) {
		rawDesired.PortNumber = rawInitial.PortNumber
	}
	if dcl.StringCanonicalize(rawDesired.CurrentZone, rawInitial.CurrentZone) {
		rawDesired.CurrentZone = rawInitial.CurrentZone
	}
	if dcl.IsZeroValue(rawDesired.CreationTime) {
		rawDesired.CreationTime = rawInitial.CreationTime
	}
	if dcl.IsZeroValue(rawDesired.State) {
		rawDesired.State = rawInitial.State
	}
	if dcl.StringCanonicalize(rawDesired.StatusMessage, rawInitial.StatusMessage) {
		rawDesired.StatusMessage = rawInitial.StatusMessage
	}
	if dcl.StringCanonicalize(rawDesired.ExtraField, rawInitial.ExtraField) {
		rawDesired.ExtraField = rawInitial.ExtraField
	}
	rawDesired.PreprocessCreateRecipe = canonicalizeInstancePreprocessCreateRecipe(rawDesired.PreprocessCreateRecipe, rawInitial.PreprocessCreateRecipe, opts...)
	rawDesired.InitiateCreateRecipe = canonicalizeInstanceInitiateCreateRecipe(rawDesired.InitiateCreateRecipe, rawInitial.InitiateCreateRecipe, opts...)
	rawDesired.CreateRecipe = canonicalizeInstanceCreateRecipe(rawDesired.CreateRecipe, rawInitial.CreateRecipe, opts...)
	rawDesired.DeleteRecipe = canonicalizeInstanceDeleteRecipe(rawDesired.DeleteRecipe, rawInitial.DeleteRecipe, opts...)
	rawDesired.UpdateRecipe = canonicalizeInstanceUpdateRecipe(rawDesired.UpdateRecipe, rawInitial.UpdateRecipe, opts...)
	rawDesired.PreprocessResetRecipe = canonicalizeInstancePreprocessResetRecipe(rawDesired.PreprocessResetRecipe, rawInitial.PreprocessResetRecipe, opts...)
	rawDesired.InitiateResetRecipe = canonicalizeInstanceInitiateResetRecipe(rawDesired.InitiateResetRecipe, rawInitial.InitiateResetRecipe, opts...)
	rawDesired.ResetRecipe = canonicalizeInstanceResetRecipe(rawDesired.ResetRecipe, rawInitial.ResetRecipe, opts...)
	rawDesired.PreprocessRepairRecipe = canonicalizeInstancePreprocessRepairRecipe(rawDesired.PreprocessRepairRecipe, rawInitial.PreprocessRepairRecipe, opts...)
	rawDesired.InitiateRepairRecipe = canonicalizeInstanceInitiateRepairRecipe(rawDesired.InitiateRepairRecipe, rawInitial.InitiateRepairRecipe, opts...)
	rawDesired.RepairRecipe = canonicalizeInstanceRepairRecipe(rawDesired.RepairRecipe, rawInitial.RepairRecipe, opts...)
	rawDesired.PreprocessDeleteRecipe = canonicalizeInstancePreprocessDeleteRecipe(rawDesired.PreprocessDeleteRecipe, rawInitial.PreprocessDeleteRecipe, opts...)
	rawDesired.InitiateDeleteRecipe = canonicalizeInstanceInitiateDeleteRecipe(rawDesired.InitiateDeleteRecipe, rawInitial.InitiateDeleteRecipe, opts...)
	rawDesired.PreprocessUpdateRecipe = canonicalizeInstancePreprocessUpdateRecipe(rawDesired.PreprocessUpdateRecipe, rawInitial.PreprocessUpdateRecipe, opts...)
	rawDesired.InitiateUpdateRecipe = canonicalizeInstanceInitiateUpdateRecipe(rawDesired.InitiateUpdateRecipe, rawInitial.InitiateUpdateRecipe, opts...)
	rawDesired.PreprocessFreezeRecipe = canonicalizeInstancePreprocessFreezeRecipe(rawDesired.PreprocessFreezeRecipe, rawInitial.PreprocessFreezeRecipe, opts...)
	rawDesired.FreezeRecipe = canonicalizeInstanceFreezeRecipe(rawDesired.FreezeRecipe, rawInitial.FreezeRecipe, opts...)
	rawDesired.PreprocessUnfreezeRecipe = canonicalizeInstancePreprocessUnfreezeRecipe(rawDesired.PreprocessUnfreezeRecipe, rawInitial.PreprocessUnfreezeRecipe, opts...)
	rawDesired.UnfreezeRecipe = canonicalizeInstanceUnfreezeRecipe(rawDesired.UnfreezeRecipe, rawInitial.UnfreezeRecipe, opts...)
	rawDesired.ReadonlyRecipe = canonicalizeInstanceReadonlyRecipe(rawDesired.ReadonlyRecipe, rawInitial.ReadonlyRecipe, opts...)
	if dcl.BoolCanonicalize(rawDesired.EnableCallHistory, rawInitial.EnableCallHistory) {
		rawDesired.EnableCallHistory = rawInitial.EnableCallHistory
	}
	if dcl.IsZeroValue(rawDesired.History) {
		rawDesired.History = rawInitial.History
	}
	if dcl.StringCanonicalize(rawDesired.PublicResourceViewOverride, rawInitial.PublicResourceViewOverride) {
		rawDesired.PublicResourceViewOverride = rawInitial.PublicResourceViewOverride
	}
	if dcl.NameToSelfLink(rawDesired.Project, rawInitial.Project) {
		rawDesired.Project = rawInitial.Project
	}
	if dcl.NameToSelfLink(rawDesired.Location, rawInitial.Location) {
		rawDesired.Location = rawInitial.Location
	}

	return rawDesired, nil
}

func canonicalizeInstanceNewState(c *Client, rawNew, rawDesired *Instance) (*Instance, error) {

	if dcl.IsEmptyValueIndirect(rawNew.Name) && dcl.IsEmptyValueIndirect(rawDesired.Name) {
		rawNew.Name = rawDesired.Name
	} else {
		if dcl.StringCanonicalize(rawDesired.Name, rawNew.Name) {
			rawNew.Name = rawDesired.Name
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.DisplayName) && dcl.IsEmptyValueIndirect(rawDesired.DisplayName) {
		rawNew.DisplayName = rawDesired.DisplayName
	} else {
		if dcl.StringCanonicalize(rawDesired.DisplayName, rawNew.DisplayName) {
			rawNew.DisplayName = rawDesired.DisplayName
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.Labels) && dcl.IsEmptyValueIndirect(rawDesired.Labels) {
		rawNew.Labels = rawDesired.Labels
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.Zone) && dcl.IsEmptyValueIndirect(rawDesired.Zone) {
		rawNew.Zone = rawDesired.Zone
	} else {
		if dcl.StringCanonicalize(rawDesired.Zone, rawNew.Zone) {
			rawNew.Zone = rawDesired.Zone
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.Sku) && dcl.IsEmptyValueIndirect(rawDesired.Sku) {
		rawNew.Sku = rawDesired.Sku
	} else {
		rawNew.Sku = canonicalizeNewInstanceSku(c, rawDesired.Sku, rawNew.Sku)
	}

	if dcl.IsEmptyValueIndirect(rawNew.AuthorizedNetworkId) && dcl.IsEmptyValueIndirect(rawDesired.AuthorizedNetworkId) {
		rawNew.AuthorizedNetworkId = rawDesired.AuthorizedNetworkId
	} else {
		if dcl.StringCanonicalize(rawDesired.AuthorizedNetworkId, rawNew.AuthorizedNetworkId) {
			rawNew.AuthorizedNetworkId = rawDesired.AuthorizedNetworkId
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.ReservedIPRange) && dcl.IsEmptyValueIndirect(rawDesired.ReservedIPRange) {
		rawNew.ReservedIPRange = rawDesired.ReservedIPRange
	} else {
		if dcl.StringCanonicalize(rawDesired.ReservedIPRange, rawNew.ReservedIPRange) {
			rawNew.ReservedIPRange = rawDesired.ReservedIPRange
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.HostName) && dcl.IsEmptyValueIndirect(rawDesired.HostName) {
		rawNew.HostName = rawDesired.HostName
	} else {
		if dcl.StringCanonicalize(rawDesired.HostName, rawNew.HostName) {
			rawNew.HostName = rawDesired.HostName
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.PortNumber) && dcl.IsEmptyValueIndirect(rawDesired.PortNumber) {
		rawNew.PortNumber = rawDesired.PortNumber
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.CurrentZone) && dcl.IsEmptyValueIndirect(rawDesired.CurrentZone) {
		rawNew.CurrentZone = rawDesired.CurrentZone
	} else {
		if dcl.StringCanonicalize(rawDesired.CurrentZone, rawNew.CurrentZone) {
			rawNew.CurrentZone = rawDesired.CurrentZone
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.CreationTime) && dcl.IsEmptyValueIndirect(rawDesired.CreationTime) {
		rawNew.CreationTime = rawDesired.CreationTime
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.State) && dcl.IsEmptyValueIndirect(rawDesired.State) {
		rawNew.State = rawDesired.State
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.StatusMessage) && dcl.IsEmptyValueIndirect(rawDesired.StatusMessage) {
		rawNew.StatusMessage = rawDesired.StatusMessage
	} else {
		if dcl.StringCanonicalize(rawDesired.StatusMessage, rawNew.StatusMessage) {
			rawNew.StatusMessage = rawDesired.StatusMessage
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.ExtraField) && dcl.IsEmptyValueIndirect(rawDesired.ExtraField) {
		rawNew.ExtraField = rawDesired.ExtraField
	} else {
		if dcl.StringCanonicalize(rawDesired.ExtraField, rawNew.ExtraField) {
			rawNew.ExtraField = rawDesired.ExtraField
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessCreateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessCreateRecipe) {
		rawNew.PreprocessCreateRecipe = rawDesired.PreprocessCreateRecipe
	} else {
		rawNew.PreprocessCreateRecipe = canonicalizeNewInstancePreprocessCreateRecipe(c, rawDesired.PreprocessCreateRecipe, rawNew.PreprocessCreateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.InitiateCreateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.InitiateCreateRecipe) {
		rawNew.InitiateCreateRecipe = rawDesired.InitiateCreateRecipe
	} else {
		rawNew.InitiateCreateRecipe = canonicalizeNewInstanceInitiateCreateRecipe(c, rawDesired.InitiateCreateRecipe, rawNew.InitiateCreateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.CreateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.CreateRecipe) {
		rawNew.CreateRecipe = rawDesired.CreateRecipe
	} else {
		rawNew.CreateRecipe = canonicalizeNewInstanceCreateRecipe(c, rawDesired.CreateRecipe, rawNew.CreateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.DeleteRecipe) && dcl.IsEmptyValueIndirect(rawDesired.DeleteRecipe) {
		rawNew.DeleteRecipe = rawDesired.DeleteRecipe
	} else {
		rawNew.DeleteRecipe = canonicalizeNewInstanceDeleteRecipe(c, rawDesired.DeleteRecipe, rawNew.DeleteRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.UpdateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.UpdateRecipe) {
		rawNew.UpdateRecipe = rawDesired.UpdateRecipe
	} else {
		rawNew.UpdateRecipe = canonicalizeNewInstanceUpdateRecipe(c, rawDesired.UpdateRecipe, rawNew.UpdateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessResetRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessResetRecipe) {
		rawNew.PreprocessResetRecipe = rawDesired.PreprocessResetRecipe
	} else {
		rawNew.PreprocessResetRecipe = canonicalizeNewInstancePreprocessResetRecipe(c, rawDesired.PreprocessResetRecipe, rawNew.PreprocessResetRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.InitiateResetRecipe) && dcl.IsEmptyValueIndirect(rawDesired.InitiateResetRecipe) {
		rawNew.InitiateResetRecipe = rawDesired.InitiateResetRecipe
	} else {
		rawNew.InitiateResetRecipe = canonicalizeNewInstanceInitiateResetRecipe(c, rawDesired.InitiateResetRecipe, rawNew.InitiateResetRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.ResetRecipe) && dcl.IsEmptyValueIndirect(rawDesired.ResetRecipe) {
		rawNew.ResetRecipe = rawDesired.ResetRecipe
	} else {
		rawNew.ResetRecipe = canonicalizeNewInstanceResetRecipe(c, rawDesired.ResetRecipe, rawNew.ResetRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessRepairRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessRepairRecipe) {
		rawNew.PreprocessRepairRecipe = rawDesired.PreprocessRepairRecipe
	} else {
		rawNew.PreprocessRepairRecipe = canonicalizeNewInstancePreprocessRepairRecipe(c, rawDesired.PreprocessRepairRecipe, rawNew.PreprocessRepairRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.InitiateRepairRecipe) && dcl.IsEmptyValueIndirect(rawDesired.InitiateRepairRecipe) {
		rawNew.InitiateRepairRecipe = rawDesired.InitiateRepairRecipe
	} else {
		rawNew.InitiateRepairRecipe = canonicalizeNewInstanceInitiateRepairRecipe(c, rawDesired.InitiateRepairRecipe, rawNew.InitiateRepairRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.RepairRecipe) && dcl.IsEmptyValueIndirect(rawDesired.RepairRecipe) {
		rawNew.RepairRecipe = rawDesired.RepairRecipe
	} else {
		rawNew.RepairRecipe = canonicalizeNewInstanceRepairRecipe(c, rawDesired.RepairRecipe, rawNew.RepairRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessDeleteRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessDeleteRecipe) {
		rawNew.PreprocessDeleteRecipe = rawDesired.PreprocessDeleteRecipe
	} else {
		rawNew.PreprocessDeleteRecipe = canonicalizeNewInstancePreprocessDeleteRecipe(c, rawDesired.PreprocessDeleteRecipe, rawNew.PreprocessDeleteRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.InitiateDeleteRecipe) && dcl.IsEmptyValueIndirect(rawDesired.InitiateDeleteRecipe) {
		rawNew.InitiateDeleteRecipe = rawDesired.InitiateDeleteRecipe
	} else {
		rawNew.InitiateDeleteRecipe = canonicalizeNewInstanceInitiateDeleteRecipe(c, rawDesired.InitiateDeleteRecipe, rawNew.InitiateDeleteRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessUpdateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessUpdateRecipe) {
		rawNew.PreprocessUpdateRecipe = rawDesired.PreprocessUpdateRecipe
	} else {
		rawNew.PreprocessUpdateRecipe = canonicalizeNewInstancePreprocessUpdateRecipe(c, rawDesired.PreprocessUpdateRecipe, rawNew.PreprocessUpdateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.InitiateUpdateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.InitiateUpdateRecipe) {
		rawNew.InitiateUpdateRecipe = rawDesired.InitiateUpdateRecipe
	} else {
		rawNew.InitiateUpdateRecipe = canonicalizeNewInstanceInitiateUpdateRecipe(c, rawDesired.InitiateUpdateRecipe, rawNew.InitiateUpdateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessFreezeRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessFreezeRecipe) {
		rawNew.PreprocessFreezeRecipe = rawDesired.PreprocessFreezeRecipe
	} else {
		rawNew.PreprocessFreezeRecipe = canonicalizeNewInstancePreprocessFreezeRecipe(c, rawDesired.PreprocessFreezeRecipe, rawNew.PreprocessFreezeRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.FreezeRecipe) && dcl.IsEmptyValueIndirect(rawDesired.FreezeRecipe) {
		rawNew.FreezeRecipe = rawDesired.FreezeRecipe
	} else {
		rawNew.FreezeRecipe = canonicalizeNewInstanceFreezeRecipe(c, rawDesired.FreezeRecipe, rawNew.FreezeRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessUnfreezeRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessUnfreezeRecipe) {
		rawNew.PreprocessUnfreezeRecipe = rawDesired.PreprocessUnfreezeRecipe
	} else {
		rawNew.PreprocessUnfreezeRecipe = canonicalizeNewInstancePreprocessUnfreezeRecipe(c, rawDesired.PreprocessUnfreezeRecipe, rawNew.PreprocessUnfreezeRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.UnfreezeRecipe) && dcl.IsEmptyValueIndirect(rawDesired.UnfreezeRecipe) {
		rawNew.UnfreezeRecipe = rawDesired.UnfreezeRecipe
	} else {
		rawNew.UnfreezeRecipe = canonicalizeNewInstanceUnfreezeRecipe(c, rawDesired.UnfreezeRecipe, rawNew.UnfreezeRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.ReadonlyRecipe) && dcl.IsEmptyValueIndirect(rawDesired.ReadonlyRecipe) {
		rawNew.ReadonlyRecipe = rawDesired.ReadonlyRecipe
	} else {
		rawNew.ReadonlyRecipe = canonicalizeNewInstanceReadonlyRecipe(c, rawDesired.ReadonlyRecipe, rawNew.ReadonlyRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.EnableCallHistory) && dcl.IsEmptyValueIndirect(rawDesired.EnableCallHistory) {
		rawNew.EnableCallHistory = rawDesired.EnableCallHistory
	} else {
		if dcl.BoolCanonicalize(rawDesired.EnableCallHistory, rawNew.EnableCallHistory) {
			rawNew.EnableCallHistory = rawDesired.EnableCallHistory
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.History) && dcl.IsEmptyValueIndirect(rawDesired.History) {
		rawNew.History = rawDesired.History
	} else {
		rawNew.History = canonicalizeNewInstanceHistorySlice(c, rawDesired.History, rawNew.History)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PublicResourceViewOverride) && dcl.IsEmptyValueIndirect(rawDesired.PublicResourceViewOverride) {
		rawNew.PublicResourceViewOverride = rawDesired.PublicResourceViewOverride
	} else {
		if dcl.StringCanonicalize(rawDesired.PublicResourceViewOverride, rawNew.PublicResourceViewOverride) {
			rawNew.PublicResourceViewOverride = rawDesired.PublicResourceViewOverride
		}
	}

	rawNew.Project = rawDesired.Project

	rawNew.Location = rawDesired.Location

	return rawNew, nil
}

func canonicalizeInstanceSku(des, initial *InstanceSku, opts ...dcl.ApplyOption) *InstanceSku {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Tier) {
		des.Tier = initial.Tier
	}
	if dcl.IsZeroValue(des.Size) {
		des.Size = initial.Size
	}

	return des
}

func canonicalizeNewInstanceSku(c *Client, des, nw *InstanceSku) *InstanceSku {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceSkuSet(c *Client, des, nw []InstanceSku) []InstanceSku {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceSku
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceSku(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceSkuSlice(c *Client, des, nw []InstanceSku) []InstanceSku {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceSku
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceSku(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipe(des, initial *InstancePreprocessCreateRecipe, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipe(c *Client, des, nw *InstancePreprocessCreateRecipe) *InstancePreprocessCreateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessCreateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeSet(c *Client, des, nw []InstancePreprocessCreateRecipe) []InstancePreprocessCreateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeSlice(c *Client, des, nw []InstancePreprocessCreateRecipe) []InstancePreprocessCreateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeSteps(des, initial *InstancePreprocessCreateRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessCreateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessCreateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessCreateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeSteps(c *Client, des, nw *InstancePreprocessCreateRecipeSteps) *InstancePreprocessCreateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstancePreprocessCreateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsSet(c *Client, des, nw []InstancePreprocessCreateRecipeSteps) []InstancePreprocessCreateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeSteps) []InstancePreprocessCreateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsStatus(des, initial *InstancePreprocessCreateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatus(c *Client, des, nw *InstancePreprocessCreateRecipeStepsStatus) *InstancePreprocessCreateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsStatus) []InstancePreprocessCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsStatus) []InstancePreprocessCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsStatusDetails(des, initial *InstancePreprocessCreateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessCreateRecipeStepsStatusDetails) *InstancePreprocessCreateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsStatusDetails) []InstancePreprocessCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsStatusDetails) []InstancePreprocessCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessCreateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPreprocessUpdate) *InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPreprocessUpdate) []InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPreprocessUpdate) []InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessCreateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessCreateRecipeStepsRequestedTenantProject) *InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsRequestedTenantProject) []InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsRequestedTenantProject) []InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfo(des, initial *InstancePreprocessCreateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPermissionsInfo) *InstancePreprocessCreateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfo) []InstancePreprocessCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfo) []InstancePreprocessCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(des, initial *InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) *InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipe(des, initial *InstanceInitiateCreateRecipe, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipe(c *Client, des, nw *InstanceInitiateCreateRecipe) *InstanceInitiateCreateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceInitiateCreateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeSet(c *Client, des, nw []InstanceInitiateCreateRecipe) []InstanceInitiateCreateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeSlice(c *Client, des, nw []InstanceInitiateCreateRecipe) []InstanceInitiateCreateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeSteps(des, initial *InstanceInitiateCreateRecipeSteps, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceInitiateCreateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceInitiateCreateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceInitiateCreateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeSteps(c *Client, des, nw *InstanceInitiateCreateRecipeSteps) *InstanceInitiateCreateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceInitiateCreateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsSet(c *Client, des, nw []InstanceInitiateCreateRecipeSteps) []InstanceInitiateCreateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsSlice(c *Client, des, nw []InstanceInitiateCreateRecipeSteps) []InstanceInitiateCreateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsStatus(des, initial *InstanceInitiateCreateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsStatus(c *Client, des, nw *InstanceInitiateCreateRecipeStepsStatus) *InstanceInitiateCreateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceInitiateCreateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsStatusSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsStatus) []InstanceInitiateCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsStatusSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsStatus) []InstanceInitiateCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsStatusDetails(des, initial *InstanceInitiateCreateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsStatusDetails(c *Client, des, nw *InstanceInitiateCreateRecipeStepsStatusDetails) *InstanceInitiateCreateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsStatusDetails) []InstanceInitiateCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsStatusDetails) []InstanceInitiateCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(des, initial *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsPreprocessUpdate(des, initial *InstanceInitiateCreateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceInitiateCreateRecipeStepsPreprocessUpdate) *InstanceInitiateCreateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPreprocessUpdate) []InstanceInitiateCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPreprocessUpdate) []InstanceInitiateCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsRequestedTenantProject(des, initial *InstanceInitiateCreateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceInitiateCreateRecipeStepsRequestedTenantProject) *InstanceInitiateCreateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsRequestedTenantProject) []InstanceInitiateCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsRequestedTenantProject) []InstanceInitiateCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsPermissionsInfo(des, initial *InstanceInitiateCreateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceInitiateCreateRecipeStepsPermissionsInfo) *InstanceInitiateCreateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPermissionsInfo) []InstanceInitiateCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPermissionsInfo) []InstanceInitiateCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) *InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(des, initial *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipe(des, initial *InstanceCreateRecipe, opts ...dcl.ApplyOption) *InstanceCreateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceCreateRecipe(c *Client, des, nw *InstanceCreateRecipe) *InstanceCreateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceCreateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeSet(c *Client, des, nw []InstanceCreateRecipe) []InstanceCreateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeSlice(c *Client, des, nw []InstanceCreateRecipe) []InstanceCreateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeSteps(des, initial *InstanceCreateRecipeSteps, opts ...dcl.ApplyOption) *InstanceCreateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceCreateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceCreateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceCreateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeSteps(c *Client, des, nw *InstanceCreateRecipeSteps) *InstanceCreateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceCreateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsSet(c *Client, des, nw []InstanceCreateRecipeSteps) []InstanceCreateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsSlice(c *Client, des, nw []InstanceCreateRecipeSteps) []InstanceCreateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsStatus(des, initial *InstanceCreateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsStatus(c *Client, des, nw *InstanceCreateRecipeStepsStatus) *InstanceCreateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceCreateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsStatusSet(c *Client, des, nw []InstanceCreateRecipeStepsStatus) []InstanceCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsStatusSlice(c *Client, des, nw []InstanceCreateRecipeStepsStatus) []InstanceCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsStatusDetails(des, initial *InstanceCreateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsStatusDetails(c *Client, des, nw *InstanceCreateRecipeStepsStatusDetails) *InstanceCreateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceCreateRecipeStepsStatusDetails) []InstanceCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceCreateRecipeStepsStatusDetails) []InstanceCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsQuotaRequestDeltas(des, initial *InstanceCreateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceCreateRecipeStepsQuotaRequestDeltas) *InstanceCreateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceCreateRecipeStepsQuotaRequestDeltas) []InstanceCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceCreateRecipeStepsQuotaRequestDeltas) []InstanceCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPreprocessUpdate(des, initial *InstanceCreateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceCreateRecipeStepsPreprocessUpdate) *InstanceCreateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceCreateRecipeStepsPreprocessUpdate) []InstanceCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceCreateRecipeStepsPreprocessUpdate) []InstanceCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsRequestedTenantProject(des, initial *InstanceCreateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceCreateRecipeStepsRequestedTenantProject) *InstanceCreateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceCreateRecipeStepsRequestedTenantProject) []InstanceCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceCreateRecipeStepsRequestedTenantProject) []InstanceCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPermissionsInfo(des, initial *InstanceCreateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceCreateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceCreateRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceCreateRecipeStepsPermissionsInfo) *InstanceCreateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfo) []InstanceCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfo) []InstanceCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceCreateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceCreateRecipeStepsPermissionsInfoPolicyName) *InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoPolicyName) []InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoPolicyName) []InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceCreateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceCreateRecipeStepsPermissionsInfoIamPermissions) *InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoIamPermissions) []InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoIamPermissions) []InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceCreateRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceCreateRecipeStepsPermissionsInfoApiAttrs) *InstanceCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoApiAttrs) []InstanceCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoApiAttrs) []InstanceCreateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdate(des, initial *InstanceCreateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceCreateRecipeStepsKeyNotificationsUpdate) *InstanceCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdate) []InstanceCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdate) []InstanceCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipe(des, initial *InstanceDeleteRecipe, opts ...dcl.ApplyOption) *InstanceDeleteRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipe(c *Client, des, nw *InstanceDeleteRecipe) *InstanceDeleteRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceDeleteRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeSet(c *Client, des, nw []InstanceDeleteRecipe) []InstanceDeleteRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeSlice(c *Client, des, nw []InstanceDeleteRecipe) []InstanceDeleteRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeSteps(des, initial *InstanceDeleteRecipeSteps, opts ...dcl.ApplyOption) *InstanceDeleteRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceDeleteRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceDeleteRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceDeleteRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeSteps(c *Client, des, nw *InstanceDeleteRecipeSteps) *InstanceDeleteRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceDeleteRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsSet(c *Client, des, nw []InstanceDeleteRecipeSteps) []InstanceDeleteRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsSlice(c *Client, des, nw []InstanceDeleteRecipeSteps) []InstanceDeleteRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsStatus(des, initial *InstanceDeleteRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsStatus(c *Client, des, nw *InstanceDeleteRecipeStepsStatus) *InstanceDeleteRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceDeleteRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusSet(c *Client, des, nw []InstanceDeleteRecipeStepsStatus) []InstanceDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusSlice(c *Client, des, nw []InstanceDeleteRecipeStepsStatus) []InstanceDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsStatusDetails(des, initial *InstanceDeleteRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusDetails(c *Client, des, nw *InstanceDeleteRecipeStepsStatusDetails) *InstanceDeleteRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceDeleteRecipeStepsStatusDetails) []InstanceDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceDeleteRecipeStepsStatusDetails) []InstanceDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsQuotaRequestDeltas(des, initial *InstanceDeleteRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceDeleteRecipeStepsQuotaRequestDeltas) *InstanceDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceDeleteRecipeStepsQuotaRequestDeltas) []InstanceDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceDeleteRecipeStepsQuotaRequestDeltas) []InstanceDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPreprocessUpdate(des, initial *InstanceDeleteRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceDeleteRecipeStepsPreprocessUpdate) *InstanceDeleteRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceDeleteRecipeStepsPreprocessUpdate) []InstanceDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPreprocessUpdate) []InstanceDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsRequestedTenantProject(des, initial *InstanceDeleteRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceDeleteRecipeStepsRequestedTenantProject) *InstanceDeleteRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceDeleteRecipeStepsRequestedTenantProject) []InstanceDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceDeleteRecipeStepsRequestedTenantProject) []InstanceDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPermissionsInfo(des, initial *InstanceDeleteRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceDeleteRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceDeleteRecipeStepsPermissionsInfo) *InstanceDeleteRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfo) []InstanceDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfo) []InstanceDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceDeleteRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceDeleteRecipeStepsPermissionsInfoPolicyName) *InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoPolicyName) []InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoPolicyName) []InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceDeleteRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) *InstanceDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdate(des, initial *InstanceDeleteRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceDeleteRecipeStepsKeyNotificationsUpdate) *InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdate) []InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdate) []InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipe(des, initial *InstanceUpdateRecipe, opts ...dcl.ApplyOption) *InstanceUpdateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipe(c *Client, des, nw *InstanceUpdateRecipe) *InstanceUpdateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceUpdateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeSet(c *Client, des, nw []InstanceUpdateRecipe) []InstanceUpdateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeSlice(c *Client, des, nw []InstanceUpdateRecipe) []InstanceUpdateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeSteps(des, initial *InstanceUpdateRecipeSteps, opts ...dcl.ApplyOption) *InstanceUpdateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceUpdateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceUpdateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceUpdateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeSteps(c *Client, des, nw *InstanceUpdateRecipeSteps) *InstanceUpdateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceUpdateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsSet(c *Client, des, nw []InstanceUpdateRecipeSteps) []InstanceUpdateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsSlice(c *Client, des, nw []InstanceUpdateRecipeSteps) []InstanceUpdateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsStatus(des, initial *InstanceUpdateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsStatus(c *Client, des, nw *InstanceUpdateRecipeStepsStatus) *InstanceUpdateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceUpdateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusSet(c *Client, des, nw []InstanceUpdateRecipeStepsStatus) []InstanceUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusSlice(c *Client, des, nw []InstanceUpdateRecipeStepsStatus) []InstanceUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsStatusDetails(des, initial *InstanceUpdateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusDetails(c *Client, des, nw *InstanceUpdateRecipeStepsStatusDetails) *InstanceUpdateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceUpdateRecipeStepsStatusDetails) []InstanceUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceUpdateRecipeStepsStatusDetails) []InstanceUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsQuotaRequestDeltas(des, initial *InstanceUpdateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceUpdateRecipeStepsQuotaRequestDeltas) *InstanceUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceUpdateRecipeStepsQuotaRequestDeltas) []InstanceUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceUpdateRecipeStepsQuotaRequestDeltas) []InstanceUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPreprocessUpdate(des, initial *InstanceUpdateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceUpdateRecipeStepsPreprocessUpdate) *InstanceUpdateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceUpdateRecipeStepsPreprocessUpdate) []InstanceUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPreprocessUpdate) []InstanceUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsRequestedTenantProject(des, initial *InstanceUpdateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceUpdateRecipeStepsRequestedTenantProject) *InstanceUpdateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceUpdateRecipeStepsRequestedTenantProject) []InstanceUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceUpdateRecipeStepsRequestedTenantProject) []InstanceUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPermissionsInfo(des, initial *InstanceUpdateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceUpdateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceUpdateRecipeStepsPermissionsInfo) *InstanceUpdateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfo) []InstanceUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfo) []InstanceUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceUpdateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceUpdateRecipeStepsPermissionsInfoPolicyName) *InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoPolicyName) []InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoPolicyName) []InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceUpdateRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) *InstanceUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdate(des, initial *InstanceUpdateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceUpdateRecipeStepsKeyNotificationsUpdate) *InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdate) []InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdate) []InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipe(des, initial *InstancePreprocessResetRecipe, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipe(c *Client, des, nw *InstancePreprocessResetRecipe) *InstancePreprocessResetRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessResetRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeSet(c *Client, des, nw []InstancePreprocessResetRecipe) []InstancePreprocessResetRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeSlice(c *Client, des, nw []InstancePreprocessResetRecipe) []InstancePreprocessResetRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeSteps(des, initial *InstancePreprocessResetRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessResetRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessResetRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessResetRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeSteps(c *Client, des, nw *InstancePreprocessResetRecipeSteps) *InstancePreprocessResetRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstancePreprocessResetRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsSet(c *Client, des, nw []InstancePreprocessResetRecipeSteps) []InstancePreprocessResetRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsSlice(c *Client, des, nw []InstancePreprocessResetRecipeSteps) []InstancePreprocessResetRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsStatus(des, initial *InstancePreprocessResetRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatus(c *Client, des, nw *InstancePreprocessResetRecipeStepsStatus) *InstancePreprocessResetRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsStatus) []InstancePreprocessResetRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsStatus) []InstancePreprocessResetRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsStatusDetails(des, initial *InstancePreprocessResetRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessResetRecipeStepsStatusDetails) *InstancePreprocessResetRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsStatusDetails) []InstancePreprocessResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsStatusDetails) []InstancePreprocessResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessResetRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessResetRecipeStepsQuotaRequestDeltas) *InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsQuotaRequestDeltas) []InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsQuotaRequestDeltas) []InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessResetRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessResetRecipeStepsPreprocessUpdate) *InstancePreprocessResetRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPreprocessUpdate) []InstancePreprocessResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPreprocessUpdate) []InstancePreprocessResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessResetRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessResetRecipeStepsRequestedTenantProject) *InstancePreprocessResetRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsRequestedTenantProject) []InstancePreprocessResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsRequestedTenantProject) []InstancePreprocessResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfo(des, initial *InstancePreprocessResetRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessResetRecipeStepsPermissionsInfo) *InstancePreprocessResetRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfo) []InstancePreprocessResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfo) []InstancePreprocessResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(des, initial *InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) *InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipe(des, initial *InstanceInitiateResetRecipe, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipe(c *Client, des, nw *InstanceInitiateResetRecipe) *InstanceInitiateResetRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceInitiateResetRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeSet(c *Client, des, nw []InstanceInitiateResetRecipe) []InstanceInitiateResetRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeSlice(c *Client, des, nw []InstanceInitiateResetRecipe) []InstanceInitiateResetRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeSteps(des, initial *InstanceInitiateResetRecipeSteps, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceInitiateResetRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceInitiateResetRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceInitiateResetRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeSteps(c *Client, des, nw *InstanceInitiateResetRecipeSteps) *InstanceInitiateResetRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceInitiateResetRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceInitiateResetRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceInitiateResetRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsSet(c *Client, des, nw []InstanceInitiateResetRecipeSteps) []InstanceInitiateResetRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsSlice(c *Client, des, nw []InstanceInitiateResetRecipeSteps) []InstanceInitiateResetRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsStatus(des, initial *InstanceInitiateResetRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsStatus(c *Client, des, nw *InstanceInitiateResetRecipeStepsStatus) *InstanceInitiateResetRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceInitiateResetRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsStatusSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsStatus) []InstanceInitiateResetRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsStatusSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsStatus) []InstanceInitiateResetRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsStatusDetails(des, initial *InstanceInitiateResetRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsStatusDetails(c *Client, des, nw *InstanceInitiateResetRecipeStepsStatusDetails) *InstanceInitiateResetRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsStatusDetails) []InstanceInitiateResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsStatusDetails) []InstanceInitiateResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsQuotaRequestDeltas(des, initial *InstanceInitiateResetRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceInitiateResetRecipeStepsQuotaRequestDeltas) *InstanceInitiateResetRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsQuotaRequestDeltas) []InstanceInitiateResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsQuotaRequestDeltas) []InstanceInitiateResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsPreprocessUpdate(des, initial *InstanceInitiateResetRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceInitiateResetRecipeStepsPreprocessUpdate) *InstanceInitiateResetRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsPreprocessUpdate) []InstanceInitiateResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsPreprocessUpdate) []InstanceInitiateResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsRequestedTenantProject(des, initial *InstanceInitiateResetRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceInitiateResetRecipeStepsRequestedTenantProject) *InstanceInitiateResetRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsRequestedTenantProject) []InstanceInitiateResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsRequestedTenantProject) []InstanceInitiateResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsPermissionsInfo(des, initial *InstanceInitiateResetRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceInitiateResetRecipeStepsPermissionsInfo) *InstanceInitiateResetRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsPermissionsInfo) []InstanceInitiateResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsPermissionsInfo) []InstanceInitiateResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) *InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(des, initial *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipe(des, initial *InstanceResetRecipe, opts ...dcl.ApplyOption) *InstanceResetRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceResetRecipe(c *Client, des, nw *InstanceResetRecipe) *InstanceResetRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceResetRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeSet(c *Client, des, nw []InstanceResetRecipe) []InstanceResetRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeSlice(c *Client, des, nw []InstanceResetRecipe) []InstanceResetRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeSteps(des, initial *InstanceResetRecipeSteps, opts ...dcl.ApplyOption) *InstanceResetRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceResetRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceResetRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceResetRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceResetRecipeSteps(c *Client, des, nw *InstanceResetRecipeSteps) *InstanceResetRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceResetRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceResetRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceResetRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceResetRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsSet(c *Client, des, nw []InstanceResetRecipeSteps) []InstanceResetRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsSlice(c *Client, des, nw []InstanceResetRecipeSteps) []InstanceResetRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsStatus(des, initial *InstanceResetRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsStatus(c *Client, des, nw *InstanceResetRecipeStepsStatus) *InstanceResetRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceResetRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsStatusSet(c *Client, des, nw []InstanceResetRecipeStepsStatus) []InstanceResetRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsStatusSlice(c *Client, des, nw []InstanceResetRecipeStepsStatus) []InstanceResetRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsStatusDetails(des, initial *InstanceResetRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsStatusDetails(c *Client, des, nw *InstanceResetRecipeStepsStatusDetails) *InstanceResetRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceResetRecipeStepsStatusDetails) []InstanceResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceResetRecipeStepsStatusDetails) []InstanceResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsQuotaRequestDeltas(des, initial *InstanceResetRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceResetRecipeStepsQuotaRequestDeltas) *InstanceResetRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceResetRecipeStepsQuotaRequestDeltas) []InstanceResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceResetRecipeStepsQuotaRequestDeltas) []InstanceResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPreprocessUpdate(des, initial *InstanceResetRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceResetRecipeStepsPreprocessUpdate) *InstanceResetRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceResetRecipeStepsPreprocessUpdate) []InstanceResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceResetRecipeStepsPreprocessUpdate) []InstanceResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsRequestedTenantProject(des, initial *InstanceResetRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceResetRecipeStepsRequestedTenantProject) *InstanceResetRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceResetRecipeStepsRequestedTenantProject) []InstanceResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceResetRecipeStepsRequestedTenantProject) []InstanceResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPermissionsInfo(des, initial *InstanceResetRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceResetRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceResetRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceResetRecipeStepsPermissionsInfo) *InstanceResetRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfo) []InstanceResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfo) []InstanceResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceResetRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceResetRecipeStepsPermissionsInfoPolicyName) *InstanceResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoPolicyName) []InstanceResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoPolicyName) []InstanceResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceResetRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceResetRecipeStepsPermissionsInfoIamPermissions) *InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoIamPermissions) []InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoIamPermissions) []InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceResetRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceResetRecipeStepsPermissionsInfoApiAttrs) *InstanceResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoApiAttrs) []InstanceResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoApiAttrs) []InstanceResetRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdate(des, initial *InstanceResetRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceResetRecipeStepsKeyNotificationsUpdate) *InstanceResetRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdate) []InstanceResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdate) []InstanceResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipe(des, initial *InstancePreprocessRepairRecipe, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipe(c *Client, des, nw *InstancePreprocessRepairRecipe) *InstancePreprocessRepairRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessRepairRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeSet(c *Client, des, nw []InstancePreprocessRepairRecipe) []InstancePreprocessRepairRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeSlice(c *Client, des, nw []InstancePreprocessRepairRecipe) []InstancePreprocessRepairRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeSteps(des, initial *InstancePreprocessRepairRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessRepairRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessRepairRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessRepairRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeSteps(c *Client, des, nw *InstancePreprocessRepairRecipeSteps) *InstancePreprocessRepairRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstancePreprocessRepairRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsSet(c *Client, des, nw []InstancePreprocessRepairRecipeSteps) []InstancePreprocessRepairRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeSteps) []InstancePreprocessRepairRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsStatus(des, initial *InstancePreprocessRepairRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatus(c *Client, des, nw *InstancePreprocessRepairRecipeStepsStatus) *InstancePreprocessRepairRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsStatus) []InstancePreprocessRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsStatus) []InstancePreprocessRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsStatusDetails(des, initial *InstancePreprocessRepairRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessRepairRecipeStepsStatusDetails) *InstancePreprocessRepairRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsStatusDetails) []InstancePreprocessRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsStatusDetails) []InstancePreprocessRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessRepairRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPreprocessUpdate) *InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPreprocessUpdate) []InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPreprocessUpdate) []InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessRepairRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessRepairRecipeStepsRequestedTenantProject) *InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsRequestedTenantProject) []InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsRequestedTenantProject) []InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfo(des, initial *InstancePreprocessRepairRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPermissionsInfo) *InstancePreprocessRepairRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfo) []InstancePreprocessRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfo) []InstancePreprocessRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(des, initial *InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) *InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipe(des, initial *InstanceInitiateRepairRecipe, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipe(c *Client, des, nw *InstanceInitiateRepairRecipe) *InstanceInitiateRepairRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceInitiateRepairRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeSet(c *Client, des, nw []InstanceInitiateRepairRecipe) []InstanceInitiateRepairRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeSlice(c *Client, des, nw []InstanceInitiateRepairRecipe) []InstanceInitiateRepairRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeSteps(des, initial *InstanceInitiateRepairRecipeSteps, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceInitiateRepairRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceInitiateRepairRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceInitiateRepairRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeSteps(c *Client, des, nw *InstanceInitiateRepairRecipeSteps) *InstanceInitiateRepairRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceInitiateRepairRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsSet(c *Client, des, nw []InstanceInitiateRepairRecipeSteps) []InstanceInitiateRepairRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsSlice(c *Client, des, nw []InstanceInitiateRepairRecipeSteps) []InstanceInitiateRepairRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsStatus(des, initial *InstanceInitiateRepairRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsStatus(c *Client, des, nw *InstanceInitiateRepairRecipeStepsStatus) *InstanceInitiateRepairRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceInitiateRepairRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsStatusSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsStatus) []InstanceInitiateRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsStatusSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsStatus) []InstanceInitiateRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsStatusDetails(des, initial *InstanceInitiateRepairRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsStatusDetails(c *Client, des, nw *InstanceInitiateRepairRecipeStepsStatusDetails) *InstanceInitiateRepairRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsStatusDetails) []InstanceInitiateRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsStatusDetails) []InstanceInitiateRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(des, initial *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsPreprocessUpdate(des, initial *InstanceInitiateRepairRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceInitiateRepairRecipeStepsPreprocessUpdate) *InstanceInitiateRepairRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPreprocessUpdate) []InstanceInitiateRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPreprocessUpdate) []InstanceInitiateRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsRequestedTenantProject(des, initial *InstanceInitiateRepairRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceInitiateRepairRecipeStepsRequestedTenantProject) *InstanceInitiateRepairRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsRequestedTenantProject) []InstanceInitiateRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsRequestedTenantProject) []InstanceInitiateRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsPermissionsInfo(des, initial *InstanceInitiateRepairRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceInitiateRepairRecipeStepsPermissionsInfo) *InstanceInitiateRepairRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPermissionsInfo) []InstanceInitiateRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPermissionsInfo) []InstanceInitiateRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) *InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(des, initial *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipe(des, initial *InstanceRepairRecipe, opts ...dcl.ApplyOption) *InstanceRepairRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceRepairRecipe(c *Client, des, nw *InstanceRepairRecipe) *InstanceRepairRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceRepairRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeSet(c *Client, des, nw []InstanceRepairRecipe) []InstanceRepairRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeSlice(c *Client, des, nw []InstanceRepairRecipe) []InstanceRepairRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeSteps(des, initial *InstanceRepairRecipeSteps, opts ...dcl.ApplyOption) *InstanceRepairRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceRepairRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceRepairRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceRepairRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeSteps(c *Client, des, nw *InstanceRepairRecipeSteps) *InstanceRepairRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceRepairRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsSet(c *Client, des, nw []InstanceRepairRecipeSteps) []InstanceRepairRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsSlice(c *Client, des, nw []InstanceRepairRecipeSteps) []InstanceRepairRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsStatus(des, initial *InstanceRepairRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsStatus(c *Client, des, nw *InstanceRepairRecipeStepsStatus) *InstanceRepairRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceRepairRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsStatusSet(c *Client, des, nw []InstanceRepairRecipeStepsStatus) []InstanceRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsStatusSlice(c *Client, des, nw []InstanceRepairRecipeStepsStatus) []InstanceRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsStatusDetails(des, initial *InstanceRepairRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsStatusDetails(c *Client, des, nw *InstanceRepairRecipeStepsStatusDetails) *InstanceRepairRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceRepairRecipeStepsStatusDetails) []InstanceRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceRepairRecipeStepsStatusDetails) []InstanceRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsQuotaRequestDeltas(des, initial *InstanceRepairRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceRepairRecipeStepsQuotaRequestDeltas) *InstanceRepairRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceRepairRecipeStepsQuotaRequestDeltas) []InstanceRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceRepairRecipeStepsQuotaRequestDeltas) []InstanceRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPreprocessUpdate(des, initial *InstanceRepairRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceRepairRecipeStepsPreprocessUpdate) *InstanceRepairRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceRepairRecipeStepsPreprocessUpdate) []InstanceRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceRepairRecipeStepsPreprocessUpdate) []InstanceRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsRequestedTenantProject(des, initial *InstanceRepairRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceRepairRecipeStepsRequestedTenantProject) *InstanceRepairRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceRepairRecipeStepsRequestedTenantProject) []InstanceRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceRepairRecipeStepsRequestedTenantProject) []InstanceRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPermissionsInfo(des, initial *InstanceRepairRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceRepairRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceRepairRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceRepairRecipeStepsPermissionsInfo) *InstanceRepairRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfo) []InstanceRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfo) []InstanceRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceRepairRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceRepairRecipeStepsPermissionsInfoPolicyName) *InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoPolicyName) []InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoPolicyName) []InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceRepairRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceRepairRecipeStepsPermissionsInfoIamPermissions) *InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoIamPermissions) []InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoIamPermissions) []InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceRepairRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceRepairRecipeStepsPermissionsInfoApiAttrs) *InstanceRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoApiAttrs) []InstanceRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoApiAttrs) []InstanceRepairRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdate(des, initial *InstanceRepairRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceRepairRecipeStepsKeyNotificationsUpdate) *InstanceRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdate) []InstanceRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdate) []InstanceRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipe(des, initial *InstancePreprocessDeleteRecipe, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipe(c *Client, des, nw *InstancePreprocessDeleteRecipe) *InstancePreprocessDeleteRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessDeleteRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeSet(c *Client, des, nw []InstancePreprocessDeleteRecipe) []InstancePreprocessDeleteRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeSlice(c *Client, des, nw []InstancePreprocessDeleteRecipe) []InstancePreprocessDeleteRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeSteps(des, initial *InstancePreprocessDeleteRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessDeleteRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessDeleteRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessDeleteRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeSteps(c *Client, des, nw *InstancePreprocessDeleteRecipeSteps) *InstancePreprocessDeleteRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstancePreprocessDeleteRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeSteps) []InstancePreprocessDeleteRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeSteps) []InstancePreprocessDeleteRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsStatus(des, initial *InstancePreprocessDeleteRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatus(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsStatus) *InstancePreprocessDeleteRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsStatus) []InstancePreprocessDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsStatus) []InstancePreprocessDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsStatusDetails(des, initial *InstancePreprocessDeleteRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsStatusDetails) *InstancePreprocessDeleteRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsStatusDetails) []InstancePreprocessDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsStatusDetails) []InstancePreprocessDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessDeleteRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPreprocessUpdate) *InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPreprocessUpdate) []InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPreprocessUpdate) []InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessDeleteRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsRequestedTenantProject) *InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsRequestedTenantProject) []InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsRequestedTenantProject) []InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfo(des, initial *InstancePreprocessDeleteRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPermissionsInfo) *InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfo) []InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfo) []InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(des, initial *InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) *InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipe(des, initial *InstanceInitiateDeleteRecipe, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipe(c *Client, des, nw *InstanceInitiateDeleteRecipe) *InstanceInitiateDeleteRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceInitiateDeleteRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeSet(c *Client, des, nw []InstanceInitiateDeleteRecipe) []InstanceInitiateDeleteRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeSlice(c *Client, des, nw []InstanceInitiateDeleteRecipe) []InstanceInitiateDeleteRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeSteps(des, initial *InstanceInitiateDeleteRecipeSteps, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceInitiateDeleteRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceInitiateDeleteRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceInitiateDeleteRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeSteps(c *Client, des, nw *InstanceInitiateDeleteRecipeSteps) *InstanceInitiateDeleteRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceInitiateDeleteRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsSet(c *Client, des, nw []InstanceInitiateDeleteRecipeSteps) []InstanceInitiateDeleteRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeSteps) []InstanceInitiateDeleteRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsStatus(des, initial *InstanceInitiateDeleteRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsStatus(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsStatus) *InstanceInitiateDeleteRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceInitiateDeleteRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsStatusSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsStatus) []InstanceInitiateDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsStatusSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsStatus) []InstanceInitiateDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsStatusDetails(des, initial *InstanceInitiateDeleteRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsStatusDetails(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsStatusDetails) *InstanceInitiateDeleteRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsStatusDetails) []InstanceInitiateDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsStatusDetails) []InstanceInitiateDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(des, initial *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsPreprocessUpdate(des, initial *InstanceInitiateDeleteRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsPreprocessUpdate) *InstanceInitiateDeleteRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPreprocessUpdate) []InstanceInitiateDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPreprocessUpdate) []InstanceInitiateDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsRequestedTenantProject(des, initial *InstanceInitiateDeleteRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsRequestedTenantProject) *InstanceInitiateDeleteRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsRequestedTenantProject) []InstanceInitiateDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsRequestedTenantProject) []InstanceInitiateDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsPermissionsInfo(des, initial *InstanceInitiateDeleteRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsPermissionsInfo) *InstanceInitiateDeleteRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPermissionsInfo) []InstanceInitiateDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPermissionsInfo) []InstanceInitiateDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) *InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(des, initial *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipe(des, initial *InstancePreprocessUpdateRecipe, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipe(c *Client, des, nw *InstancePreprocessUpdateRecipe) *InstancePreprocessUpdateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessUpdateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeSet(c *Client, des, nw []InstancePreprocessUpdateRecipe) []InstancePreprocessUpdateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeSlice(c *Client, des, nw []InstancePreprocessUpdateRecipe) []InstancePreprocessUpdateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeSteps(des, initial *InstancePreprocessUpdateRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessUpdateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessUpdateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessUpdateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeSteps(c *Client, des, nw *InstancePreprocessUpdateRecipeSteps) *InstancePreprocessUpdateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstancePreprocessUpdateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeSteps) []InstancePreprocessUpdateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeSteps) []InstancePreprocessUpdateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsStatus(des, initial *InstancePreprocessUpdateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatus(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsStatus) *InstancePreprocessUpdateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsStatus) []InstancePreprocessUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsStatus) []InstancePreprocessUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsStatusDetails(des, initial *InstancePreprocessUpdateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsStatusDetails) *InstancePreprocessUpdateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsStatusDetails) []InstancePreprocessUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsStatusDetails) []InstancePreprocessUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessUpdateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPreprocessUpdate) *InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPreprocessUpdate) []InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPreprocessUpdate) []InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessUpdateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsRequestedTenantProject) *InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsRequestedTenantProject) []InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsRequestedTenantProject) []InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfo(des, initial *InstancePreprocessUpdateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPermissionsInfo) *InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfo) []InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfo) []InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(des, initial *InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) *InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipe(des, initial *InstanceInitiateUpdateRecipe, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipe(c *Client, des, nw *InstanceInitiateUpdateRecipe) *InstanceInitiateUpdateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceInitiateUpdateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeSet(c *Client, des, nw []InstanceInitiateUpdateRecipe) []InstanceInitiateUpdateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeSlice(c *Client, des, nw []InstanceInitiateUpdateRecipe) []InstanceInitiateUpdateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeSteps(des, initial *InstanceInitiateUpdateRecipeSteps, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceInitiateUpdateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceInitiateUpdateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceInitiateUpdateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeSteps(c *Client, des, nw *InstanceInitiateUpdateRecipeSteps) *InstanceInitiateUpdateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceInitiateUpdateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsSet(c *Client, des, nw []InstanceInitiateUpdateRecipeSteps) []InstanceInitiateUpdateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeSteps) []InstanceInitiateUpdateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsStatus(des, initial *InstanceInitiateUpdateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsStatus(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsStatus) *InstanceInitiateUpdateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceInitiateUpdateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsStatusSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsStatus) []InstanceInitiateUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsStatusSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsStatus) []InstanceInitiateUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsStatusDetails(des, initial *InstanceInitiateUpdateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsStatusDetails(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsStatusDetails) *InstanceInitiateUpdateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsStatusDetails) []InstanceInitiateUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsStatusDetails) []InstanceInitiateUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(des, initial *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsPreprocessUpdate(des, initial *InstanceInitiateUpdateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsPreprocessUpdate) *InstanceInitiateUpdateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPreprocessUpdate) []InstanceInitiateUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPreprocessUpdate) []InstanceInitiateUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsRequestedTenantProject(des, initial *InstanceInitiateUpdateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsRequestedTenantProject) *InstanceInitiateUpdateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsRequestedTenantProject) []InstanceInitiateUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsRequestedTenantProject) []InstanceInitiateUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsPermissionsInfo(des, initial *InstanceInitiateUpdateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsPermissionsInfo) *InstanceInitiateUpdateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPermissionsInfo) []InstanceInitiateUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPermissionsInfo) []InstanceInitiateUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) *InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(des, initial *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipe(des, initial *InstancePreprocessFreezeRecipe, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipe(c *Client, des, nw *InstancePreprocessFreezeRecipe) *InstancePreprocessFreezeRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessFreezeRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeSet(c *Client, des, nw []InstancePreprocessFreezeRecipe) []InstancePreprocessFreezeRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeSlice(c *Client, des, nw []InstancePreprocessFreezeRecipe) []InstancePreprocessFreezeRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeSteps(des, initial *InstancePreprocessFreezeRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessFreezeRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessFreezeRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessFreezeRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeSteps(c *Client, des, nw *InstancePreprocessFreezeRecipeSteps) *InstancePreprocessFreezeRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstancePreprocessFreezeRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeSteps) []InstancePreprocessFreezeRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeSteps) []InstancePreprocessFreezeRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsStatus(des, initial *InstancePreprocessFreezeRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatus(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsStatus) *InstancePreprocessFreezeRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsStatus) []InstancePreprocessFreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsStatus) []InstancePreprocessFreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsStatusDetails(des, initial *InstancePreprocessFreezeRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsStatusDetails) *InstancePreprocessFreezeRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsStatusDetails) []InstancePreprocessFreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsStatusDetails) []InstancePreprocessFreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessFreezeRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPreprocessUpdate) *InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPreprocessUpdate) []InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPreprocessUpdate) []InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessFreezeRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsRequestedTenantProject) *InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsRequestedTenantProject) []InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsRequestedTenantProject) []InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfo(des, initial *InstancePreprocessFreezeRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPermissionsInfo) *InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfo) []InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfo) []InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(des, initial *InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) *InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipe(des, initial *InstanceFreezeRecipe, opts ...dcl.ApplyOption) *InstanceFreezeRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipe(c *Client, des, nw *InstanceFreezeRecipe) *InstanceFreezeRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceFreezeRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeSet(c *Client, des, nw []InstanceFreezeRecipe) []InstanceFreezeRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeSlice(c *Client, des, nw []InstanceFreezeRecipe) []InstanceFreezeRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeSteps(des, initial *InstanceFreezeRecipeSteps, opts ...dcl.ApplyOption) *InstanceFreezeRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceFreezeRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceFreezeRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceFreezeRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeSteps(c *Client, des, nw *InstanceFreezeRecipeSteps) *InstanceFreezeRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceFreezeRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsSet(c *Client, des, nw []InstanceFreezeRecipeSteps) []InstanceFreezeRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsSlice(c *Client, des, nw []InstanceFreezeRecipeSteps) []InstanceFreezeRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsStatus(des, initial *InstanceFreezeRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsStatus(c *Client, des, nw *InstanceFreezeRecipeStepsStatus) *InstanceFreezeRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceFreezeRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusSet(c *Client, des, nw []InstanceFreezeRecipeStepsStatus) []InstanceFreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusSlice(c *Client, des, nw []InstanceFreezeRecipeStepsStatus) []InstanceFreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsStatusDetails(des, initial *InstanceFreezeRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusDetails(c *Client, des, nw *InstanceFreezeRecipeStepsStatusDetails) *InstanceFreezeRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceFreezeRecipeStepsStatusDetails) []InstanceFreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceFreezeRecipeStepsStatusDetails) []InstanceFreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsQuotaRequestDeltas(des, initial *InstanceFreezeRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceFreezeRecipeStepsQuotaRequestDeltas) *InstanceFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceFreezeRecipeStepsQuotaRequestDeltas) []InstanceFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceFreezeRecipeStepsQuotaRequestDeltas) []InstanceFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPreprocessUpdate(des, initial *InstanceFreezeRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceFreezeRecipeStepsPreprocessUpdate) *InstanceFreezeRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceFreezeRecipeStepsPreprocessUpdate) []InstanceFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPreprocessUpdate) []InstanceFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsRequestedTenantProject(des, initial *InstanceFreezeRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceFreezeRecipeStepsRequestedTenantProject) *InstanceFreezeRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceFreezeRecipeStepsRequestedTenantProject) []InstanceFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceFreezeRecipeStepsRequestedTenantProject) []InstanceFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPermissionsInfo(des, initial *InstanceFreezeRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceFreezeRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceFreezeRecipeStepsPermissionsInfo) *InstanceFreezeRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfo) []InstanceFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfo) []InstanceFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceFreezeRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceFreezeRecipeStepsPermissionsInfoPolicyName) *InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoPolicyName) []InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoPolicyName) []InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceFreezeRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) *InstanceFreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdate(des, initial *InstanceFreezeRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceFreezeRecipeStepsKeyNotificationsUpdate) *InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdate) []InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdate) []InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipe(des, initial *InstancePreprocessUnfreezeRecipe, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipe(c *Client, des, nw *InstancePreprocessUnfreezeRecipe) *InstancePreprocessUnfreezeRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipe) []InstancePreprocessUnfreezeRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipe) []InstancePreprocessUnfreezeRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeSteps(des, initial *InstancePreprocessUnfreezeRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessUnfreezeRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeSteps(c *Client, des, nw *InstancePreprocessUnfreezeRecipeSteps) *InstancePreprocessUnfreezeRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeSteps) []InstancePreprocessUnfreezeRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeSteps) []InstancePreprocessUnfreezeRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsStatus(des, initial *InstancePreprocessUnfreezeRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatus(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsStatus) *InstancePreprocessUnfreezeRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsStatus) []InstancePreprocessUnfreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsStatus) []InstancePreprocessUnfreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsStatusDetails(des, initial *InstancePreprocessUnfreezeRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsStatusDetails) *InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsStatusDetails) []InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsStatusDetails) []InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(des, initial *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(des, initial *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipe(des, initial *InstanceUnfreezeRecipe, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipe(c *Client, des, nw *InstanceUnfreezeRecipe) *InstanceUnfreezeRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceUnfreezeRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeSet(c *Client, des, nw []InstanceUnfreezeRecipe) []InstanceUnfreezeRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeSlice(c *Client, des, nw []InstanceUnfreezeRecipe) []InstanceUnfreezeRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeSteps(des, initial *InstanceUnfreezeRecipeSteps, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceUnfreezeRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceUnfreezeRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceUnfreezeRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeSteps(c *Client, des, nw *InstanceUnfreezeRecipeSteps) *InstanceUnfreezeRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceUnfreezeRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsSet(c *Client, des, nw []InstanceUnfreezeRecipeSteps) []InstanceUnfreezeRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsSlice(c *Client, des, nw []InstanceUnfreezeRecipeSteps) []InstanceUnfreezeRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsStatus(des, initial *InstanceUnfreezeRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatus(c *Client, des, nw *InstanceUnfreezeRecipeStepsStatus) *InstanceUnfreezeRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsStatus) []InstanceUnfreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsStatus) []InstanceUnfreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsStatusDetails(des, initial *InstanceUnfreezeRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetails(c *Client, des, nw *InstanceUnfreezeRecipeStepsStatusDetails) *InstanceUnfreezeRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsStatusDetails) []InstanceUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsStatusDetails) []InstanceUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsQuotaRequestDeltas(des, initial *InstanceUnfreezeRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceUnfreezeRecipeStepsQuotaRequestDeltas) *InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsQuotaRequestDeltas) []InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsQuotaRequestDeltas) []InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPreprocessUpdate(des, initial *InstanceUnfreezeRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceUnfreezeRecipeStepsPreprocessUpdate) *InstanceUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPreprocessUpdate) []InstanceUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPreprocessUpdate) []InstanceUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsRequestedTenantProject(des, initial *InstanceUnfreezeRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceUnfreezeRecipeStepsRequestedTenantProject) *InstanceUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsRequestedTenantProject) []InstanceUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsRequestedTenantProject) []InstanceUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfo(des, initial *InstanceUnfreezeRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceUnfreezeRecipeStepsPermissionsInfo) *InstanceUnfreezeRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfo) []InstanceUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfo) []InstanceUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) *InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(des, initial *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipe(des, initial *InstanceReadonlyRecipe, opts ...dcl.ApplyOption) *InstanceReadonlyRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipe(c *Client, des, nw *InstanceReadonlyRecipe) *InstanceReadonlyRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceReadonlyRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeSet(c *Client, des, nw []InstanceReadonlyRecipe) []InstanceReadonlyRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipe(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeSlice(c *Client, des, nw []InstanceReadonlyRecipe) []InstanceReadonlyRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeSteps(des, initial *InstanceReadonlyRecipeSteps, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceReadonlyRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceReadonlyRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceReadonlyRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeSteps(c *Client, des, nw *InstanceReadonlyRecipeSteps) *InstanceReadonlyRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	nw.Status = canonicalizeNewInstanceReadonlyRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsSet(c *Client, des, nw []InstanceReadonlyRecipeSteps) []InstanceReadonlyRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeSteps(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsSlice(c *Client, des, nw []InstanceReadonlyRecipeSteps) []InstanceReadonlyRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsStatus(des, initial *InstanceReadonlyRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatus(c *Client, des, nw *InstanceReadonlyRecipeStepsStatus) *InstanceReadonlyRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceReadonlyRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusSet(c *Client, des, nw []InstanceReadonlyRecipeStepsStatus) []InstanceReadonlyRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsStatus(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsStatus) []InstanceReadonlyRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsStatusDetails(des, initial *InstanceReadonlyRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusDetails(c *Client, des, nw *InstanceReadonlyRecipeStepsStatusDetails) *InstanceReadonlyRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceReadonlyRecipeStepsStatusDetails) []InstanceReadonlyRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsStatusDetails(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsStatusDetails) []InstanceReadonlyRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsQuotaRequestDeltas(des, initial *InstanceReadonlyRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceReadonlyRecipeStepsQuotaRequestDeltas) *InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceReadonlyRecipeStepsQuotaRequestDeltas) []InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsQuotaRequestDeltas) []InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPreprocessUpdate(des, initial *InstanceReadonlyRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceReadonlyRecipeStepsPreprocessUpdate) *InstanceReadonlyRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPreprocessUpdate) []InstanceReadonlyRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsPreprocessUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPreprocessUpdate) []InstanceReadonlyRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsRequestedTenantProject(des, initial *InstanceReadonlyRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceReadonlyRecipeStepsRequestedTenantProject) *InstanceReadonlyRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceReadonlyRecipeStepsRequestedTenantProject) []InstanceReadonlyRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsRequestedTenantProject(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsRequestedTenantProject) []InstanceReadonlyRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPermissionsInfo(des, initial *InstanceReadonlyRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceReadonlyRecipeStepsPermissionsInfo) *InstanceReadonlyRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfo) []InstanceReadonlyRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsPermissionsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfo) []InstanceReadonlyRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(des, initial *InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c *Client, des, nw *InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) *InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdate(des, initial *InstanceReadonlyRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceReadonlyRecipeStepsKeyNotificationsUpdate) *InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdate) []InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdate) []InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfigs = canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des.KeyConfigs, initial.KeyConfigs, opts...)
	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfigs = canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, des.KeyConfigs, nw.KeyConfigs)
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(des, initial *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyConfig = canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des.KeyConfig, initial.KeyConfig, opts...)

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, des, nw *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyConfig = canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, des.KeyConfig, nw.KeyConfig)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSet(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(des, initial *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, des, nw *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSet(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceHistory(des, initial *InstanceHistory, opts ...dcl.ApplyOption) *InstanceHistory {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Timestamp) {
		des.Timestamp = initial.Timestamp
	}
	if dcl.StringCanonicalize(des.OperationHandle, initial.OperationHandle) || dcl.IsZeroValue(des.OperationHandle) {
		des.OperationHandle = initial.OperationHandle
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.StepIndex) {
		des.StepIndex = initial.StepIndex
	}
	if dcl.IsZeroValue(des.TenantProjectNumber) {
		des.TenantProjectNumber = initial.TenantProjectNumber
	}
	if dcl.StringCanonicalize(des.TenantProjectId, initial.TenantProjectId) || dcl.IsZeroValue(des.TenantProjectId) {
		des.TenantProjectId = initial.TenantProjectId
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}

	return des
}

func canonicalizeNewInstanceHistory(c *Client, des, nw *InstanceHistory) *InstanceHistory {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.OperationHandle, nw.OperationHandle) {
		nw.OperationHandle = des.OperationHandle
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.StringCanonicalize(des.TenantProjectId, nw.TenantProjectId) {
		nw.TenantProjectId = des.TenantProjectId
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}

	return nw
}

func canonicalizeNewInstanceHistorySet(c *Client, des, nw []InstanceHistory) []InstanceHistory {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceHistory
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if !compareInstanceHistory(c, &d, &n) {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceHistorySlice(c *Client, des, nw []InstanceHistory) []InstanceHistory {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return des
	}

	var items []InstanceHistory
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceHistory(c, &d, &n))
	}

	return items
}

type instanceDiff struct {
	// The diff should include one or the other of RequiresRecreate or UpdateOp.
	RequiresRecreate bool
	UpdateOp         instanceApiOperation
	Diffs            []*dcl.FieldDiff
	// This is for reporting only.
	FieldName string
}

// The differ returns a list of diffs, along with a list of operations that should be taken
// to remedy them. Right now, it does not attempt to consolidate operations - if several
// fields can be fixed with a patch update, it will perform the patch several times.
// Diffs on some fields will be ignored if the `desired` state has an empty (nil)
// value. This empty value indicates that the user does not care about the state for
// the field. Empty fields on the actual object will cause diffs.
// TODO(magic-modules-eng): for efficiency in some resources, add batching.
func diffInstance(c *Client, desired, actual *Instance, opts ...dcl.ApplyOption) ([]instanceDiff, error) {
	if desired == nil || actual == nil {
		return nil, fmt.Errorf("nil resource passed to diff - always a programming error: %#v, %#v", desired, actual)
	}

	var diffs []instanceDiff

	var fn dcl.FieldName

	// New style diffs.
	if ds, err := dcl.Diff(desired.Name, actual.Name, dcl.Info{}, fn.AddNest("Name")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "Name",
		})
	}

	if ds, err := dcl.Diff(desired.DisplayName, actual.DisplayName, dcl.Info{}, fn.AddNest("DisplayName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "DisplayName",
		})
	}

	if ds, err := dcl.Diff(desired.Labels, actual.Labels, dcl.Info{}, fn.AddNest("Labels")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "Labels",
		})
	}

	if ds, err := dcl.Diff(desired.Zone, actual.Zone, dcl.Info{}, fn.AddNest("Zone")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "Zone",
		})
	}

	if ds, err := dcl.Diff(desired.Sku, actual.Sku, dcl.Info{ObjectFunction: compareInstanceSkuNewStyle}, fn.AddNest("Sku")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "Sku",
		})
	}

	if ds, err := dcl.Diff(desired.AuthorizedNetworkId, actual.AuthorizedNetworkId, dcl.Info{}, fn.AddNest("AuthorizedNetworkId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "AuthorizedNetworkId",
		})
	}

	if ds, err := dcl.Diff(desired.ReservedIPRange, actual.ReservedIPRange, dcl.Info{}, fn.AddNest("ReservedIPRange")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "ReservedIPRange",
		})
	}

	if ds, err := dcl.Diff(desired.HostName, actual.HostName, dcl.Info{}, fn.AddNest("HostName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "HostName",
		})
	}

	if ds, err := dcl.Diff(desired.PortNumber, actual.PortNumber, dcl.Info{}, fn.AddNest("PortNumber")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PortNumber",
		})
	}

	if ds, err := dcl.Diff(desired.CurrentZone, actual.CurrentZone, dcl.Info{}, fn.AddNest("CurrentZone")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "CurrentZone",
		})
	}

	if ds, err := dcl.Diff(desired.CreationTime, actual.CreationTime, dcl.Info{}, fn.AddNest("CreationTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "CreationTime",
		})
	}

	if ds, err := dcl.Diff(desired.State, actual.State, dcl.Info{Type: "EnumType"}, fn.AddNest("State")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "State",
		})
	}

	if ds, err := dcl.Diff(desired.StatusMessage, actual.StatusMessage, dcl.Info{}, fn.AddNest("StatusMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "StatusMessage",
		})
	}

	if ds, err := dcl.Diff(desired.ExtraField, actual.ExtraField, dcl.Info{}, fn.AddNest("ExtraField")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "ExtraField",
		})
	}

	if ds, err := dcl.Diff(desired.PreprocessCreateRecipe, actual.PreprocessCreateRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeNewStyle}, fn.AddNest("PreprocessCreateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PreprocessCreateRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.InitiateCreateRecipe, actual.InitiateCreateRecipe, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeNewStyle}, fn.AddNest("InitiateCreateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "InitiateCreateRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.CreateRecipe, actual.CreateRecipe, dcl.Info{ObjectFunction: compareInstanceCreateRecipeNewStyle}, fn.AddNest("CreateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "CreateRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.DeleteRecipe, actual.DeleteRecipe, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeNewStyle}, fn.AddNest("DeleteRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "DeleteRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.UpdateRecipe, actual.UpdateRecipe, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeNewStyle}, fn.AddNest("UpdateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "UpdateRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.PreprocessResetRecipe, actual.PreprocessResetRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeNewStyle}, fn.AddNest("PreprocessResetRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PreprocessResetRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.InitiateResetRecipe, actual.InitiateResetRecipe, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeNewStyle}, fn.AddNest("InitiateResetRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "InitiateResetRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.ResetRecipe, actual.ResetRecipe, dcl.Info{ObjectFunction: compareInstanceResetRecipeNewStyle}, fn.AddNest("ResetRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "ResetRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.PreprocessRepairRecipe, actual.PreprocessRepairRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeNewStyle}, fn.AddNest("PreprocessRepairRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PreprocessRepairRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.InitiateRepairRecipe, actual.InitiateRepairRecipe, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeNewStyle}, fn.AddNest("InitiateRepairRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "InitiateRepairRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.RepairRecipe, actual.RepairRecipe, dcl.Info{ObjectFunction: compareInstanceRepairRecipeNewStyle}, fn.AddNest("RepairRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "RepairRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.PreprocessDeleteRecipe, actual.PreprocessDeleteRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeNewStyle}, fn.AddNest("PreprocessDeleteRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PreprocessDeleteRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.InitiateDeleteRecipe, actual.InitiateDeleteRecipe, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeNewStyle}, fn.AddNest("InitiateDeleteRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "InitiateDeleteRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdateRecipe, actual.PreprocessUpdateRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeNewStyle}, fn.AddNest("PreprocessUpdateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PreprocessUpdateRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.InitiateUpdateRecipe, actual.InitiateUpdateRecipe, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeNewStyle}, fn.AddNest("InitiateUpdateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "InitiateUpdateRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.PreprocessFreezeRecipe, actual.PreprocessFreezeRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeNewStyle}, fn.AddNest("PreprocessFreezeRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PreprocessFreezeRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.FreezeRecipe, actual.FreezeRecipe, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeNewStyle}, fn.AddNest("FreezeRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "FreezeRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.PreprocessUnfreezeRecipe, actual.PreprocessUnfreezeRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeNewStyle}, fn.AddNest("PreprocessUnfreezeRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PreprocessUnfreezeRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.UnfreezeRecipe, actual.UnfreezeRecipe, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeNewStyle}, fn.AddNest("UnfreezeRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "UnfreezeRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipe, actual.ReadonlyRecipe, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeNewStyle}, fn.AddNest("ReadonlyRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "ReadonlyRecipe",
		})
	}

	if ds, err := dcl.Diff(desired.EnableCallHistory, actual.EnableCallHistory, dcl.Info{}, fn.AddNest("EnableCallHistory")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "EnableCallHistory",
		})
	}

	if ds, err := dcl.Diff(desired.History, actual.History, dcl.Info{ObjectFunction: compareInstanceHistoryNewStyle}, fn.AddNest("History")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "History",
		})
	}

	if ds, err := dcl.Diff(desired.PublicResourceViewOverride, actual.PublicResourceViewOverride, dcl.Info{}, fn.AddNest("PublicResourceViewOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{
			UpdateOp: &updateInstanceUpdateInstanceOperation{}, Diffs: ds,
			FieldName: "PublicResourceViewOverride",
		})
	}

	if ds, err := dcl.Diff(desired.Project, actual.Project, dcl.Info{}, fn.AddNest("Project")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{RequiresRecreate: true, Diffs: ds,
			FieldName: "Project",
		})
	}

	if ds, err := dcl.Diff(desired.Location, actual.Location, dcl.Info{}, fn.AddNest("Location")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, instanceDiff{RequiresRecreate: true, Diffs: ds,
			FieldName: "Location",
		})
	}

	// We need to ensure that this list does not contain identical operations *most of the time*.
	// There may be some cases where we will need multiple copies of the same operation - for instance,
	// if a resource has multiple prerequisite-containing fields.  For now, we don't know of any
	// such examples and so we deduplicate unconditionally.

	// The best way for us to do this is to iterate through the list
	// and remove any copies of operations which are identical to a previous operation.
	// This is O(n^2) in the number of operations, but n will always be very small,
	// even 10 would be an extremely high number.
	var opTypes []string
	var deduped []instanceDiff
	for _, d := range diffs {
		// Two operations are considered identical if they have the same type.
		// The type of an operation is derived from the name of the update method.
		if !dcl.StringSliceContains(fmt.Sprintf("%T", d.UpdateOp), opTypes) {
			deduped = append(deduped, d)
			opTypes = append(opTypes, fmt.Sprintf("%T", d.UpdateOp))
		} else {
			c.Config.Logger.Infof("Omitting planned operation of type %T since once is already scheduled.", d.UpdateOp)
		}
	}

	return deduped, nil
}
func compareInstanceSkuNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceSku)
	if !ok {
		desiredNotPointer, ok := d.(InstanceSku)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceSku or *InstanceSku", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceSku)
	if !ok {
		actualNotPointer, ok := a.(InstanceSku)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceSku", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tier, actual.Tier, dcl.Info{Type: "EnumType"}, fn.AddNest("Tier")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Size, actual.Size, dcl.Info{Type: "EnumType"}, fn.AddNest("Size")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceSku(c *Client, desired, actual *InstanceSku) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Tier, actual.Tier) && !dcl.IsZeroValue(desired.Tier) {
		c.Config.Logger.Infof("Diff in Tier.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tier), dcl.SprintResource(actual.Tier))
		return true
	}
	if !reflect.DeepEqual(desired.Size, actual.Size) && !dcl.IsZeroValue(desired.Size) {
		c.Config.Logger.Infof("Diff in Size.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Size), dcl.SprintResource(actual.Size))
		return true
	}
	return false
}

func compareInstanceSkuSlice(c *Client, desired, actual []InstanceSku) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceSku, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceSku(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceSku, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceSkuMap(c *Client, desired, actual map[string]InstanceSku) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceSku, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceSku, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceSku(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceSku, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipe or *InstancePreprocessCreateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipe(c *Client, desired, actual *InstancePreprocessCreateRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeSlice(c *Client, desired, actual []InstancePreprocessCreateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeSteps or *InstancePreprocessCreateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeSteps(c *Client, desired, actual *InstancePreprocessCreateRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsStatus or *InstancePreprocessCreateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsStatus(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsStatusSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsStatusMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsStatusDetails or *InstancePreprocessCreateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsStatusDetails(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsQuotaRequestDeltas or *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPreprocessUpdate or *InstancePreprocessCreateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsRequestedTenantProject or *InstancePreprocessCreateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfo or *InstancePreprocessCreateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfo(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate or *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipe or *InstanceInitiateCreateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipe(c *Client, desired, actual *InstanceInitiateCreateRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeSlice(c *Client, desired, actual []InstanceInitiateCreateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeSteps or *InstanceInitiateCreateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeSteps(c *Client, desired, actual *InstanceInitiateCreateRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsStatus or *InstanceInitiateCreateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsStatus(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsStatusSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsStatusDetails or *InstanceInitiateCreateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsStatusDetails(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsQuotaRequestDeltas or *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsPreprocessUpdate or *InstanceInitiateCreateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsRequestedTenantProject or *InstanceInitiateCreateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsPermissionsInfo or *InstanceInitiateCreateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName or *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions or *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate or *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipe or *InstanceCreateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipe(c *Client, desired, actual *InstanceCreateRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceCreateRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceCreateRecipeSlice(c *Client, desired, actual []InstanceCreateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeMap(c *Client, desired, actual map[string]InstanceCreateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeSteps or *InstanceCreateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeSteps(c *Client, desired, actual *InstanceCreateRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceCreateRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceCreateRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceCreateRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceCreateRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceCreateRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsSlice(c *Client, desired, actual []InstanceCreateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsMap(c *Client, desired, actual map[string]InstanceCreateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsStatus or *InstanceCreateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsStatus(c *Client, desired, actual *InstanceCreateRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceCreateRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsStatusSlice(c *Client, desired, actual []InstanceCreateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsStatusDetails or *InstanceCreateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsStatusDetails(c *Client, desired, actual *InstanceCreateRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceCreateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsQuotaRequestDeltas or *InstanceCreateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceCreateRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceCreateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPreprocessUpdate or *InstanceCreateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceCreateRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceCreateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsRequestedTenantProject or *InstanceCreateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceCreateRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceCreateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfo or *InstanceCreateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceCreateRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceCreateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfoPolicyName or *InstanceCreateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfoIamPermissions or *InstanceCreateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdate or *InstanceCreateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceCreateRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceCreateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipe or *InstanceDeleteRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipe(c *Client, desired, actual *InstanceDeleteRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceDeleteRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeSlice(c *Client, desired, actual []InstanceDeleteRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeMap(c *Client, desired, actual map[string]InstanceDeleteRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeSteps or *InstanceDeleteRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeSteps(c *Client, desired, actual *InstanceDeleteRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceDeleteRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceDeleteRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceDeleteRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceDeleteRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsSlice(c *Client, desired, actual []InstanceDeleteRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsMap(c *Client, desired, actual map[string]InstanceDeleteRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsStatus or *InstanceDeleteRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsStatus(c *Client, desired, actual *InstanceDeleteRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceDeleteRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsStatusSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsStatusDetails or *InstanceDeleteRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsStatusDetails(c *Client, desired, actual *InstanceDeleteRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsQuotaRequestDeltas or *InstanceDeleteRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceDeleteRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPreprocessUpdate or *InstanceDeleteRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceDeleteRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsRequestedTenantProject or *InstanceDeleteRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceDeleteRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfo or *InstanceDeleteRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceDeleteRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfoPolicyName or *InstanceDeleteRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfoIamPermissions or *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdate or *InstanceDeleteRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipe or *InstanceUpdateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipe(c *Client, desired, actual *InstanceUpdateRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUpdateRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeSlice(c *Client, desired, actual []InstanceUpdateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeMap(c *Client, desired, actual map[string]InstanceUpdateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeSteps or *InstanceUpdateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeSteps(c *Client, desired, actual *InstanceUpdateRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceUpdateRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceUpdateRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceUpdateRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceUpdateRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsSlice(c *Client, desired, actual []InstanceUpdateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsMap(c *Client, desired, actual map[string]InstanceUpdateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsStatus or *InstanceUpdateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsStatus(c *Client, desired, actual *InstanceUpdateRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceUpdateRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsStatusSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsStatusDetails or *InstanceUpdateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsStatusDetails(c *Client, desired, actual *InstanceUpdateRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsQuotaRequestDeltas or *InstanceUpdateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceUpdateRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPreprocessUpdate or *InstanceUpdateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceUpdateRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsRequestedTenantProject or *InstanceUpdateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceUpdateRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfo or *InstanceUpdateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceUpdateRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfoPolicyName or *InstanceUpdateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfoIamPermissions or *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdate or *InstanceUpdateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipe or *InstancePreprocessResetRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipe(c *Client, desired, actual *InstancePreprocessResetRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessResetRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeSlice(c *Client, desired, actual []InstancePreprocessResetRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeSteps or *InstancePreprocessResetRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeSteps(c *Client, desired, actual *InstancePreprocessResetRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsSlice(c *Client, desired, actual []InstancePreprocessResetRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsStatus or *InstancePreprocessResetRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsStatus(c *Client, desired, actual *InstancePreprocessResetRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsStatusSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsStatusMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsStatusDetails or *InstancePreprocessResetRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsStatusDetails(c *Client, desired, actual *InstancePreprocessResetRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsQuotaRequestDeltas or *InstancePreprocessResetRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstancePreprocessResetRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPreprocessUpdate or *InstancePreprocessResetRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstancePreprocessResetRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsRequestedTenantProject or *InstancePreprocessResetRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstancePreprocessResetRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfo or *InstancePreprocessResetRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfo(c *Client, desired, actual *InstancePreprocessResetRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdate or *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipe or *InstanceInitiateResetRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipe(c *Client, desired, actual *InstanceInitiateResetRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateResetRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeSlice(c *Client, desired, actual []InstanceInitiateResetRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeSteps or *InstanceInitiateResetRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeSteps(c *Client, desired, actual *InstanceInitiateResetRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsSlice(c *Client, desired, actual []InstanceInitiateResetRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsStatus or *InstanceInitiateResetRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsStatus(c *Client, desired, actual *InstanceInitiateResetRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsStatusSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsStatusDetails or *InstanceInitiateResetRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsStatusDetails(c *Client, desired, actual *InstanceInitiateResetRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsQuotaRequestDeltas or *InstanceInitiateResetRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceInitiateResetRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsPreprocessUpdate or *InstanceInitiateResetRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceInitiateResetRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsRequestedTenantProject or *InstanceInitiateResetRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceInitiateResetRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsPermissionsInfo or *InstanceInitiateResetRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceInitiateResetRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName or *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions or *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsKeyNotificationsUpdate or *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipe or *InstanceResetRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipe(c *Client, desired, actual *InstanceResetRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceResetRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceResetRecipeSlice(c *Client, desired, actual []InstanceResetRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeMap(c *Client, desired, actual map[string]InstanceResetRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeSteps or *InstanceResetRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeSteps(c *Client, desired, actual *InstanceResetRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceResetRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceResetRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceResetRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceResetRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceResetRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceResetRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsSlice(c *Client, desired, actual []InstanceResetRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsMap(c *Client, desired, actual map[string]InstanceResetRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsStatus or *InstanceResetRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsStatus(c *Client, desired, actual *InstanceResetRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceResetRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsStatusSlice(c *Client, desired, actual []InstanceResetRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsStatusDetails or *InstanceResetRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsStatusDetails(c *Client, desired, actual *InstanceResetRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceResetRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsQuotaRequestDeltas or *InstanceResetRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceResetRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceResetRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPreprocessUpdate or *InstanceResetRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceResetRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceResetRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsRequestedTenantProject or *InstanceResetRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceResetRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceResetRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfo or *InstanceResetRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceResetRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceResetRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceResetRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfoPolicyName or *InstanceResetRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceResetRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceResetRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfoIamPermissions or *InstanceResetRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceResetRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdate or *InstanceResetRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceResetRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceResetRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipe or *InstancePreprocessRepairRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipe(c *Client, desired, actual *InstancePreprocessRepairRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeSlice(c *Client, desired, actual []InstancePreprocessRepairRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeSteps or *InstancePreprocessRepairRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeSteps(c *Client, desired, actual *InstancePreprocessRepairRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsStatus or *InstancePreprocessRepairRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsStatus(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsStatusSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsStatusMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsStatusDetails or *InstancePreprocessRepairRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsStatusDetails(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsQuotaRequestDeltas or *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPreprocessUpdate or *InstancePreprocessRepairRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsRequestedTenantProject or *InstancePreprocessRepairRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfo or *InstancePreprocessRepairRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfo(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate or *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipe or *InstanceInitiateRepairRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipe(c *Client, desired, actual *InstanceInitiateRepairRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeSlice(c *Client, desired, actual []InstanceInitiateRepairRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeSteps or *InstanceInitiateRepairRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeSteps(c *Client, desired, actual *InstanceInitiateRepairRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsStatus or *InstanceInitiateRepairRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsStatus(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsStatusSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsStatusDetails or *InstanceInitiateRepairRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsStatusDetails(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsQuotaRequestDeltas or *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsPreprocessUpdate or *InstanceInitiateRepairRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsRequestedTenantProject or *InstanceInitiateRepairRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsPermissionsInfo or *InstanceInitiateRepairRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName or *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions or *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate or *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipe or *InstanceRepairRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipe(c *Client, desired, actual *InstanceRepairRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceRepairRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceRepairRecipeSlice(c *Client, desired, actual []InstanceRepairRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeMap(c *Client, desired, actual map[string]InstanceRepairRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeSteps or *InstanceRepairRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeSteps(c *Client, desired, actual *InstanceRepairRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceRepairRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceRepairRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceRepairRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceRepairRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceRepairRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsSlice(c *Client, desired, actual []InstanceRepairRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsMap(c *Client, desired, actual map[string]InstanceRepairRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsStatus or *InstanceRepairRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsStatus(c *Client, desired, actual *InstanceRepairRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceRepairRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsStatusSlice(c *Client, desired, actual []InstanceRepairRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsStatusDetails or *InstanceRepairRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsStatusDetails(c *Client, desired, actual *InstanceRepairRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceRepairRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsQuotaRequestDeltas or *InstanceRepairRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceRepairRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceRepairRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPreprocessUpdate or *InstanceRepairRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceRepairRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceRepairRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsRequestedTenantProject or *InstanceRepairRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceRepairRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceRepairRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfo or *InstanceRepairRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceRepairRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceRepairRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfoPolicyName or *InstanceRepairRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfoIamPermissions or *InstanceRepairRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdate or *InstanceRepairRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceRepairRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceRepairRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipe or *InstancePreprocessDeleteRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipe(c *Client, desired, actual *InstancePreprocessDeleteRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeSteps or *InstancePreprocessDeleteRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeSteps(c *Client, desired, actual *InstancePreprocessDeleteRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsStatus or *InstancePreprocessDeleteRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsStatus(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsStatusSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsStatusMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsStatusDetails or *InstancePreprocessDeleteRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsStatusDetails(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas or *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPreprocessUpdate or *InstancePreprocessDeleteRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsRequestedTenantProject or *InstancePreprocessDeleteRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfo or *InstancePreprocessDeleteRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfo(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate or *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipe or *InstanceInitiateDeleteRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipe(c *Client, desired, actual *InstanceInitiateDeleteRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeSteps or *InstanceInitiateDeleteRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeSteps(c *Client, desired, actual *InstanceInitiateDeleteRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsStatus or *InstanceInitiateDeleteRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsStatus(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsStatusSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsStatusDetails or *InstanceInitiateDeleteRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsStatusDetails(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas or *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsPreprocessUpdate or *InstanceInitiateDeleteRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsRequestedTenantProject or *InstanceInitiateDeleteRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsPermissionsInfo or *InstanceInitiateDeleteRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName or *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions or *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate or *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipe or *InstancePreprocessUpdateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipe(c *Client, desired, actual *InstancePreprocessUpdateRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeSteps or *InstancePreprocessUpdateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeSteps(c *Client, desired, actual *InstancePreprocessUpdateRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsStatus or *InstancePreprocessUpdateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsStatus(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsStatusSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsStatusMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsStatusDetails or *InstancePreprocessUpdateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsStatusDetails(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas or *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPreprocessUpdate or *InstancePreprocessUpdateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsRequestedTenantProject or *InstancePreprocessUpdateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfo or *InstancePreprocessUpdateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfo(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate or *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipe or *InstanceInitiateUpdateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipe(c *Client, desired, actual *InstanceInitiateUpdateRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeSteps or *InstanceInitiateUpdateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeSteps(c *Client, desired, actual *InstanceInitiateUpdateRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsStatus or *InstanceInitiateUpdateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsStatus(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsStatusSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsStatusDetails or *InstanceInitiateUpdateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsStatusDetails(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas or *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsPreprocessUpdate or *InstanceInitiateUpdateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsRequestedTenantProject or *InstanceInitiateUpdateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsPermissionsInfo or *InstanceInitiateUpdateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName or *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions or *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate or *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipe or *InstancePreprocessFreezeRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipe(c *Client, desired, actual *InstancePreprocessFreezeRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeSteps or *InstancePreprocessFreezeRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeSteps(c *Client, desired, actual *InstancePreprocessFreezeRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsStatus or *InstancePreprocessFreezeRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsStatus(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsStatusSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsStatusMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsStatusDetails or *InstancePreprocessFreezeRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsStatusDetails(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas or *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPreprocessUpdate or *InstancePreprocessFreezeRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsRequestedTenantProject or *InstancePreprocessFreezeRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfo or *InstancePreprocessFreezeRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfo(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate or *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipe or *InstanceFreezeRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipe(c *Client, desired, actual *InstanceFreezeRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceFreezeRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeSlice(c *Client, desired, actual []InstanceFreezeRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeMap(c *Client, desired, actual map[string]InstanceFreezeRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeSteps or *InstanceFreezeRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeSteps(c *Client, desired, actual *InstanceFreezeRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceFreezeRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceFreezeRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceFreezeRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceFreezeRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsSlice(c *Client, desired, actual []InstanceFreezeRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsMap(c *Client, desired, actual map[string]InstanceFreezeRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsStatus or *InstanceFreezeRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsStatus(c *Client, desired, actual *InstanceFreezeRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceFreezeRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsStatusSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsStatusDetails or *InstanceFreezeRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsStatusDetails(c *Client, desired, actual *InstanceFreezeRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsQuotaRequestDeltas or *InstanceFreezeRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceFreezeRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPreprocessUpdate or *InstanceFreezeRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceFreezeRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsRequestedTenantProject or *InstanceFreezeRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceFreezeRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfo or *InstanceFreezeRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceFreezeRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfoPolicyName or *InstanceFreezeRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceFreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfoIamPermissions or *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdate or *InstanceFreezeRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceFreezeRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipe or *InstancePreprocessUnfreezeRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipe(c *Client, desired, actual *InstancePreprocessUnfreezeRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeSteps or *InstancePreprocessUnfreezeRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeSteps(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsStatus or *InstancePreprocessUnfreezeRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsStatus(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsStatusDetails or *InstancePreprocessUnfreezeRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusDetails(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas or *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate or *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject or *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfo or *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate or *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipe or *InstanceUnfreezeRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipe(c *Client, desired, actual *InstanceUnfreezeRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUnfreezeRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeSlice(c *Client, desired, actual []InstanceUnfreezeRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeSteps or *InstanceUnfreezeRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeSteps(c *Client, desired, actual *InstanceUnfreezeRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsSlice(c *Client, desired, actual []InstanceUnfreezeRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsStatus or *InstanceUnfreezeRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsStatus(c *Client, desired, actual *InstanceUnfreezeRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsStatusSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsStatusDetails or *InstanceUnfreezeRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsStatusDetails(c *Client, desired, actual *InstanceUnfreezeRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsQuotaRequestDeltas or *InstanceUnfreezeRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceUnfreezeRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPreprocessUpdate or *InstanceUnfreezeRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceUnfreezeRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsRequestedTenantProject or *InstanceUnfreezeRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceUnfreezeRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfo or *InstanceUnfreezeRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceUnfreezeRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName or *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions or *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdate or *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipe or *InstanceReadonlyRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsNewStyle}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipe(c *Client, desired, actual *InstanceReadonlyRecipe) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceReadonlyRecipeStepsSlice(c, desired.Steps, actual.Steps) && !dcl.IsZeroValue(desired.Steps) {
		c.Config.Logger.Infof("Diff in Steps.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Steps), dcl.SprintResource(actual.Steps))
		return true
	}
	if !dcl.BoolCanonicalize(desired.HonorCancelRequest, actual.HonorCancelRequest) && !dcl.IsZeroValue(desired.HonorCancelRequest) {
		c.Config.Logger.Infof("Diff in HonorCancelRequest.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.HonorCancelRequest), dcl.SprintResource(actual.HonorCancelRequest))
		return true
	}
	if !reflect.DeepEqual(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter) && !dcl.IsZeroValue(desired.IgnoreRecipeAfter) {
		c.Config.Logger.Infof("Diff in IgnoreRecipeAfter.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IgnoreRecipeAfter), dcl.SprintResource(actual.IgnoreRecipeAfter))
		return true
	}
	if !reflect.DeepEqual(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow) && !dcl.IsZeroValue(desired.VerifyDeadlineSecondsBelow) {
		c.Config.Logger.Infof("Diff in VerifyDeadlineSecondsBelow.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.VerifyDeadlineSecondsBelow), dcl.SprintResource(actual.VerifyDeadlineSecondsBelow))
		return true
	}
	if !dcl.BoolCanonicalize(desired.PopulateOperationResult, actual.PopulateOperationResult) && !dcl.IsZeroValue(desired.PopulateOperationResult) {
		c.Config.Logger.Infof("Diff in PopulateOperationResult.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PopulateOperationResult), dcl.SprintResource(actual.PopulateOperationResult))
		return true
	}
	if !reflect.DeepEqual(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime) && !dcl.IsZeroValue(desired.ReadonlyRecipeStartTime) {
		c.Config.Logger.Infof("Diff in ReadonlyRecipeStartTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ReadonlyRecipeStartTime), dcl.SprintResource(actual.ReadonlyRecipeStartTime))
		return true
	}
	if !dcl.StringSliceEquals(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay) && !dcl.IsZeroValue(desired.ResourceNamesStoredInClhWithDelay) {
		c.Config.Logger.Infof("Diff in ResourceNamesStoredInClhWithDelay.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceNamesStoredInClhWithDelay), dcl.SprintResource(actual.ResourceNamesStoredInClhWithDelay))
		return true
	}
	if !reflect.DeepEqual(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos) && !dcl.IsZeroValue(desired.DelayToStoreResourcesInClhDbNanos) {
		c.Config.Logger.Infof("Diff in DelayToStoreResourcesInClhDbNanos.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DelayToStoreResourcesInClhDbNanos), dcl.SprintResource(actual.DelayToStoreResourcesInClhDbNanos))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeSlice(c *Client, desired, actual []InstanceReadonlyRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipe, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipe(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipe, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeMap(c *Client, desired, actual map[string]InstanceReadonlyRecipe) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipe, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipe, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipe(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipe, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeSteps or *InstanceReadonlyRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType"}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsStatusNewStyle}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsQuotaRequestDeltasNewStyle}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPreprocessUpdateNewStyle}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsRequestedTenantProjectNewStyle}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPermissionsInfoNewStyle}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateNewStyle}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeSteps(c *Client, desired, actual *InstanceReadonlyRecipeSteps) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.RelativeTime, actual.RelativeTime) && !dcl.IsZeroValue(desired.RelativeTime) {
		c.Config.Logger.Infof("Diff in RelativeTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RelativeTime), dcl.SprintResource(actual.RelativeTime))
		return true
	}
	if !reflect.DeepEqual(desired.SleepDuration, actual.SleepDuration) && !dcl.IsZeroValue(desired.SleepDuration) {
		c.Config.Logger.Infof("Diff in SleepDuration.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.SleepDuration), dcl.SprintResource(actual.SleepDuration))
		return true
	}
	if !reflect.DeepEqual(desired.Action, actual.Action) && !dcl.IsZeroValue(desired.Action) {
		c.Config.Logger.Infof("Diff in Action.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Action), dcl.SprintResource(actual.Action))
		return true
	}
	if compareInstanceReadonlyRecipeStepsStatus(c, desired.Status, actual.Status) && !dcl.IsZeroValue(desired.Status) {
		c.Config.Logger.Infof("Diff in Status.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Status), dcl.SprintResource(actual.Status))
		return true
	}
	if !dcl.StringCanonicalize(desired.ErrorSpace, actual.ErrorSpace) && !dcl.IsZeroValue(desired.ErrorSpace) {
		c.Config.Logger.Infof("Diff in ErrorSpace.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ErrorSpace), dcl.SprintResource(actual.ErrorSpace))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	if !reflect.DeepEqual(desired.ResourceMetadataSize, actual.ResourceMetadataSize) && !dcl.IsZeroValue(desired.ResourceMetadataSize) {
		c.Config.Logger.Infof("Diff in ResourceMetadataSize.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourceMetadataSize), dcl.SprintResource(actual.ResourceMetadataSize))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec) && !dcl.IsZeroValue(desired.UpdatedRepeatOperationDelaySec) {
		c.Config.Logger.Infof("Diff in UpdatedRepeatOperationDelaySec.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.UpdatedRepeatOperationDelaySec), dcl.SprintResource(actual.UpdatedRepeatOperationDelaySec))
		return true
	}
	if compareInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c, desired.QuotaRequestDeltas, actual.QuotaRequestDeltas) && !dcl.IsZeroValue(desired.QuotaRequestDeltas) {
		c.Config.Logger.Infof("Diff in QuotaRequestDeltas.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.QuotaRequestDeltas), dcl.SprintResource(actual.QuotaRequestDeltas))
		return true
	}
	if compareInstanceReadonlyRecipeStepsPreprocessUpdate(c, desired.PreprocessUpdate, actual.PreprocessUpdate) && !dcl.IsZeroValue(desired.PreprocessUpdate) {
		c.Config.Logger.Infof("Diff in PreprocessUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PreprocessUpdate), dcl.SprintResource(actual.PreprocessUpdate))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	if compareInstanceReadonlyRecipeStepsRequestedTenantProject(c, desired.RequestedTenantProject, actual.RequestedTenantProject) && !dcl.IsZeroValue(desired.RequestedTenantProject) {
		c.Config.Logger.Infof("Diff in RequestedTenantProject.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.RequestedTenantProject), dcl.SprintResource(actual.RequestedTenantProject))
		return true
	}
	if compareInstanceReadonlyRecipeStepsPermissionsInfoSlice(c, desired.PermissionsInfo, actual.PermissionsInfo) && !dcl.IsZeroValue(desired.PermissionsInfo) {
		c.Config.Logger.Infof("Diff in PermissionsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PermissionsInfo), dcl.SprintResource(actual.PermissionsInfo))
		return true
	}
	if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate) && !dcl.IsZeroValue(desired.KeyNotificationsUpdate) {
		c.Config.Logger.Infof("Diff in KeyNotificationsUpdate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsUpdate), dcl.SprintResource(actual.KeyNotificationsUpdate))
		return true
	}
	if !reflect.DeepEqual(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime) && !dcl.IsZeroValue(desired.ClhDataUpdateTime) {
		c.Config.Logger.Infof("Diff in ClhDataUpdateTime.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ClhDataUpdateTime), dcl.SprintResource(actual.ClhDataUpdateTime))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsSlice(c *Client, desired, actual []InstanceReadonlyRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeSteps, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeSteps(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeSteps, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeSteps) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeSteps, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeSteps, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeSteps(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeSteps, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsStatus or *InstanceReadonlyRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsStatusDetailsNewStyle}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsStatus(c *Client, desired, actual *InstanceReadonlyRecipeStepsStatus) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Code, actual.Code) && !dcl.IsZeroValue(desired.Code) {
		c.Config.Logger.Infof("Diff in Code.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Code), dcl.SprintResource(actual.Code))
		return true
	}
	if !dcl.StringCanonicalize(desired.Message, actual.Message) && !dcl.IsZeroValue(desired.Message) {
		c.Config.Logger.Infof("Diff in Message.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Message), dcl.SprintResource(actual.Message))
		return true
	}
	if compareInstanceReadonlyRecipeStepsStatusDetailsSlice(c, desired.Details, actual.Details) && !dcl.IsZeroValue(desired.Details) {
		c.Config.Logger.Infof("Diff in Details.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Details), dcl.SprintResource(actual.Details))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsStatusSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsStatus, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsStatus(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsStatus, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsStatusMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsStatus) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsStatus, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsStatus, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsStatus(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsStatus, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsStatusDetails or *InstanceReadonlyRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsStatusDetails(c *Client, desired, actual *InstanceReadonlyRecipeStepsStatusDetails) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.TypeUrl, actual.TypeUrl) && !dcl.IsZeroValue(desired.TypeUrl) {
		c.Config.Logger.Infof("Diff in TypeUrl.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TypeUrl), dcl.SprintResource(actual.TypeUrl))
		return true
	}
	if !dcl.StringCanonicalize(desired.Value, actual.Value) && !dcl.IsZeroValue(desired.Value) {
		c.Config.Logger.Infof("Diff in Value.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Value), dcl.SprintResource(actual.Value))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsStatusDetailsSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsStatusDetails(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsStatusDetails, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsStatusDetailsMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsStatusDetails) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsStatusDetails, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsStatusDetails, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsStatusDetails(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsStatusDetails, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsQuotaRequestDeltas or *InstanceReadonlyRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsQuotaRequestDeltas(c *Client, desired, actual *InstanceReadonlyRecipeStepsQuotaRequestDeltas) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.MetricName, actual.MetricName) && !dcl.IsZeroValue(desired.MetricName) {
		c.Config.Logger.Infof("Diff in MetricName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.MetricName), dcl.SprintResource(actual.MetricName))
		return true
	}
	if !reflect.DeepEqual(desired.Amount, actual.Amount) && !dcl.IsZeroValue(desired.Amount) {
		c.Config.Logger.Infof("Diff in Amount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Amount), dcl.SprintResource(actual.Amount))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsQuotaRequestDeltas, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsQuotaRequestDeltasMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsQuotaRequestDeltas, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsQuotaRequestDeltas, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsQuotaRequestDeltas, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPreprocessUpdate or *InstanceReadonlyRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPreprocessUpdate(c *Client, desired, actual *InstanceReadonlyRecipeStepsPreprocessUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.LatencySloBucketName, actual.LatencySloBucketName) && !dcl.IsZeroValue(desired.LatencySloBucketName) {
		c.Config.Logger.Infof("Diff in LatencySloBucketName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.LatencySloBucketName), dcl.SprintResource(actual.LatencySloBucketName))
		return true
	}
	if !dcl.StringCanonicalize(desired.PublicOperationMetadata, actual.PublicOperationMetadata) && !dcl.IsZeroValue(desired.PublicOperationMetadata) {
		c.Config.Logger.Infof("Diff in PublicOperationMetadata.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PublicOperationMetadata), dcl.SprintResource(actual.PublicOperationMetadata))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPreprocessUpdateSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsPreprocessUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPreprocessUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPreprocessUpdateMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsPreprocessUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPreprocessUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPreprocessUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsPreprocessUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPreprocessUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsRequestedTenantProject or *InstanceReadonlyRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType"}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsRequestedTenantProject(c *Client, desired, actual *InstanceReadonlyRecipeStepsRequestedTenantProject) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Tag, actual.Tag) && !dcl.IsZeroValue(desired.Tag) {
		c.Config.Logger.Infof("Diff in Tag.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Tag), dcl.SprintResource(actual.Tag))
		return true
	}
	if !dcl.StringCanonicalize(desired.Folder, actual.Folder) && !dcl.IsZeroValue(desired.Folder) {
		c.Config.Logger.Infof("Diff in Folder.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Folder), dcl.SprintResource(actual.Folder))
		return true
	}
	if !reflect.DeepEqual(desired.Scope, actual.Scope) && !dcl.IsZeroValue(desired.Scope) {
		c.Config.Logger.Infof("Diff in Scope.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Scope), dcl.SprintResource(actual.Scope))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsRequestedTenantProjectSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsRequestedTenantProject(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsRequestedTenantProject, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsRequestedTenantProjectMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsRequestedTenantProject) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsRequestedTenantProject, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsRequestedTenantProject, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsRequestedTenantProject(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsRequestedTenantProject, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfo or *InstanceReadonlyRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameNewStyle}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsNewStyle}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsNewStyle}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPermissionsInfo(c *Client, desired, actual *InstanceReadonlyRecipeStepsPermissionsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, desired.PolicyName, actual.PolicyName) && !dcl.IsZeroValue(desired.PolicyName) {
		c.Config.Logger.Infof("Diff in PolicyName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.PolicyName), dcl.SprintResource(actual.PolicyName))
		return true
	}
	if compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c, desired.IamPermissions, actual.IamPermissions) && !dcl.IsZeroValue(desired.IamPermissions) {
		c.Config.Logger.Infof("Diff in IamPermissions.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.IamPermissions), dcl.SprintResource(actual.IamPermissions))
		return true
	}
	if !dcl.StringCanonicalize(desired.ResourcePath, actual.ResourcePath) && !dcl.IsZeroValue(desired.ResourcePath) {
		c.Config.Logger.Infof("Diff in ResourcePath.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ResourcePath), dcl.SprintResource(actual.ResourcePath))
		return true
	}
	if compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, desired.ApiAttrs, actual.ApiAttrs) && !dcl.IsZeroValue(desired.ApiAttrs) {
		c.Config.Logger.Infof("Diff in ApiAttrs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.ApiAttrs), dcl.SprintResource(actual.ApiAttrs))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsPermissionsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsPermissionsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPermissionsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsPermissionsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfoPolicyName or *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c *Client, desired, actual *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Type, actual.Type) && !dcl.IsZeroValue(desired.Type) {
		c.Config.Logger.Infof("Diff in Type.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Type), dcl.SprintResource(actual.Type))
		return true
	}
	if !dcl.StringCanonicalize(desired.Id, actual.Id) && !dcl.IsZeroValue(desired.Id) {
		c.Config.Logger.Infof("Diff in Id.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Id), dcl.SprintResource(actual.Id))
		return true
	}
	if !dcl.StringCanonicalize(desired.Region, actual.Region) && !dcl.IsZeroValue(desired.Region) {
		c.Config.Logger.Infof("Diff in Region.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Region), dcl.SprintResource(actual.Region))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions or *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c *Client, desired, actual *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.Permission, actual.Permission) && !dcl.IsZeroValue(desired.Permission) {
		c.Config.Logger.Infof("Diff in Permission.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Permission), dcl.SprintResource(actual.Permission))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c *Client, desired, actual *InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdate or *InstanceReadonlyRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c *Client, desired, actual *InstanceReadonlyRecipeStepsKeyNotificationsUpdate) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, desired.KeyNotificationsInfo, actual.KeyNotificationsInfo) && !dcl.IsZeroValue(desired.KeyNotificationsInfo) {
		c.Config.Logger.Infof("Diff in KeyNotificationsInfo.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyNotificationsInfo), dcl.SprintResource(actual.KeyNotificationsInfo))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdate, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdate, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdate, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdate, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfigs, actual.KeyConfigs, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle}, fn.AddNest("KeyConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, desired, actual *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, desired.KeyConfigs, actual.KeyConfigs) && !dcl.IsZeroValue(desired.KeyConfigs) {
		c.Config.Logger.Infof("Diff in KeyConfigs.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfigs), dcl.SprintResource(actual.KeyConfigs))
		return true
	}
	if !reflect.DeepEqual(desired.DataVersion, actual.DataVersion) && !dcl.IsZeroValue(desired.DataVersion) {
		c.Config.Logger.Infof("Diff in DataVersion.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.DataVersion), dcl.SprintResource(actual.DataVersion))
		return true
	}
	if !dcl.StringCanonicalize(desired.Delegate, actual.Delegate) && !dcl.IsZeroValue(desired.Delegate) {
		c.Config.Logger.Infof("Diff in Delegate.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Delegate), dcl.SprintResource(actual.Delegate))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs or *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyConfig, actual.KeyConfig, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle}, fn.AddNest("KeyConfig")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, desired, actual *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, desired.KeyConfig, actual.KeyConfig) && !dcl.IsZeroValue(desired.KeyConfig) {
		c.Config.Logger.Infof("Diff in KeyConfig.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyConfig), dcl.SprintResource(actual.KeyConfig))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig or *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, desired, actual *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !dcl.StringCanonicalize(desired.KeyOrVersionName, actual.KeyOrVersionName) && !dcl.IsZeroValue(desired.KeyOrVersionName) {
		c.Config.Logger.Infof("Diff in KeyOrVersionName.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.KeyOrVersionName), dcl.SprintResource(actual.KeyOrVersionName))
		return true
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, desired, actual map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceHistoryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceHistory)
	if !ok {
		desiredNotPointer, ok := d.(InstanceHistory)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceHistory or *InstanceHistory", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceHistory)
	if !ok {
		actualNotPointer, ok := a.(InstanceHistory)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceHistory", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Timestamp, actual.Timestamp, dcl.Info{}, fn.AddNest("Timestamp")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.OperationHandle, actual.OperationHandle, dcl.Info{}, fn.AddNest("OperationHandle")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.StepIndex, actual.StepIndex, dcl.Info{}, fn.AddNest("StepIndex")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TenantProjectNumber, actual.TenantProjectNumber, dcl.Info{}, fn.AddNest("TenantProjectNumber")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TenantProjectId, actual.TenantProjectId, dcl.Info{}, fn.AddNest("TenantProjectId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceHistory(c *Client, desired, actual *InstanceHistory) bool {
	if desired == nil {
		return false
	}
	if actual == nil {
		return true
	}
	if !reflect.DeepEqual(desired.Timestamp, actual.Timestamp) && !dcl.IsZeroValue(desired.Timestamp) {
		c.Config.Logger.Infof("Diff in Timestamp.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Timestamp), dcl.SprintResource(actual.Timestamp))
		return true
	}
	if !dcl.StringCanonicalize(desired.OperationHandle, actual.OperationHandle) && !dcl.IsZeroValue(desired.OperationHandle) {
		c.Config.Logger.Infof("Diff in OperationHandle.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.OperationHandle), dcl.SprintResource(actual.OperationHandle))
		return true
	}
	if !dcl.StringCanonicalize(desired.Description, actual.Description) && !dcl.IsZeroValue(desired.Description) {
		c.Config.Logger.Infof("Diff in Description.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.Description), dcl.SprintResource(actual.Description))
		return true
	}
	if !reflect.DeepEqual(desired.StepIndex, actual.StepIndex) && !dcl.IsZeroValue(desired.StepIndex) {
		c.Config.Logger.Infof("Diff in StepIndex.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.StepIndex), dcl.SprintResource(actual.StepIndex))
		return true
	}
	if !reflect.DeepEqual(desired.TenantProjectNumber, actual.TenantProjectNumber) && !dcl.IsZeroValue(desired.TenantProjectNumber) {
		c.Config.Logger.Infof("Diff in TenantProjectNumber.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TenantProjectNumber), dcl.SprintResource(actual.TenantProjectNumber))
		return true
	}
	if !dcl.StringCanonicalize(desired.TenantProjectId, actual.TenantProjectId) && !dcl.IsZeroValue(desired.TenantProjectId) {
		c.Config.Logger.Infof("Diff in TenantProjectId.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.TenantProjectId), dcl.SprintResource(actual.TenantProjectId))
		return true
	}
	if !dcl.StringCanonicalize(desired.P4ServiceAccount, actual.P4ServiceAccount) && !dcl.IsZeroValue(desired.P4ServiceAccount) {
		c.Config.Logger.Infof("Diff in P4ServiceAccount.\nDESIRED: %s\nACTUAL: %s\n", dcl.SprintResource(desired.P4ServiceAccount), dcl.SprintResource(actual.P4ServiceAccount))
		return true
	}
	return false
}

func compareInstanceHistorySlice(c *Client, desired, actual []InstanceHistory) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceHistory, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceHistory(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceHistory, element %d.\nDESIRED: %s\nACTUAL: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceHistoryMap(c *Client, desired, actual map[string]InstanceHistory) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceHistory, lengths unequal.")
		return true
	}
	for k, desiredValue := range desired {
		actualValue, ok := actual[k]
		if !ok {
			c.Config.Logger.Infof("Diff in InstanceHistory, key %s not found in ACTUAL.\n", k)
			return true
		}
		if compareInstanceHistory(c, &desiredValue, &actualValue) {
			c.Config.Logger.Infof("Diff in InstanceHistory, key %s.\nDESIRED: %s\nACTUAL: %s\n", k, dcl.SprintResource(desiredValue), dcl.SprintResource(actualValue))
			return true
		}
	}
	return false
}

func compareInstanceSkuTierEnumSlice(c *Client, desired, actual []InstanceSkuTierEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceSkuTierEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceSkuTierEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceSkuTierEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceSkuTierEnum(c *Client, desired, actual *InstanceSkuTierEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceSkuSizeEnumSlice(c *Client, desired, actual []InstanceSkuSizeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceSkuSizeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceSkuSizeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceSkuSizeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceSkuSizeEnum(c *Client, desired, actual *InstanceSkuSizeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceStateEnumSlice(c *Client, desired, actual []InstanceStateEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceStateEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceStateEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceStateEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceStateEnum(c *Client, desired, actual *InstanceStateEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessCreateRecipeStepsActionEnumSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsActionEnum(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateCreateRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsActionEnum(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceCreateRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceCreateRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsActionEnum(c *Client, desired, actual *InstanceCreateRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceCreateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceDeleteRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsActionEnum(c *Client, desired, actual *InstanceDeleteRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceUpdateRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsActionEnum(c *Client, desired, actual *InstanceUpdateRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessResetRecipeStepsActionEnumSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsActionEnum(c *Client, desired, actual *InstancePreprocessResetRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateResetRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsActionEnum(c *Client, desired, actual *InstanceInitiateResetRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceResetRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceResetRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsActionEnum(c *Client, desired, actual *InstanceResetRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceResetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceResetRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceResetRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceResetRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceResetRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceResetRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceResetRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessRepairRecipeStepsActionEnumSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsActionEnum(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateRepairRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsActionEnum(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceRepairRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceRepairRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsActionEnum(c *Client, desired, actual *InstanceRepairRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceRepairRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessDeleteRecipeStepsActionEnumSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsActionEnum(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateDeleteRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsActionEnum(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessUpdateRecipeStepsActionEnumSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsActionEnum(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateUpdateRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsActionEnum(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessFreezeRecipeStepsActionEnumSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsActionEnum(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceFreezeRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsActionEnum(c *Client, desired, actual *InstanceFreezeRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessUnfreezeRecipeStepsActionEnumSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsActionEnum(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceUnfreezeRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsActionEnum(c *Client, desired, actual *InstanceUnfreezeRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceReadonlyRecipeStepsActionEnumSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsActionEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsActionEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsActionEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsActionEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsActionEnum(c *Client, desired, actual *InstanceReadonlyRecipeStepsActionEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

func compareInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, desired, actual []InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum) bool {
	if len(desired) != len(actual) {
		c.Config.Logger.Info("Diff in InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum, lengths unequal.")
		return true
	}
	for i := 0; i < len(desired); i++ {
		if compareInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum(c, &desired[i], &actual[i]) {
			c.Config.Logger.Infof("Diff in InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum, element %d.\nOLD: %s\nNEW: %s\n", i, dcl.SprintResource(desired[i]), dcl.SprintResource(actual[i]))
			return true
		}
	}
	return false
}

func compareInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum(c *Client, desired, actual *InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum) bool {
	return !reflect.DeepEqual(desired, actual)
}

// urlNormalized returns a copy of the resource struct with values normalized
// for URL substitutions. For instance, it converts long-form self-links to
// short-form so they can be substituted in.
func (r *Instance) urlNormalized() *Instance {
	normalized := dcl.Copy(*r).(Instance)
	normalized.Name = dcl.SelfLinkToName(r.Name)
	normalized.DisplayName = dcl.SelfLinkToName(r.DisplayName)
	normalized.Zone = dcl.SelfLinkToName(r.Zone)
	normalized.AuthorizedNetworkId = dcl.SelfLinkToName(r.AuthorizedNetworkId)
	normalized.ReservedIPRange = dcl.SelfLinkToName(r.ReservedIPRange)
	normalized.HostName = dcl.SelfLinkToName(r.HostName)
	normalized.CurrentZone = dcl.SelfLinkToName(r.CurrentZone)
	normalized.StatusMessage = dcl.SelfLinkToName(r.StatusMessage)
	normalized.ExtraField = dcl.SelfLinkToName(r.ExtraField)
	normalized.PublicResourceViewOverride = dcl.SelfLinkToName(r.PublicResourceViewOverride)
	normalized.Project = dcl.SelfLinkToName(r.Project)
	normalized.Location = dcl.SelfLinkToName(r.Location)
	return &normalized
}

func (r *Instance) getFields() (string, string, string) {
	n := r.urlNormalized()
	return dcl.ValueOrEmptyString(n.Project), dcl.ValueOrEmptyString(n.Location), dcl.ValueOrEmptyString(n.Name)
}

func (r *Instance) createFields() (string, string, string) {
	n := r.urlNormalized()
	return dcl.ValueOrEmptyString(n.Project), dcl.ValueOrEmptyString(n.Location), dcl.ValueOrEmptyString(n.Name)
}

func (r *Instance) deleteFields() (string, string, string) {
	n := r.urlNormalized()
	return dcl.ValueOrEmptyString(n.Project), dcl.ValueOrEmptyString(n.Location), dcl.ValueOrEmptyString(n.Name)
}

func (r *Instance) updateURL(userBasePath, updateName string) (string, error) {
	n := r.urlNormalized()
	if updateName == "UpdateInstance" {
		fields := map[string]interface{}{
			"project":  dcl.ValueOrEmptyString(n.Project),
			"location": dcl.ValueOrEmptyString(n.Location),
			"name":     dcl.ValueOrEmptyString(n.Name),
		}
		return dcl.URL("projects/{{project}}/locations/{{location}}/instances/{{name}}", "https://arcus2tier2.sandbox.googleapis.com/v1alpha2/", userBasePath, fields), nil

	}
	return "", fmt.Errorf("unknown update name: %s", updateName)
}

// marshal encodes the Instance resource into JSON for a Create request, and
// performs transformations from the resource schema to the API schema if
// necessary.
func (r *Instance) marshal(c *Client) ([]byte, error) {
	m, err := expandInstance(c, r)
	if err != nil {
		return nil, fmt.Errorf("error marshalling Instance: %w", err)
	}

	return json.Marshal(m)
}

// unmarshalInstance decodes JSON responses into the Instance resource schema.
func unmarshalInstance(b []byte, c *Client) (*Instance, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return unmarshalMapInstance(m, c)
}

func unmarshalMapInstance(m map[string]interface{}, c *Client) (*Instance, error) {

	return flattenInstance(c, m), nil
}

// expandInstance expands Instance into a JSON request object.
func expandInstance(c *Client, f *Instance) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if v := f.Name; !dcl.IsEmptyValueIndirect(v) {
		m["name"] = v
	}
	if v := f.DisplayName; !dcl.IsEmptyValueIndirect(v) {
		m["displayName"] = v
	}
	if v := f.Labels; !dcl.IsEmptyValueIndirect(v) {
		m["labels"] = v
	}
	if v := f.Zone; !dcl.IsEmptyValueIndirect(v) {
		m["zone"] = v
	}
	if v, err := expandInstanceSku(c, f.Sku); err != nil {
		return nil, fmt.Errorf("error expanding Sku into sku: %w", err)
	} else if v != nil {
		m["sku"] = v
	}
	if v := f.AuthorizedNetworkId; !dcl.IsEmptyValueIndirect(v) {
		m["authorizedNetworkId"] = v
	}
	if v := f.ReservedIPRange; !dcl.IsEmptyValueIndirect(v) {
		m["reservedIpRange"] = v
	}
	if v := f.HostName; !dcl.IsEmptyValueIndirect(v) {
		m["hostName"] = v
	}
	if v := f.PortNumber; !dcl.IsEmptyValueIndirect(v) {
		m["portNumber"] = v
	}
	if v := f.CurrentZone; !dcl.IsEmptyValueIndirect(v) {
		m["currentZone"] = v
	}
	if v := f.CreationTime; !dcl.IsEmptyValueIndirect(v) {
		m["creationTime"] = v
	}
	if v := f.State; !dcl.IsEmptyValueIndirect(v) {
		m["state"] = v
	}
	if v := f.StatusMessage; !dcl.IsEmptyValueIndirect(v) {
		m["statusMessage"] = v
	}
	if v := f.ExtraField; !dcl.IsEmptyValueIndirect(v) {
		m["extraField"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipe(c, f.PreprocessCreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessCreateRecipe into preprocessCreateRecipe: %w", err)
	} else if v != nil {
		m["preprocessCreateRecipe"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipe(c, f.InitiateCreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateCreateRecipe into initiateCreateRecipe: %w", err)
	} else if v != nil {
		m["initiateCreateRecipe"] = v
	}
	if v, err := expandInstanceCreateRecipe(c, f.CreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding CreateRecipe into createRecipe: %w", err)
	} else if v != nil {
		m["createRecipe"] = v
	}
	if v, err := expandInstanceDeleteRecipe(c, f.DeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding DeleteRecipe into deleteRecipe: %w", err)
	} else if v != nil {
		m["deleteRecipe"] = v
	}
	if v, err := expandInstanceUpdateRecipe(c, f.UpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding UpdateRecipe into updateRecipe: %w", err)
	} else if v != nil {
		m["updateRecipe"] = v
	}
	if v, err := expandInstancePreprocessResetRecipe(c, f.PreprocessResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessResetRecipe into preprocessResetRecipe: %w", err)
	} else if v != nil {
		m["preprocessResetRecipe"] = v
	}
	if v, err := expandInstanceInitiateResetRecipe(c, f.InitiateResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateResetRecipe into initiateResetRecipe: %w", err)
	} else if v != nil {
		m["initiateResetRecipe"] = v
	}
	if v, err := expandInstanceResetRecipe(c, f.ResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ResetRecipe into resetRecipe: %w", err)
	} else if v != nil {
		m["resetRecipe"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipe(c, f.PreprocessRepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessRepairRecipe into preprocessRepairRecipe: %w", err)
	} else if v != nil {
		m["preprocessRepairRecipe"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipe(c, f.InitiateRepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateRepairRecipe into initiateRepairRecipe: %w", err)
	} else if v != nil {
		m["initiateRepairRecipe"] = v
	}
	if v, err := expandInstanceRepairRecipe(c, f.RepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding RepairRecipe into repairRecipe: %w", err)
	} else if v != nil {
		m["repairRecipe"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipe(c, f.PreprocessDeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessDeleteRecipe into preprocessDeleteRecipe: %w", err)
	} else if v != nil {
		m["preprocessDeleteRecipe"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipe(c, f.InitiateDeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateDeleteRecipe into initiateDeleteRecipe: %w", err)
	} else if v != nil {
		m["initiateDeleteRecipe"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipe(c, f.PreprocessUpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdateRecipe into preprocessUpdateRecipe: %w", err)
	} else if v != nil {
		m["preprocessUpdateRecipe"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipe(c, f.InitiateUpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding InitiateUpdateRecipe into initiateUpdateRecipe: %w", err)
	} else if v != nil {
		m["initiateUpdateRecipe"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipe(c, f.PreprocessFreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessFreezeRecipe into preprocessFreezeRecipe: %w", err)
	} else if v != nil {
		m["preprocessFreezeRecipe"] = v
	}
	if v, err := expandInstanceFreezeRecipe(c, f.FreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding FreezeRecipe into freezeRecipe: %w", err)
	} else if v != nil {
		m["freezeRecipe"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipe(c, f.PreprocessUnfreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUnfreezeRecipe into preprocessUnfreezeRecipe: %w", err)
	} else if v != nil {
		m["preprocessUnfreezeRecipe"] = v
	}
	if v, err := expandInstanceUnfreezeRecipe(c, f.UnfreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding UnfreezeRecipe into unfreezeRecipe: %w", err)
	} else if v != nil {
		m["unfreezeRecipe"] = v
	}
	if v, err := expandInstanceReadonlyRecipe(c, f.ReadonlyRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ReadonlyRecipe into readonlyRecipe: %w", err)
	} else if v != nil {
		m["readonlyRecipe"] = v
	}
	if v := f.EnableCallHistory; !dcl.IsEmptyValueIndirect(v) {
		m["enableCallHistory"] = v
	}
	if v, err := expandInstanceHistorySlice(c, f.History); err != nil {
		return nil, fmt.Errorf("error expanding History into history: %w", err)
	} else if v != nil {
		m["history"] = v
	}
	if v := f.PublicResourceViewOverride; !dcl.IsEmptyValueIndirect(v) {
		m["publicResourceViewOverride"] = v
	}
	if v, err := dcl.EmptyValue(); err != nil {
		return nil, fmt.Errorf("error expanding Project into project: %w", err)
	} else if v != nil {
		m["project"] = v
	}
	if v, err := dcl.EmptyValue(); err != nil {
		return nil, fmt.Errorf("error expanding Location into location: %w", err)
	} else if v != nil {
		m["location"] = v
	}

	return m, nil
}

// flattenInstance flattens Instance from a JSON request object into the
// Instance type.
func flattenInstance(c *Client, i interface{}) *Instance {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}
	if len(m) == 0 {
		return nil
	}

	r := &Instance{}
	r.Name = dcl.FlattenString(m["name"])
	r.DisplayName = dcl.FlattenString(m["displayName"])
	r.Labels = dcl.FlattenKeyValuePairs(m["labels"])
	r.Zone = dcl.FlattenString(m["zone"])
	r.Sku = flattenInstanceSku(c, m["sku"])
	r.AuthorizedNetworkId = dcl.FlattenString(m["authorizedNetworkId"])
	r.ReservedIPRange = dcl.FlattenString(m["reservedIpRange"])
	r.HostName = dcl.FlattenString(m["hostName"])
	r.PortNumber = dcl.FlattenInteger(m["portNumber"])
	r.CurrentZone = dcl.FlattenString(m["currentZone"])
	r.CreationTime = dcl.FlattenString(m["creationTime"])
	r.State = flattenInstanceStateEnum(m["state"])
	r.StatusMessage = dcl.FlattenString(m["statusMessage"])
	r.ExtraField = dcl.FlattenString(m["extraField"])
	r.PreprocessCreateRecipe = flattenInstancePreprocessCreateRecipe(c, m["preprocessCreateRecipe"])
	r.InitiateCreateRecipe = flattenInstanceInitiateCreateRecipe(c, m["initiateCreateRecipe"])
	r.CreateRecipe = flattenInstanceCreateRecipe(c, m["createRecipe"])
	r.DeleteRecipe = flattenInstanceDeleteRecipe(c, m["deleteRecipe"])
	r.UpdateRecipe = flattenInstanceUpdateRecipe(c, m["updateRecipe"])
	r.PreprocessResetRecipe = flattenInstancePreprocessResetRecipe(c, m["preprocessResetRecipe"])
	r.InitiateResetRecipe = flattenInstanceInitiateResetRecipe(c, m["initiateResetRecipe"])
	r.ResetRecipe = flattenInstanceResetRecipe(c, m["resetRecipe"])
	r.PreprocessRepairRecipe = flattenInstancePreprocessRepairRecipe(c, m["preprocessRepairRecipe"])
	r.InitiateRepairRecipe = flattenInstanceInitiateRepairRecipe(c, m["initiateRepairRecipe"])
	r.RepairRecipe = flattenInstanceRepairRecipe(c, m["repairRecipe"])
	r.PreprocessDeleteRecipe = flattenInstancePreprocessDeleteRecipe(c, m["preprocessDeleteRecipe"])
	r.InitiateDeleteRecipe = flattenInstanceInitiateDeleteRecipe(c, m["initiateDeleteRecipe"])
	r.PreprocessUpdateRecipe = flattenInstancePreprocessUpdateRecipe(c, m["preprocessUpdateRecipe"])
	r.InitiateUpdateRecipe = flattenInstanceInitiateUpdateRecipe(c, m["initiateUpdateRecipe"])
	r.PreprocessFreezeRecipe = flattenInstancePreprocessFreezeRecipe(c, m["preprocessFreezeRecipe"])
	r.FreezeRecipe = flattenInstanceFreezeRecipe(c, m["freezeRecipe"])
	r.PreprocessUnfreezeRecipe = flattenInstancePreprocessUnfreezeRecipe(c, m["preprocessUnfreezeRecipe"])
	r.UnfreezeRecipe = flattenInstanceUnfreezeRecipe(c, m["unfreezeRecipe"])
	r.ReadonlyRecipe = flattenInstanceReadonlyRecipe(c, m["readonlyRecipe"])
	r.EnableCallHistory = dcl.FlattenBool(m["enableCallHistory"])
	r.History = flattenInstanceHistorySlice(c, m["history"])
	r.PublicResourceViewOverride = dcl.FlattenString(m["publicResourceViewOverride"])
	r.Project = dcl.FlattenString(m["project"])
	r.Location = dcl.FlattenString(m["location"])

	return r
}

// expandInstanceSkuMap expands the contents of InstanceSku into a JSON
// request object.
func expandInstanceSkuMap(c *Client, f map[string]InstanceSku) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceSku(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceSkuSlice expands the contents of InstanceSku into a JSON
// request object.
func expandInstanceSkuSlice(c *Client, f []InstanceSku) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceSku(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceSkuMap flattens the contents of InstanceSku from a JSON
// response object.
func flattenInstanceSkuMap(c *Client, i interface{}) map[string]InstanceSku {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceSku{}
	}

	if len(a) == 0 {
		return map[string]InstanceSku{}
	}

	items := make(map[string]InstanceSku)
	for k, item := range a {
		items[k] = *flattenInstanceSku(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceSkuSlice flattens the contents of InstanceSku from a JSON
// response object.
func flattenInstanceSkuSlice(c *Client, i interface{}) []InstanceSku {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceSku{}
	}

	if len(a) == 0 {
		return []InstanceSku{}
	}

	items := make([]InstanceSku, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceSku(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceSku expands an instance of InstanceSku into a JSON
// request object.
func expandInstanceSku(c *Client, f *InstanceSku) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tier; !dcl.IsEmptyValueIndirect(v) {
		m["tier"] = v
	}
	if v := f.Size; !dcl.IsEmptyValueIndirect(v) {
		m["size"] = v
	}

	return m, nil
}

// flattenInstanceSku flattens an instance of InstanceSku from a JSON
// response object.
func flattenInstanceSku(c *Client, i interface{}) *InstanceSku {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceSku{}
	r.Tier = flattenInstanceSkuTierEnum(m["tier"])
	r.Size = flattenInstanceSkuSizeEnum(m["size"])

	return r
}

// expandInstancePreprocessCreateRecipeMap expands the contents of InstancePreprocessCreateRecipe into a JSON
// request object.
func expandInstancePreprocessCreateRecipeMap(c *Client, f map[string]InstancePreprocessCreateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeSlice expands the contents of InstancePreprocessCreateRecipe into a JSON
// request object.
func expandInstancePreprocessCreateRecipeSlice(c *Client, f []InstancePreprocessCreateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeMap flattens the contents of InstancePreprocessCreateRecipe from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipe{}
	}

	items := make(map[string]InstancePreprocessCreateRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeSlice flattens the contents of InstancePreprocessCreateRecipe from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipe{}
	}

	items := make([]InstancePreprocessCreateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipe expands an instance of InstancePreprocessCreateRecipe into a JSON
// request object.
func expandInstancePreprocessCreateRecipe(c *Client, f *InstancePreprocessCreateRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipe flattens an instance of InstancePreprocessCreateRecipe from a JSON
// response object.
func flattenInstancePreprocessCreateRecipe(c *Client, i interface{}) *InstancePreprocessCreateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipe{}
	r.Steps = flattenInstancePreprocessCreateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsMap expands the contents of InstancePreprocessCreateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsMap(c *Client, f map[string]InstancePreprocessCreateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsSlice expands the contents of InstancePreprocessCreateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsSlice(c *Client, f []InstancePreprocessCreateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsMap flattens the contents of InstancePreprocessCreateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsSlice flattens the contents of InstancePreprocessCreateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeSteps{}
	}

	items := make([]InstancePreprocessCreateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeSteps expands an instance of InstancePreprocessCreateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessCreateRecipeSteps(c *Client, f *InstancePreprocessCreateRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeSteps flattens an instance of InstancePreprocessCreateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeSteps(c *Client, i interface{}) *InstancePreprocessCreateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessCreateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessCreateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsStatusMap expands the contents of InstancePreprocessCreateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsStatusSlice expands the contents of InstancePreprocessCreateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusSlice(c *Client, f []InstancePreprocessCreateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsStatusMap flattens the contents of InstancePreprocessCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsStatusSlice flattens the contents of InstancePreprocessCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsStatus expands an instance of InstancePreprocessCreateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatus(c *Client, f *InstancePreprocessCreateRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsStatus flattens an instance of InstancePreprocessCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessCreateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsStatusDetails expands an instance of InstancePreprocessCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusDetails(c *Client, f *InstancePreprocessCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsStatusDetails flattens an instance of InstancePreprocessCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessCreateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfo expands an instance of InstancePreprocessCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs expands an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceInitiateCreateRecipeMap expands the contents of InstanceInitiateCreateRecipe into a JSON
// request object.
func expandInstanceInitiateCreateRecipeMap(c *Client, f map[string]InstanceInitiateCreateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeSlice expands the contents of InstanceInitiateCreateRecipe into a JSON
// request object.
func expandInstanceInitiateCreateRecipeSlice(c *Client, f []InstanceInitiateCreateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeMap flattens the contents of InstanceInitiateCreateRecipe from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipe{}
	}

	items := make(map[string]InstanceInitiateCreateRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeSlice flattens the contents of InstanceInitiateCreateRecipe from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipe{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipe{}
	}

	items := make([]InstanceInitiateCreateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipe expands an instance of InstanceInitiateCreateRecipe into a JSON
// request object.
func expandInstanceInitiateCreateRecipe(c *Client, f *InstanceInitiateCreateRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipe flattens an instance of InstanceInitiateCreateRecipe from a JSON
// response object.
func flattenInstanceInitiateCreateRecipe(c *Client, i interface{}) *InstanceInitiateCreateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipe{}
	r.Steps = flattenInstanceInitiateCreateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsMap expands the contents of InstanceInitiateCreateRecipeSteps into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsMap(c *Client, f map[string]InstanceInitiateCreateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsSlice expands the contents of InstanceInitiateCreateRecipeSteps into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsSlice(c *Client, f []InstanceInitiateCreateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsMap flattens the contents of InstanceInitiateCreateRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeSteps{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsSlice flattens the contents of InstanceInitiateCreateRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeSteps{}
	}

	items := make([]InstanceInitiateCreateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeSteps expands an instance of InstanceInitiateCreateRecipeSteps into a JSON
// request object.
func expandInstanceInitiateCreateRecipeSteps(c *Client, f *InstanceInitiateCreateRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeSteps flattens an instance of InstanceInitiateCreateRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeSteps(c *Client, i interface{}) *InstanceInitiateCreateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceInitiateCreateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceInitiateCreateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceInitiateCreateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsStatusMap expands the contents of InstanceInitiateCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsStatusMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsStatusSlice expands the contents of InstanceInitiateCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsStatusSlice(c *Client, f []InstanceInitiateCreateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsStatusMap flattens the contents of InstanceInitiateCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsStatus{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsStatusSlice flattens the contents of InstanceInitiateCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsStatus{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsStatus expands an instance of InstanceInitiateCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsStatus(c *Client, f *InstanceInitiateCreateRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsStatus flattens an instance of InstanceInitiateCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsStatus(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceInitiateCreateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsStatusDetailsMap expands the contents of InstanceInitiateCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsStatusDetailsSlice expands the contents of InstanceInitiateCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsStatusDetailsSlice(c *Client, f []InstanceInitiateCreateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsStatusDetailsMap flattens the contents of InstanceInitiateCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsStatusDetailsSlice flattens the contents of InstanceInitiateCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsStatusDetails{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsStatusDetails expands an instance of InstanceInitiateCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsStatusDetails(c *Client, f *InstanceInitiateCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsStatusDetails flattens an instance of InstanceInitiateCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceInitiateCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceInitiateCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceInitiateCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceInitiateCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltas expands an instance of InstanceInitiateCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltas flattens an instance of InstanceInitiateCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsPreprocessUpdateMap expands the contents of InstanceInitiateCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsPreprocessUpdateSlice expands the contents of InstanceInitiateCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceInitiateCreateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsPreprocessUpdateMap flattens the contents of InstanceInitiateCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceInitiateCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsPreprocessUpdate expands an instance of InstanceInitiateCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPreprocessUpdate(c *Client, f *InstanceInitiateCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsPreprocessUpdate flattens an instance of InstanceInitiateCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsRequestedTenantProjectMap expands the contents of InstanceInitiateCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceInitiateCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceInitiateCreateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceInitiateCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceInitiateCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsRequestedTenantProject expands an instance of InstanceInitiateCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsRequestedTenantProject(c *Client, f *InstanceInitiateCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsRequestedTenantProject flattens an instance of InstanceInitiateCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoMap expands the contents of InstanceInitiateCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoSlice expands the contents of InstanceInitiateCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceInitiateCreateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoMap flattens the contents of InstanceInitiateCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoSlice flattens the contents of InstanceInitiateCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfo expands an instance of InstanceInitiateCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfo(c *Client, f *InstanceInitiateCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfo flattens an instance of InstanceInitiateCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate expands an instance of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceCreateRecipeMap expands the contents of InstanceCreateRecipe into a JSON
// request object.
func expandInstanceCreateRecipeMap(c *Client, f map[string]InstanceCreateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeSlice expands the contents of InstanceCreateRecipe into a JSON
// request object.
func expandInstanceCreateRecipeSlice(c *Client, f []InstanceCreateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeMap flattens the contents of InstanceCreateRecipe from a JSON
// response object.
func flattenInstanceCreateRecipeMap(c *Client, i interface{}) map[string]InstanceCreateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipe{}
	}

	items := make(map[string]InstanceCreateRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeSlice flattens the contents of InstanceCreateRecipe from a JSON
// response object.
func flattenInstanceCreateRecipeSlice(c *Client, i interface{}) []InstanceCreateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipe{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipe{}
	}

	items := make([]InstanceCreateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipe expands an instance of InstanceCreateRecipe into a JSON
// request object.
func expandInstanceCreateRecipe(c *Client, f *InstanceCreateRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceCreateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipe flattens an instance of InstanceCreateRecipe from a JSON
// response object.
func flattenInstanceCreateRecipe(c *Client, i interface{}) *InstanceCreateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipe{}
	r.Steps = flattenInstanceCreateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceCreateRecipeStepsMap expands the contents of InstanceCreateRecipeSteps into a JSON
// request object.
func expandInstanceCreateRecipeStepsMap(c *Client, f map[string]InstanceCreateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsSlice expands the contents of InstanceCreateRecipeSteps into a JSON
// request object.
func expandInstanceCreateRecipeStepsSlice(c *Client, f []InstanceCreateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsMap flattens the contents of InstanceCreateRecipeSteps from a JSON
// response object.
func flattenInstanceCreateRecipeStepsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeSteps{}
	}

	items := make(map[string]InstanceCreateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsSlice flattens the contents of InstanceCreateRecipeSteps from a JSON
// response object.
func flattenInstanceCreateRecipeStepsSlice(c *Client, i interface{}) []InstanceCreateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeSteps{}
	}

	items := make([]InstanceCreateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeSteps expands an instance of InstanceCreateRecipeSteps into a JSON
// request object.
func expandInstanceCreateRecipeSteps(c *Client, f *InstanceCreateRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeSteps flattens an instance of InstanceCreateRecipeSteps from a JSON
// response object.
func flattenInstanceCreateRecipeSteps(c *Client, i interface{}) *InstanceCreateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceCreateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceCreateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceCreateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceCreateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceCreateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceCreateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceCreateRecipeStepsStatusMap expands the contents of InstanceCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusMap(c *Client, f map[string]InstanceCreateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsStatusSlice expands the contents of InstanceCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusSlice(c *Client, f []InstanceCreateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsStatusMap flattens the contents of InstanceCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsStatus{}
	}

	items := make(map[string]InstanceCreateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsStatusSlice flattens the contents of InstanceCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsStatus{}
	}

	items := make([]InstanceCreateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsStatus expands an instance of InstanceCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatus(c *Client, f *InstanceCreateRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsStatus flattens an instance of InstanceCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatus(c *Client, i interface{}) *InstanceCreateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceCreateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceCreateRecipeStepsStatusDetailsMap expands the contents of InstanceCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsStatusDetailsSlice expands the contents of InstanceCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusDetailsSlice(c *Client, f []InstanceCreateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsStatusDetailsMap flattens the contents of InstanceCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceCreateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsStatusDetailsSlice flattens the contents of InstanceCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsStatusDetails{}
	}

	items := make([]InstanceCreateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsStatusDetails expands an instance of InstanceCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusDetails(c *Client, f *InstanceCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsStatusDetails flattens an instance of InstanceCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceCreateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceCreateRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceCreateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceCreateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceCreateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceCreateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceCreateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsQuotaRequestDeltas expands an instance of InstanceCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceCreateRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsQuotaRequestDeltas flattens an instance of InstanceCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceCreateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceCreateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceCreateRecipeStepsPreprocessUpdateMap expands the contents of InstanceCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPreprocessUpdateSlice expands the contents of InstanceCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceCreateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPreprocessUpdateMap flattens the contents of InstanceCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceCreateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPreprocessUpdate expands an instance of InstanceCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsPreprocessUpdate(c *Client, f *InstanceCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPreprocessUpdate flattens an instance of InstanceCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceCreateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceCreateRecipeStepsRequestedTenantProjectMap expands the contents of InstanceCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceCreateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceCreateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceCreateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceCreateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceCreateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceCreateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceCreateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsRequestedTenantProject expands an instance of InstanceCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceCreateRecipeStepsRequestedTenantProject(c *Client, f *InstanceCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsRequestedTenantProject flattens an instance of InstanceCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceCreateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceCreateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceCreateRecipeStepsPermissionsInfoMap expands the contents of InstanceCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPermissionsInfoSlice expands the contents of InstanceCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceCreateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoMap flattens the contents of InstanceCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPermissionsInfoSlice flattens the contents of InstanceCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceCreateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPermissionsInfo expands an instance of InstanceCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfo(c *Client, f *InstanceCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfo flattens an instance of InstanceCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceCreateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceCreateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceCreateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceCreateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceCreateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceCreateRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceCreateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceCreateRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceCreateRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceCreateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceCreateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceCreateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceCreateRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceCreateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceCreateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdate expands an instance of InstanceCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceCreateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceDeleteRecipeMap expands the contents of InstanceDeleteRecipe into a JSON
// request object.
func expandInstanceDeleteRecipeMap(c *Client, f map[string]InstanceDeleteRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeSlice expands the contents of InstanceDeleteRecipe into a JSON
// request object.
func expandInstanceDeleteRecipeSlice(c *Client, f []InstanceDeleteRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeMap flattens the contents of InstanceDeleteRecipe from a JSON
// response object.
func flattenInstanceDeleteRecipeMap(c *Client, i interface{}) map[string]InstanceDeleteRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipe{}
	}

	items := make(map[string]InstanceDeleteRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeSlice flattens the contents of InstanceDeleteRecipe from a JSON
// response object.
func flattenInstanceDeleteRecipeSlice(c *Client, i interface{}) []InstanceDeleteRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipe{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipe{}
	}

	items := make([]InstanceDeleteRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipe expands an instance of InstanceDeleteRecipe into a JSON
// request object.
func expandInstanceDeleteRecipe(c *Client, f *InstanceDeleteRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceDeleteRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipe flattens an instance of InstanceDeleteRecipe from a JSON
// response object.
func flattenInstanceDeleteRecipe(c *Client, i interface{}) *InstanceDeleteRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipe{}
	r.Steps = flattenInstanceDeleteRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceDeleteRecipeStepsMap expands the contents of InstanceDeleteRecipeSteps into a JSON
// request object.
func expandInstanceDeleteRecipeStepsMap(c *Client, f map[string]InstanceDeleteRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsSlice expands the contents of InstanceDeleteRecipeSteps into a JSON
// request object.
func expandInstanceDeleteRecipeStepsSlice(c *Client, f []InstanceDeleteRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsMap flattens the contents of InstanceDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeSteps{}
	}

	items := make(map[string]InstanceDeleteRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsSlice flattens the contents of InstanceDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsSlice(c *Client, i interface{}) []InstanceDeleteRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeSteps{}
	}

	items := make([]InstanceDeleteRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeSteps expands an instance of InstanceDeleteRecipeSteps into a JSON
// request object.
func expandInstanceDeleteRecipeSteps(c *Client, f *InstanceDeleteRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeSteps flattens an instance of InstanceDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceDeleteRecipeSteps(c *Client, i interface{}) *InstanceDeleteRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceDeleteRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceDeleteRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceDeleteRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceDeleteRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceDeleteRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceDeleteRecipeStepsStatusMap expands the contents of InstanceDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusMap(c *Client, f map[string]InstanceDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsStatusSlice expands the contents of InstanceDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusSlice(c *Client, f []InstanceDeleteRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsStatusMap flattens the contents of InstanceDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsStatus{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsStatusSlice flattens the contents of InstanceDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsStatus{}
	}

	items := make([]InstanceDeleteRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsStatus expands an instance of InstanceDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatus(c *Client, f *InstanceDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsStatus flattens an instance of InstanceDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatus(c *Client, i interface{}) *InstanceDeleteRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceDeleteRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceDeleteRecipeStepsStatusDetailsMap expands the contents of InstanceDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsStatusDetailsSlice expands the contents of InstanceDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusDetailsSlice(c *Client, f []InstanceDeleteRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsStatusDetailsMap flattens the contents of InstanceDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsStatusDetailsSlice flattens the contents of InstanceDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsStatusDetails{}
	}

	items := make([]InstanceDeleteRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsStatusDetails expands an instance of InstanceDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusDetails(c *Client, f *InstanceDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsStatusDetails flattens an instance of InstanceDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceDeleteRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceDeleteRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceDeleteRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceDeleteRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsQuotaRequestDeltas expands an instance of InstanceDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceDeleteRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsQuotaRequestDeltas flattens an instance of InstanceDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceDeleteRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceDeleteRecipeStepsPreprocessUpdateMap expands the contents of InstanceDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPreprocessUpdateSlice expands the contents of InstanceDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceDeleteRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPreprocessUpdateMap flattens the contents of InstanceDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceDeleteRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPreprocessUpdate expands an instance of InstanceDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPreprocessUpdate(c *Client, f *InstanceDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPreprocessUpdate flattens an instance of InstanceDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceDeleteRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceDeleteRecipeStepsRequestedTenantProjectMap expands the contents of InstanceDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceDeleteRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceDeleteRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceDeleteRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsRequestedTenantProject expands an instance of InstanceDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceDeleteRecipeStepsRequestedTenantProject(c *Client, f *InstanceDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProject flattens an instance of InstanceDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceDeleteRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceDeleteRecipeStepsPermissionsInfoMap expands the contents of InstanceDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPermissionsInfoSlice expands the contents of InstanceDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceDeleteRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoMap flattens the contents of InstanceDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoSlice flattens the contents of InstanceDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceDeleteRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPermissionsInfo expands an instance of InstanceDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfo(c *Client, f *InstanceDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfo flattens an instance of InstanceDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceDeleteRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceDeleteRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceDeleteRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceDeleteRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceDeleteRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceDeleteRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceDeleteRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceDeleteRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdate expands an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceUpdateRecipeMap expands the contents of InstanceUpdateRecipe into a JSON
// request object.
func expandInstanceUpdateRecipeMap(c *Client, f map[string]InstanceUpdateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeSlice expands the contents of InstanceUpdateRecipe into a JSON
// request object.
func expandInstanceUpdateRecipeSlice(c *Client, f []InstanceUpdateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeMap flattens the contents of InstanceUpdateRecipe from a JSON
// response object.
func flattenInstanceUpdateRecipeMap(c *Client, i interface{}) map[string]InstanceUpdateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipe{}
	}

	items := make(map[string]InstanceUpdateRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeSlice flattens the contents of InstanceUpdateRecipe from a JSON
// response object.
func flattenInstanceUpdateRecipeSlice(c *Client, i interface{}) []InstanceUpdateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipe{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipe{}
	}

	items := make([]InstanceUpdateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipe expands an instance of InstanceUpdateRecipe into a JSON
// request object.
func expandInstanceUpdateRecipe(c *Client, f *InstanceUpdateRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUpdateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipe flattens an instance of InstanceUpdateRecipe from a JSON
// response object.
func flattenInstanceUpdateRecipe(c *Client, i interface{}) *InstanceUpdateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipe{}
	r.Steps = flattenInstanceUpdateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceUpdateRecipeStepsMap expands the contents of InstanceUpdateRecipeSteps into a JSON
// request object.
func expandInstanceUpdateRecipeStepsMap(c *Client, f map[string]InstanceUpdateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsSlice expands the contents of InstanceUpdateRecipeSteps into a JSON
// request object.
func expandInstanceUpdateRecipeStepsSlice(c *Client, f []InstanceUpdateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsMap flattens the contents of InstanceUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeSteps{}
	}

	items := make(map[string]InstanceUpdateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsSlice flattens the contents of InstanceUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsSlice(c *Client, i interface{}) []InstanceUpdateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeSteps{}
	}

	items := make([]InstanceUpdateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeSteps expands an instance of InstanceUpdateRecipeSteps into a JSON
// request object.
func expandInstanceUpdateRecipeSteps(c *Client, f *InstanceUpdateRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeSteps flattens an instance of InstanceUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceUpdateRecipeSteps(c *Client, i interface{}) *InstanceUpdateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceUpdateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceUpdateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceUpdateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceUpdateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceUpdateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceUpdateRecipeStepsStatusMap expands the contents of InstanceUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusMap(c *Client, f map[string]InstanceUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsStatusSlice expands the contents of InstanceUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusSlice(c *Client, f []InstanceUpdateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsStatusMap flattens the contents of InstanceUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsStatus{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsStatusSlice flattens the contents of InstanceUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsStatus{}
	}

	items := make([]InstanceUpdateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsStatus expands an instance of InstanceUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatus(c *Client, f *InstanceUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsStatus flattens an instance of InstanceUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatus(c *Client, i interface{}) *InstanceUpdateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceUpdateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceUpdateRecipeStepsStatusDetailsMap expands the contents of InstanceUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsStatusDetailsSlice expands the contents of InstanceUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusDetailsSlice(c *Client, f []InstanceUpdateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsStatusDetailsMap flattens the contents of InstanceUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsStatusDetailsSlice flattens the contents of InstanceUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsStatusDetails{}
	}

	items := make([]InstanceUpdateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsStatusDetails expands an instance of InstanceUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusDetails(c *Client, f *InstanceUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsStatusDetails flattens an instance of InstanceUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceUpdateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceUpdateRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceUpdateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceUpdateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsQuotaRequestDeltas expands an instance of InstanceUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUpdateRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsQuotaRequestDeltas flattens an instance of InstanceUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceUpdateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceUpdateRecipeStepsPreprocessUpdateMap expands the contents of InstanceUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPreprocessUpdateSlice expands the contents of InstanceUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceUpdateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPreprocessUpdateMap flattens the contents of InstanceUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceUpdateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPreprocessUpdate expands an instance of InstanceUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPreprocessUpdate(c *Client, f *InstanceUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPreprocessUpdate flattens an instance of InstanceUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceUpdateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceUpdateRecipeStepsRequestedTenantProjectMap expands the contents of InstanceUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUpdateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceUpdateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceUpdateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsRequestedTenantProject expands an instance of InstanceUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUpdateRecipeStepsRequestedTenantProject(c *Client, f *InstanceUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProject flattens an instance of InstanceUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceUpdateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceUpdateRecipeStepsPermissionsInfoMap expands the contents of InstanceUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPermissionsInfoSlice expands the contents of InstanceUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceUpdateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoMap flattens the contents of InstanceUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoSlice flattens the contents of InstanceUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceUpdateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPermissionsInfo expands an instance of InstanceUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfo(c *Client, f *InstanceUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfo flattens an instance of InstanceUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceUpdateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceUpdateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceUpdateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceUpdateRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceUpdateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceUpdateRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceUpdateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceUpdateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdate expands an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstancePreprocessResetRecipeMap expands the contents of InstancePreprocessResetRecipe into a JSON
// request object.
func expandInstancePreprocessResetRecipeMap(c *Client, f map[string]InstancePreprocessResetRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeSlice expands the contents of InstancePreprocessResetRecipe into a JSON
// request object.
func expandInstancePreprocessResetRecipeSlice(c *Client, f []InstancePreprocessResetRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeMap flattens the contents of InstancePreprocessResetRecipe from a JSON
// response object.
func flattenInstancePreprocessResetRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipe{}
	}

	items := make(map[string]InstancePreprocessResetRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeSlice flattens the contents of InstancePreprocessResetRecipe from a JSON
// response object.
func flattenInstancePreprocessResetRecipeSlice(c *Client, i interface{}) []InstancePreprocessResetRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipe{}
	}

	items := make([]InstancePreprocessResetRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipe expands an instance of InstancePreprocessResetRecipe into a JSON
// request object.
func expandInstancePreprocessResetRecipe(c *Client, f *InstancePreprocessResetRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessResetRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipe flattens an instance of InstancePreprocessResetRecipe from a JSON
// response object.
func flattenInstancePreprocessResetRecipe(c *Client, i interface{}) *InstancePreprocessResetRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipe{}
	r.Steps = flattenInstancePreprocessResetRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessResetRecipeStepsMap expands the contents of InstancePreprocessResetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsMap(c *Client, f map[string]InstancePreprocessResetRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsSlice expands the contents of InstancePreprocessResetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsSlice(c *Client, f []InstancePreprocessResetRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsMap flattens the contents of InstancePreprocessResetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessResetRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsSlice flattens the contents of InstancePreprocessResetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeSteps{}
	}

	items := make([]InstancePreprocessResetRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeSteps expands an instance of InstancePreprocessResetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessResetRecipeSteps(c *Client, f *InstancePreprocessResetRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeSteps flattens an instance of InstancePreprocessResetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessResetRecipeSteps(c *Client, i interface{}) *InstancePreprocessResetRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessResetRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessResetRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessResetRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessResetRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstancePreprocessResetRecipeStepsStatusMap expands the contents of InstancePreprocessResetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsStatusSlice expands the contents of InstancePreprocessResetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusSlice(c *Client, f []InstancePreprocessResetRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsStatusMap flattens the contents of InstancePreprocessResetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsStatusSlice flattens the contents of InstancePreprocessResetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessResetRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsStatus expands an instance of InstancePreprocessResetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatus(c *Client, f *InstancePreprocessResetRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsStatus flattens an instance of InstancePreprocessResetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessResetRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessResetRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessResetRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessResetRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsStatusDetails expands an instance of InstancePreprocessResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusDetails(c *Client, f *InstancePreprocessResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsStatusDetails flattens an instance of InstancePreprocessResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessResetRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessResetRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessResetRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessResetRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessResetRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessResetRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessResetRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfo expands an instance of InstancePreprocessResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs expands an instance of InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceInitiateResetRecipeMap expands the contents of InstanceInitiateResetRecipe into a JSON
// request object.
func expandInstanceInitiateResetRecipeMap(c *Client, f map[string]InstanceInitiateResetRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeSlice expands the contents of InstanceInitiateResetRecipe into a JSON
// request object.
func expandInstanceInitiateResetRecipeSlice(c *Client, f []InstanceInitiateResetRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeMap flattens the contents of InstanceInitiateResetRecipe from a JSON
// response object.
func flattenInstanceInitiateResetRecipeMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipe{}
	}

	items := make(map[string]InstanceInitiateResetRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeSlice flattens the contents of InstanceInitiateResetRecipe from a JSON
// response object.
func flattenInstanceInitiateResetRecipeSlice(c *Client, i interface{}) []InstanceInitiateResetRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipe{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipe{}
	}

	items := make([]InstanceInitiateResetRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipe expands an instance of InstanceInitiateResetRecipe into a JSON
// request object.
func expandInstanceInitiateResetRecipe(c *Client, f *InstanceInitiateResetRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateResetRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipe flattens an instance of InstanceInitiateResetRecipe from a JSON
// response object.
func flattenInstanceInitiateResetRecipe(c *Client, i interface{}) *InstanceInitiateResetRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipe{}
	r.Steps = flattenInstanceInitiateResetRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceInitiateResetRecipeStepsMap expands the contents of InstanceInitiateResetRecipeSteps into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsMap(c *Client, f map[string]InstanceInitiateResetRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsSlice expands the contents of InstanceInitiateResetRecipeSteps into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsSlice(c *Client, f []InstanceInitiateResetRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsMap flattens the contents of InstanceInitiateResetRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeSteps{}
	}

	items := make(map[string]InstanceInitiateResetRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsSlice flattens the contents of InstanceInitiateResetRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeSteps{}
	}

	items := make([]InstanceInitiateResetRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeSteps expands an instance of InstanceInitiateResetRecipeSteps into a JSON
// request object.
func expandInstanceInitiateResetRecipeSteps(c *Client, f *InstanceInitiateResetRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeSteps flattens an instance of InstanceInitiateResetRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateResetRecipeSteps(c *Client, i interface{}) *InstanceInitiateResetRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceInitiateResetRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceInitiateResetRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceInitiateResetRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceInitiateResetRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceInitiateResetRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceInitiateResetRecipeStepsStatusMap expands the contents of InstanceInitiateResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsStatusMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsStatusSlice expands the contents of InstanceInitiateResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsStatusSlice(c *Client, f []InstanceInitiateResetRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsStatusMap flattens the contents of InstanceInitiateResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsStatus{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsStatusSlice flattens the contents of InstanceInitiateResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsStatus{}
	}

	items := make([]InstanceInitiateResetRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsStatus expands an instance of InstanceInitiateResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsStatus(c *Client, f *InstanceInitiateResetRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsStatus flattens an instance of InstanceInitiateResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsStatus(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceInitiateResetRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceInitiateResetRecipeStepsStatusDetailsMap expands the contents of InstanceInitiateResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsStatusDetailsSlice expands the contents of InstanceInitiateResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsStatusDetailsSlice(c *Client, f []InstanceInitiateResetRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsStatusDetailsMap flattens the contents of InstanceInitiateResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsStatusDetailsSlice flattens the contents of InstanceInitiateResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsStatusDetails{}
	}

	items := make([]InstanceInitiateResetRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsStatusDetails expands an instance of InstanceInitiateResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsStatusDetails(c *Client, f *InstanceInitiateResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsStatusDetails flattens an instance of InstanceInitiateResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceInitiateResetRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceInitiateResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceInitiateResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceInitiateResetRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceInitiateResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceInitiateResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceInitiateResetRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsQuotaRequestDeltas expands an instance of InstanceInitiateResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceInitiateResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltas flattens an instance of InstanceInitiateResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceInitiateResetRecipeStepsPreprocessUpdateMap expands the contents of InstanceInitiateResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsPreprocessUpdateSlice expands the contents of InstanceInitiateResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceInitiateResetRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsPreprocessUpdateMap flattens the contents of InstanceInitiateResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceInitiateResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceInitiateResetRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsPreprocessUpdate expands an instance of InstanceInitiateResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPreprocessUpdate(c *Client, f *InstanceInitiateResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsPreprocessUpdate flattens an instance of InstanceInitiateResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceInitiateResetRecipeStepsRequestedTenantProjectMap expands the contents of InstanceInitiateResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceInitiateResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceInitiateResetRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceInitiateResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceInitiateResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceInitiateResetRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsRequestedTenantProject expands an instance of InstanceInitiateResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsRequestedTenantProject(c *Client, f *InstanceInitiateResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsRequestedTenantProject flattens an instance of InstanceInitiateResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoMap expands the contents of InstanceInitiateResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoSlice expands the contents of InstanceInitiateResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceInitiateResetRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoMap flattens the contents of InstanceInitiateResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoSlice flattens the contents of InstanceInitiateResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceInitiateResetRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfo expands an instance of InstanceInitiateResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfo(c *Client, f *InstanceInitiateResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfo flattens an instance of InstanceInitiateResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceInitiateResetRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdate expands an instance of InstanceInitiateResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceInitiateResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceResetRecipeMap expands the contents of InstanceResetRecipe into a JSON
// request object.
func expandInstanceResetRecipeMap(c *Client, f map[string]InstanceResetRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeSlice expands the contents of InstanceResetRecipe into a JSON
// request object.
func expandInstanceResetRecipeSlice(c *Client, f []InstanceResetRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeMap flattens the contents of InstanceResetRecipe from a JSON
// response object.
func flattenInstanceResetRecipeMap(c *Client, i interface{}) map[string]InstanceResetRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipe{}
	}

	items := make(map[string]InstanceResetRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeSlice flattens the contents of InstanceResetRecipe from a JSON
// response object.
func flattenInstanceResetRecipeSlice(c *Client, i interface{}) []InstanceResetRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipe{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipe{}
	}

	items := make([]InstanceResetRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipe expands an instance of InstanceResetRecipe into a JSON
// request object.
func expandInstanceResetRecipe(c *Client, f *InstanceResetRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceResetRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipe flattens an instance of InstanceResetRecipe from a JSON
// response object.
func flattenInstanceResetRecipe(c *Client, i interface{}) *InstanceResetRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipe{}
	r.Steps = flattenInstanceResetRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceResetRecipeStepsMap expands the contents of InstanceResetRecipeSteps into a JSON
// request object.
func expandInstanceResetRecipeStepsMap(c *Client, f map[string]InstanceResetRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsSlice expands the contents of InstanceResetRecipeSteps into a JSON
// request object.
func expandInstanceResetRecipeStepsSlice(c *Client, f []InstanceResetRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsMap flattens the contents of InstanceResetRecipeSteps from a JSON
// response object.
func flattenInstanceResetRecipeStepsMap(c *Client, i interface{}) map[string]InstanceResetRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeSteps{}
	}

	items := make(map[string]InstanceResetRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsSlice flattens the contents of InstanceResetRecipeSteps from a JSON
// response object.
func flattenInstanceResetRecipeStepsSlice(c *Client, i interface{}) []InstanceResetRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeSteps{}
	}

	items := make([]InstanceResetRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeSteps expands an instance of InstanceResetRecipeSteps into a JSON
// request object.
func expandInstanceResetRecipeSteps(c *Client, f *InstanceResetRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceResetRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceResetRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceResetRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceResetRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceResetRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceResetRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeSteps flattens an instance of InstanceResetRecipeSteps from a JSON
// response object.
func flattenInstanceResetRecipeSteps(c *Client, i interface{}) *InstanceResetRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceResetRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceResetRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceResetRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceResetRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceResetRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceResetRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceResetRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceResetRecipeStepsStatusMap expands the contents of InstanceResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusMap(c *Client, f map[string]InstanceResetRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsStatusSlice expands the contents of InstanceResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusSlice(c *Client, f []InstanceResetRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsStatusMap flattens the contents of InstanceResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsStatus{}
	}

	items := make(map[string]InstanceResetRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsStatusSlice flattens the contents of InstanceResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceResetRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsStatus{}
	}

	items := make([]InstanceResetRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsStatus expands an instance of InstanceResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceResetRecipeStepsStatus(c *Client, f *InstanceResetRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceResetRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsStatus flattens an instance of InstanceResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatus(c *Client, i interface{}) *InstanceResetRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceResetRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceResetRecipeStepsStatusDetailsMap expands the contents of InstanceResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsStatusDetailsSlice expands the contents of InstanceResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusDetailsSlice(c *Client, f []InstanceResetRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsStatusDetailsMap flattens the contents of InstanceResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceResetRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsStatusDetailsSlice flattens the contents of InstanceResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceResetRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsStatusDetails{}
	}

	items := make([]InstanceResetRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsStatusDetails expands an instance of InstanceResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusDetails(c *Client, f *InstanceResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsStatusDetails flattens an instance of InstanceResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceResetRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceResetRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceResetRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceResetRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceResetRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceResetRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceResetRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceResetRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceResetRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsQuotaRequestDeltas expands an instance of InstanceResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceResetRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsQuotaRequestDeltas flattens an instance of InstanceResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceResetRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceResetRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceResetRecipeStepsPreprocessUpdateMap expands the contents of InstanceResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPreprocessUpdateSlice expands the contents of InstanceResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceResetRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPreprocessUpdateMap flattens the contents of InstanceResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceResetRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceResetRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPreprocessUpdate expands an instance of InstanceResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsPreprocessUpdate(c *Client, f *InstanceResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPreprocessUpdate flattens an instance of InstanceResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceResetRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceResetRecipeStepsRequestedTenantProjectMap expands the contents of InstanceResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceResetRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceResetRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceResetRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceResetRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceResetRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceResetRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceResetRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceResetRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsRequestedTenantProject expands an instance of InstanceResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceResetRecipeStepsRequestedTenantProject(c *Client, f *InstanceResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsRequestedTenantProject flattens an instance of InstanceResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceResetRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceResetRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceResetRecipeStepsPermissionsInfoMap expands the contents of InstanceResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPermissionsInfoSlice expands the contents of InstanceResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceResetRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoMap flattens the contents of InstanceResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceResetRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPermissionsInfoSlice flattens the contents of InstanceResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceResetRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPermissionsInfo expands an instance of InstanceResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfo(c *Client, f *InstanceResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceResetRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfo flattens an instance of InstanceResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceResetRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceResetRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceResetRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceResetRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceResetRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceResetRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceResetRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceResetRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceResetRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceResetRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceResetRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceResetRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceResetRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceResetRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceResetRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceResetRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceResetRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceResetRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceResetRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceResetRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdate expands an instance of InstanceResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceResetRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstancePreprocessRepairRecipeMap expands the contents of InstancePreprocessRepairRecipe into a JSON
// request object.
func expandInstancePreprocessRepairRecipeMap(c *Client, f map[string]InstancePreprocessRepairRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeSlice expands the contents of InstancePreprocessRepairRecipe into a JSON
// request object.
func expandInstancePreprocessRepairRecipeSlice(c *Client, f []InstancePreprocessRepairRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeMap flattens the contents of InstancePreprocessRepairRecipe from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipe{}
	}

	items := make(map[string]InstancePreprocessRepairRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeSlice flattens the contents of InstancePreprocessRepairRecipe from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipe{}
	}

	items := make([]InstancePreprocessRepairRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipe expands an instance of InstancePreprocessRepairRecipe into a JSON
// request object.
func expandInstancePreprocessRepairRecipe(c *Client, f *InstancePreprocessRepairRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipe flattens an instance of InstancePreprocessRepairRecipe from a JSON
// response object.
func flattenInstancePreprocessRepairRecipe(c *Client, i interface{}) *InstancePreprocessRepairRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipe{}
	r.Steps = flattenInstancePreprocessRepairRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsMap expands the contents of InstancePreprocessRepairRecipeSteps into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsMap(c *Client, f map[string]InstancePreprocessRepairRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsSlice expands the contents of InstancePreprocessRepairRecipeSteps into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsSlice(c *Client, f []InstancePreprocessRepairRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsMap flattens the contents of InstancePreprocessRepairRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsSlice flattens the contents of InstancePreprocessRepairRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeSteps{}
	}

	items := make([]InstancePreprocessRepairRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeSteps expands an instance of InstancePreprocessRepairRecipeSteps into a JSON
// request object.
func expandInstancePreprocessRepairRecipeSteps(c *Client, f *InstancePreprocessRepairRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeSteps flattens an instance of InstancePreprocessRepairRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeSteps(c *Client, i interface{}) *InstancePreprocessRepairRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessRepairRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessRepairRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsStatusMap expands the contents of InstancePreprocessRepairRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsStatusSlice expands the contents of InstancePreprocessRepairRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusSlice(c *Client, f []InstancePreprocessRepairRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsStatusMap flattens the contents of InstancePreprocessRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsStatusSlice flattens the contents of InstancePreprocessRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsStatus expands an instance of InstancePreprocessRepairRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatus(c *Client, f *InstancePreprocessRepairRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsStatus flattens an instance of InstancePreprocessRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessRepairRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsStatusDetails expands an instance of InstancePreprocessRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusDetails(c *Client, f *InstancePreprocessRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsStatusDetails flattens an instance of InstancePreprocessRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessRepairRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfo expands an instance of InstancePreprocessRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs expands an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceInitiateRepairRecipeMap expands the contents of InstanceInitiateRepairRecipe into a JSON
// request object.
func expandInstanceInitiateRepairRecipeMap(c *Client, f map[string]InstanceInitiateRepairRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeSlice expands the contents of InstanceInitiateRepairRecipe into a JSON
// request object.
func expandInstanceInitiateRepairRecipeSlice(c *Client, f []InstanceInitiateRepairRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeMap flattens the contents of InstanceInitiateRepairRecipe from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipe{}
	}

	items := make(map[string]InstanceInitiateRepairRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeSlice flattens the contents of InstanceInitiateRepairRecipe from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipe{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipe{}
	}

	items := make([]InstanceInitiateRepairRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipe expands an instance of InstanceInitiateRepairRecipe into a JSON
// request object.
func expandInstanceInitiateRepairRecipe(c *Client, f *InstanceInitiateRepairRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipe flattens an instance of InstanceInitiateRepairRecipe from a JSON
// response object.
func flattenInstanceInitiateRepairRecipe(c *Client, i interface{}) *InstanceInitiateRepairRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipe{}
	r.Steps = flattenInstanceInitiateRepairRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsMap expands the contents of InstanceInitiateRepairRecipeSteps into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsMap(c *Client, f map[string]InstanceInitiateRepairRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsSlice expands the contents of InstanceInitiateRepairRecipeSteps into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsSlice(c *Client, f []InstanceInitiateRepairRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsMap flattens the contents of InstanceInitiateRepairRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeSteps{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsSlice flattens the contents of InstanceInitiateRepairRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeSteps{}
	}

	items := make([]InstanceInitiateRepairRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeSteps expands an instance of InstanceInitiateRepairRecipeSteps into a JSON
// request object.
func expandInstanceInitiateRepairRecipeSteps(c *Client, f *InstanceInitiateRepairRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeSteps flattens an instance of InstanceInitiateRepairRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeSteps(c *Client, i interface{}) *InstanceInitiateRepairRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceInitiateRepairRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceInitiateRepairRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceInitiateRepairRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsStatusMap expands the contents of InstanceInitiateRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsStatusMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsStatusSlice expands the contents of InstanceInitiateRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsStatusSlice(c *Client, f []InstanceInitiateRepairRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsStatusMap flattens the contents of InstanceInitiateRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsStatus{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsStatusSlice flattens the contents of InstanceInitiateRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsStatus{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsStatus expands an instance of InstanceInitiateRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsStatus(c *Client, f *InstanceInitiateRepairRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsStatus flattens an instance of InstanceInitiateRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsStatus(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceInitiateRepairRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsStatusDetailsMap expands the contents of InstanceInitiateRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsStatusDetailsSlice expands the contents of InstanceInitiateRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsStatusDetailsSlice(c *Client, f []InstanceInitiateRepairRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsStatusDetailsMap flattens the contents of InstanceInitiateRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsStatusDetailsSlice flattens the contents of InstanceInitiateRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsStatusDetails{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsStatusDetails expands an instance of InstanceInitiateRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsStatusDetails(c *Client, f *InstanceInitiateRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsStatusDetails flattens an instance of InstanceInitiateRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceInitiateRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceInitiateRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceInitiateRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceInitiateRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltas expands an instance of InstanceInitiateRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltas flattens an instance of InstanceInitiateRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsPreprocessUpdateMap expands the contents of InstanceInitiateRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsPreprocessUpdateSlice expands the contents of InstanceInitiateRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceInitiateRepairRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsPreprocessUpdateMap flattens the contents of InstanceInitiateRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceInitiateRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsPreprocessUpdate expands an instance of InstanceInitiateRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPreprocessUpdate(c *Client, f *InstanceInitiateRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsPreprocessUpdate flattens an instance of InstanceInitiateRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsRequestedTenantProjectMap expands the contents of InstanceInitiateRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceInitiateRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceInitiateRepairRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceInitiateRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceInitiateRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsRequestedTenantProject expands an instance of InstanceInitiateRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsRequestedTenantProject(c *Client, f *InstanceInitiateRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsRequestedTenantProject flattens an instance of InstanceInitiateRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoMap expands the contents of InstanceInitiateRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoSlice expands the contents of InstanceInitiateRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceInitiateRepairRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoMap flattens the contents of InstanceInitiateRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoSlice flattens the contents of InstanceInitiateRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfo expands an instance of InstanceInitiateRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfo(c *Client, f *InstanceInitiateRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfo flattens an instance of InstanceInitiateRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate expands an instance of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceRepairRecipeMap expands the contents of InstanceRepairRecipe into a JSON
// request object.
func expandInstanceRepairRecipeMap(c *Client, f map[string]InstanceRepairRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeSlice expands the contents of InstanceRepairRecipe into a JSON
// request object.
func expandInstanceRepairRecipeSlice(c *Client, f []InstanceRepairRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeMap flattens the contents of InstanceRepairRecipe from a JSON
// response object.
func flattenInstanceRepairRecipeMap(c *Client, i interface{}) map[string]InstanceRepairRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipe{}
	}

	items := make(map[string]InstanceRepairRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeSlice flattens the contents of InstanceRepairRecipe from a JSON
// response object.
func flattenInstanceRepairRecipeSlice(c *Client, i interface{}) []InstanceRepairRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipe{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipe{}
	}

	items := make([]InstanceRepairRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipe expands an instance of InstanceRepairRecipe into a JSON
// request object.
func expandInstanceRepairRecipe(c *Client, f *InstanceRepairRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceRepairRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipe flattens an instance of InstanceRepairRecipe from a JSON
// response object.
func flattenInstanceRepairRecipe(c *Client, i interface{}) *InstanceRepairRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipe{}
	r.Steps = flattenInstanceRepairRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceRepairRecipeStepsMap expands the contents of InstanceRepairRecipeSteps into a JSON
// request object.
func expandInstanceRepairRecipeStepsMap(c *Client, f map[string]InstanceRepairRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsSlice expands the contents of InstanceRepairRecipeSteps into a JSON
// request object.
func expandInstanceRepairRecipeStepsSlice(c *Client, f []InstanceRepairRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsMap flattens the contents of InstanceRepairRecipeSteps from a JSON
// response object.
func flattenInstanceRepairRecipeStepsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeSteps{}
	}

	items := make(map[string]InstanceRepairRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsSlice flattens the contents of InstanceRepairRecipeSteps from a JSON
// response object.
func flattenInstanceRepairRecipeStepsSlice(c *Client, i interface{}) []InstanceRepairRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeSteps{}
	}

	items := make([]InstanceRepairRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeSteps expands an instance of InstanceRepairRecipeSteps into a JSON
// request object.
func expandInstanceRepairRecipeSteps(c *Client, f *InstanceRepairRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeSteps flattens an instance of InstanceRepairRecipeSteps from a JSON
// response object.
func flattenInstanceRepairRecipeSteps(c *Client, i interface{}) *InstanceRepairRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceRepairRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceRepairRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceRepairRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceRepairRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceRepairRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceRepairRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceRepairRecipeStepsStatusMap expands the contents of InstanceRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusMap(c *Client, f map[string]InstanceRepairRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsStatusSlice expands the contents of InstanceRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusSlice(c *Client, f []InstanceRepairRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsStatusMap flattens the contents of InstanceRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsStatus{}
	}

	items := make(map[string]InstanceRepairRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsStatusSlice flattens the contents of InstanceRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsStatus{}
	}

	items := make([]InstanceRepairRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsStatus expands an instance of InstanceRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatus(c *Client, f *InstanceRepairRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsStatus flattens an instance of InstanceRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatus(c *Client, i interface{}) *InstanceRepairRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceRepairRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceRepairRecipeStepsStatusDetailsMap expands the contents of InstanceRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsStatusDetailsSlice expands the contents of InstanceRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusDetailsSlice(c *Client, f []InstanceRepairRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsStatusDetailsMap flattens the contents of InstanceRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceRepairRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsStatusDetailsSlice flattens the contents of InstanceRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsStatusDetails{}
	}

	items := make([]InstanceRepairRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsStatusDetails expands an instance of InstanceRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusDetails(c *Client, f *InstanceRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsStatusDetails flattens an instance of InstanceRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceRepairRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceRepairRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceRepairRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceRepairRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceRepairRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceRepairRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceRepairRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsQuotaRequestDeltas expands an instance of InstanceRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceRepairRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsQuotaRequestDeltas flattens an instance of InstanceRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceRepairRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceRepairRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceRepairRecipeStepsPreprocessUpdateMap expands the contents of InstanceRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPreprocessUpdateSlice expands the contents of InstanceRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceRepairRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPreprocessUpdateMap flattens the contents of InstanceRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceRepairRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPreprocessUpdate expands an instance of InstanceRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsPreprocessUpdate(c *Client, f *InstanceRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPreprocessUpdate flattens an instance of InstanceRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceRepairRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceRepairRecipeStepsRequestedTenantProjectMap expands the contents of InstanceRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceRepairRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceRepairRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceRepairRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceRepairRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceRepairRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceRepairRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceRepairRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsRequestedTenantProject expands an instance of InstanceRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceRepairRecipeStepsRequestedTenantProject(c *Client, f *InstanceRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsRequestedTenantProject flattens an instance of InstanceRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceRepairRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceRepairRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceRepairRecipeStepsPermissionsInfoMap expands the contents of InstanceRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPermissionsInfoSlice expands the contents of InstanceRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceRepairRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoMap flattens the contents of InstanceRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPermissionsInfoSlice flattens the contents of InstanceRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceRepairRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPermissionsInfo expands an instance of InstanceRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfo(c *Client, f *InstanceRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfo flattens an instance of InstanceRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceRepairRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceRepairRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceRepairRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceRepairRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceRepairRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceRepairRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceRepairRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceRepairRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceRepairRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceRepairRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceRepairRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceRepairRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceRepairRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceRepairRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceRepairRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdate expands an instance of InstanceRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceRepairRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstancePreprocessDeleteRecipeMap expands the contents of InstancePreprocessDeleteRecipe into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeMap(c *Client, f map[string]InstancePreprocessDeleteRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeSlice expands the contents of InstancePreprocessDeleteRecipe into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeSlice(c *Client, f []InstancePreprocessDeleteRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeMap flattens the contents of InstancePreprocessDeleteRecipe from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipe{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeSlice flattens the contents of InstancePreprocessDeleteRecipe from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipe{}
	}

	items := make([]InstancePreprocessDeleteRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipe expands an instance of InstancePreprocessDeleteRecipe into a JSON
// request object.
func expandInstancePreprocessDeleteRecipe(c *Client, f *InstancePreprocessDeleteRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipe flattens an instance of InstancePreprocessDeleteRecipe from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipe(c *Client, i interface{}) *InstancePreprocessDeleteRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipe{}
	r.Steps = flattenInstancePreprocessDeleteRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsMap expands the contents of InstancePreprocessDeleteRecipeSteps into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsSlice expands the contents of InstancePreprocessDeleteRecipeSteps into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsSlice(c *Client, f []InstancePreprocessDeleteRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsMap flattens the contents of InstancePreprocessDeleteRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsSlice flattens the contents of InstancePreprocessDeleteRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeSteps{}
	}

	items := make([]InstancePreprocessDeleteRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeSteps expands an instance of InstancePreprocessDeleteRecipeSteps into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeSteps(c *Client, f *InstancePreprocessDeleteRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeSteps flattens an instance of InstancePreprocessDeleteRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeSteps(c *Client, i interface{}) *InstancePreprocessDeleteRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessDeleteRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessDeleteRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsStatusMap expands the contents of InstancePreprocessDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsStatusSlice expands the contents of InstancePreprocessDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsStatusMap flattens the contents of InstancePreprocessDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsStatusSlice flattens the contents of InstancePreprocessDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsStatus expands an instance of InstancePreprocessDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatus(c *Client, f *InstancePreprocessDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsStatus flattens an instance of InstancePreprocessDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsStatusDetails expands an instance of InstancePreprocessDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusDetails(c *Client, f *InstancePreprocessDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsStatusDetails flattens an instance of InstancePreprocessDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfo expands an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs expands an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceInitiateDeleteRecipeMap expands the contents of InstanceInitiateDeleteRecipe into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeMap(c *Client, f map[string]InstanceInitiateDeleteRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeSlice expands the contents of InstanceInitiateDeleteRecipe into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeSlice(c *Client, f []InstanceInitiateDeleteRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeMap flattens the contents of InstanceInitiateDeleteRecipe from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipe{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeSlice flattens the contents of InstanceInitiateDeleteRecipe from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipe{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipe{}
	}

	items := make([]InstanceInitiateDeleteRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipe expands an instance of InstanceInitiateDeleteRecipe into a JSON
// request object.
func expandInstanceInitiateDeleteRecipe(c *Client, f *InstanceInitiateDeleteRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipe flattens an instance of InstanceInitiateDeleteRecipe from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipe(c *Client, i interface{}) *InstanceInitiateDeleteRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipe{}
	r.Steps = flattenInstanceInitiateDeleteRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsMap expands the contents of InstanceInitiateDeleteRecipeSteps into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsMap(c *Client, f map[string]InstanceInitiateDeleteRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsSlice expands the contents of InstanceInitiateDeleteRecipeSteps into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsSlice(c *Client, f []InstanceInitiateDeleteRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsMap flattens the contents of InstanceInitiateDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeSteps{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsSlice flattens the contents of InstanceInitiateDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeSteps{}
	}

	items := make([]InstanceInitiateDeleteRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeSteps expands an instance of InstanceInitiateDeleteRecipeSteps into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeSteps(c *Client, f *InstanceInitiateDeleteRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeSteps flattens an instance of InstanceInitiateDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeSteps(c *Client, i interface{}) *InstanceInitiateDeleteRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceInitiateDeleteRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceInitiateDeleteRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsStatusMap expands the contents of InstanceInitiateDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsStatusMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsStatusSlice expands the contents of InstanceInitiateDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsStatusSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsStatusMap flattens the contents of InstanceInitiateDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsStatus{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsStatusSlice flattens the contents of InstanceInitiateDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsStatus{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsStatus expands an instance of InstanceInitiateDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsStatus(c *Client, f *InstanceInitiateDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsStatus flattens an instance of InstanceInitiateDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsStatus(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceInitiateDeleteRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsStatusDetailsMap expands the contents of InstanceInitiateDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsStatusDetailsSlice expands the contents of InstanceInitiateDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsStatusDetailsSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsStatusDetailsMap flattens the contents of InstanceInitiateDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsStatusDetailsSlice flattens the contents of InstanceInitiateDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsStatusDetails{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsStatusDetails expands an instance of InstanceInitiateDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsStatusDetails(c *Client, f *InstanceInitiateDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsStatusDetails flattens an instance of InstanceInitiateDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas expands an instance of InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas flattens an instance of InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsPreprocessUpdateMap expands the contents of InstanceInitiateDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsPreprocessUpdateSlice expands the contents of InstanceInitiateDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdateMap flattens the contents of InstanceInitiateDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceInitiateDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsPreprocessUpdate expands an instance of InstanceInitiateDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c *Client, f *InstanceInitiateDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdate flattens an instance of InstanceInitiateDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsRequestedTenantProjectMap expands the contents of InstanceInitiateDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceInitiateDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceInitiateDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceInitiateDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsRequestedTenantProject expands an instance of InstanceInitiateDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c *Client, f *InstanceInitiateDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProject flattens an instance of InstanceInitiateDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoMap expands the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice expands the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoMap flattens the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice flattens the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfo expands an instance of InstanceInitiateDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfo(c *Client, f *InstanceInitiateDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfo flattens an instance of InstanceInitiateDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate expands an instance of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstancePreprocessUpdateRecipeMap expands the contents of InstancePreprocessUpdateRecipe into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeMap(c *Client, f map[string]InstancePreprocessUpdateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeSlice expands the contents of InstancePreprocessUpdateRecipe into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeSlice(c *Client, f []InstancePreprocessUpdateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeMap flattens the contents of InstancePreprocessUpdateRecipe from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipe{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeSlice flattens the contents of InstancePreprocessUpdateRecipe from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipe{}
	}

	items := make([]InstancePreprocessUpdateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipe expands an instance of InstancePreprocessUpdateRecipe into a JSON
// request object.
func expandInstancePreprocessUpdateRecipe(c *Client, f *InstancePreprocessUpdateRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipe flattens an instance of InstancePreprocessUpdateRecipe from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipe(c *Client, i interface{}) *InstancePreprocessUpdateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipe{}
	r.Steps = flattenInstancePreprocessUpdateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsMap expands the contents of InstancePreprocessUpdateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsSlice expands the contents of InstancePreprocessUpdateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsSlice(c *Client, f []InstancePreprocessUpdateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsMap flattens the contents of InstancePreprocessUpdateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsSlice flattens the contents of InstancePreprocessUpdateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeSteps{}
	}

	items := make([]InstancePreprocessUpdateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeSteps expands an instance of InstancePreprocessUpdateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeSteps(c *Client, f *InstancePreprocessUpdateRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeSteps flattens an instance of InstancePreprocessUpdateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeSteps(c *Client, i interface{}) *InstancePreprocessUpdateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessUpdateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessUpdateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsStatusMap expands the contents of InstancePreprocessUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsStatusSlice expands the contents of InstancePreprocessUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsStatusMap flattens the contents of InstancePreprocessUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsStatusSlice flattens the contents of InstancePreprocessUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsStatus expands an instance of InstancePreprocessUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatus(c *Client, f *InstancePreprocessUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsStatus flattens an instance of InstancePreprocessUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsStatusDetails expands an instance of InstancePreprocessUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusDetails(c *Client, f *InstancePreprocessUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsStatusDetails flattens an instance of InstancePreprocessUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfo expands an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs expands an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceInitiateUpdateRecipeMap expands the contents of InstanceInitiateUpdateRecipe into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeMap(c *Client, f map[string]InstanceInitiateUpdateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeSlice expands the contents of InstanceInitiateUpdateRecipe into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeSlice(c *Client, f []InstanceInitiateUpdateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeMap flattens the contents of InstanceInitiateUpdateRecipe from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipe{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeSlice flattens the contents of InstanceInitiateUpdateRecipe from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipe{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipe{}
	}

	items := make([]InstanceInitiateUpdateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipe expands an instance of InstanceInitiateUpdateRecipe into a JSON
// request object.
func expandInstanceInitiateUpdateRecipe(c *Client, f *InstanceInitiateUpdateRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipe flattens an instance of InstanceInitiateUpdateRecipe from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipe(c *Client, i interface{}) *InstanceInitiateUpdateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipe{}
	r.Steps = flattenInstanceInitiateUpdateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsMap expands the contents of InstanceInitiateUpdateRecipeSteps into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsMap(c *Client, f map[string]InstanceInitiateUpdateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsSlice expands the contents of InstanceInitiateUpdateRecipeSteps into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsSlice(c *Client, f []InstanceInitiateUpdateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsMap flattens the contents of InstanceInitiateUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeSteps{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsSlice flattens the contents of InstanceInitiateUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeSteps{}
	}

	items := make([]InstanceInitiateUpdateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeSteps expands an instance of InstanceInitiateUpdateRecipeSteps into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeSteps(c *Client, f *InstanceInitiateUpdateRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeSteps flattens an instance of InstanceInitiateUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeSteps(c *Client, i interface{}) *InstanceInitiateUpdateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceInitiateUpdateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceInitiateUpdateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsStatusMap expands the contents of InstanceInitiateUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsStatusMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsStatusSlice expands the contents of InstanceInitiateUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsStatusSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsStatusMap flattens the contents of InstanceInitiateUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsStatus{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsStatusSlice flattens the contents of InstanceInitiateUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsStatus{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsStatus expands an instance of InstanceInitiateUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsStatus(c *Client, f *InstanceInitiateUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsStatus flattens an instance of InstanceInitiateUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsStatus(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceInitiateUpdateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsStatusDetailsMap expands the contents of InstanceInitiateUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsStatusDetailsSlice expands the contents of InstanceInitiateUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsStatusDetailsSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsStatusDetailsMap flattens the contents of InstanceInitiateUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsStatusDetailsSlice flattens the contents of InstanceInitiateUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsStatusDetails{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsStatusDetails expands an instance of InstanceInitiateUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsStatusDetails(c *Client, f *InstanceInitiateUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsStatusDetails flattens an instance of InstanceInitiateUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas expands an instance of InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas flattens an instance of InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsPreprocessUpdateMap expands the contents of InstanceInitiateUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsPreprocessUpdateSlice expands the contents of InstanceInitiateUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdateMap flattens the contents of InstanceInitiateUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceInitiateUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsPreprocessUpdate expands an instance of InstanceInitiateUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c *Client, f *InstanceInitiateUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdate flattens an instance of InstanceInitiateUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsRequestedTenantProjectMap expands the contents of InstanceInitiateUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceInitiateUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceInitiateUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceInitiateUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsRequestedTenantProject expands an instance of InstanceInitiateUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c *Client, f *InstanceInitiateUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProject flattens an instance of InstanceInitiateUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoMap expands the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice expands the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoMap flattens the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice flattens the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfo expands an instance of InstanceInitiateUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfo(c *Client, f *InstanceInitiateUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfo flattens an instance of InstanceInitiateUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate expands an instance of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceInitiateUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstancePreprocessFreezeRecipeMap expands the contents of InstancePreprocessFreezeRecipe into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeMap(c *Client, f map[string]InstancePreprocessFreezeRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeSlice expands the contents of InstancePreprocessFreezeRecipe into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeSlice(c *Client, f []InstancePreprocessFreezeRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeMap flattens the contents of InstancePreprocessFreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipe{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeSlice flattens the contents of InstancePreprocessFreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipe{}
	}

	items := make([]InstancePreprocessFreezeRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipe expands an instance of InstancePreprocessFreezeRecipe into a JSON
// request object.
func expandInstancePreprocessFreezeRecipe(c *Client, f *InstancePreprocessFreezeRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipe flattens an instance of InstancePreprocessFreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipe(c *Client, i interface{}) *InstancePreprocessFreezeRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipe{}
	r.Steps = flattenInstancePreprocessFreezeRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsMap expands the contents of InstancePreprocessFreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsSlice expands the contents of InstancePreprocessFreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsSlice(c *Client, f []InstancePreprocessFreezeRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsMap flattens the contents of InstancePreprocessFreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsSlice flattens the contents of InstancePreprocessFreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeSteps{}
	}

	items := make([]InstancePreprocessFreezeRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeSteps expands an instance of InstancePreprocessFreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeSteps(c *Client, f *InstancePreprocessFreezeRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeSteps flattens an instance of InstancePreprocessFreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeSteps(c *Client, i interface{}) *InstancePreprocessFreezeRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessFreezeRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessFreezeRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsStatusMap expands the contents of InstancePreprocessFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsStatusSlice expands the contents of InstancePreprocessFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsStatusMap flattens the contents of InstancePreprocessFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsStatusSlice flattens the contents of InstancePreprocessFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsStatus expands an instance of InstancePreprocessFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatus(c *Client, f *InstancePreprocessFreezeRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsStatus flattens an instance of InstancePreprocessFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsStatusDetails expands an instance of InstancePreprocessFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusDetails(c *Client, f *InstancePreprocessFreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsStatusDetails flattens an instance of InstancePreprocessFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessFreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessFreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfo expands an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessFreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs expands an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceFreezeRecipeMap expands the contents of InstanceFreezeRecipe into a JSON
// request object.
func expandInstanceFreezeRecipeMap(c *Client, f map[string]InstanceFreezeRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeSlice expands the contents of InstanceFreezeRecipe into a JSON
// request object.
func expandInstanceFreezeRecipeSlice(c *Client, f []InstanceFreezeRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeMap flattens the contents of InstanceFreezeRecipe from a JSON
// response object.
func flattenInstanceFreezeRecipeMap(c *Client, i interface{}) map[string]InstanceFreezeRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipe{}
	}

	items := make(map[string]InstanceFreezeRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeSlice flattens the contents of InstanceFreezeRecipe from a JSON
// response object.
func flattenInstanceFreezeRecipeSlice(c *Client, i interface{}) []InstanceFreezeRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipe{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipe{}
	}

	items := make([]InstanceFreezeRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipe expands an instance of InstanceFreezeRecipe into a JSON
// request object.
func expandInstanceFreezeRecipe(c *Client, f *InstanceFreezeRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceFreezeRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipe flattens an instance of InstanceFreezeRecipe from a JSON
// response object.
func flattenInstanceFreezeRecipe(c *Client, i interface{}) *InstanceFreezeRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipe{}
	r.Steps = flattenInstanceFreezeRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceFreezeRecipeStepsMap expands the contents of InstanceFreezeRecipeSteps into a JSON
// request object.
func expandInstanceFreezeRecipeStepsMap(c *Client, f map[string]InstanceFreezeRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsSlice expands the contents of InstanceFreezeRecipeSteps into a JSON
// request object.
func expandInstanceFreezeRecipeStepsSlice(c *Client, f []InstanceFreezeRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsMap flattens the contents of InstanceFreezeRecipeSteps from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeSteps{}
	}

	items := make(map[string]InstanceFreezeRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsSlice flattens the contents of InstanceFreezeRecipeSteps from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsSlice(c *Client, i interface{}) []InstanceFreezeRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeSteps{}
	}

	items := make([]InstanceFreezeRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeSteps expands an instance of InstanceFreezeRecipeSteps into a JSON
// request object.
func expandInstanceFreezeRecipeSteps(c *Client, f *InstanceFreezeRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeSteps flattens an instance of InstanceFreezeRecipeSteps from a JSON
// response object.
func flattenInstanceFreezeRecipeSteps(c *Client, i interface{}) *InstanceFreezeRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceFreezeRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceFreezeRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceFreezeRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceFreezeRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceFreezeRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceFreezeRecipeStepsStatusMap expands the contents of InstanceFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusMap(c *Client, f map[string]InstanceFreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsStatusSlice expands the contents of InstanceFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusSlice(c *Client, f []InstanceFreezeRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsStatusMap flattens the contents of InstanceFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsStatus{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsStatusSlice flattens the contents of InstanceFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsStatus{}
	}

	items := make([]InstanceFreezeRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsStatus expands an instance of InstanceFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatus(c *Client, f *InstanceFreezeRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsStatus flattens an instance of InstanceFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatus(c *Client, i interface{}) *InstanceFreezeRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceFreezeRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceFreezeRecipeStepsStatusDetailsMap expands the contents of InstanceFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceFreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsStatusDetailsSlice expands the contents of InstanceFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusDetailsSlice(c *Client, f []InstanceFreezeRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsStatusDetailsMap flattens the contents of InstanceFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsStatusDetailsSlice flattens the contents of InstanceFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsStatusDetails{}
	}

	items := make([]InstanceFreezeRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsStatusDetails expands an instance of InstanceFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusDetails(c *Client, f *InstanceFreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsStatusDetails flattens an instance of InstanceFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceFreezeRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceFreezeRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceFreezeRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceFreezeRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsQuotaRequestDeltas expands an instance of InstanceFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceFreezeRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceFreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsQuotaRequestDeltas flattens an instance of InstanceFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceFreezeRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceFreezeRecipeStepsPreprocessUpdateMap expands the contents of InstanceFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceFreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPreprocessUpdateSlice expands the contents of InstanceFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceFreezeRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPreprocessUpdateMap flattens the contents of InstanceFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceFreezeRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPreprocessUpdate expands an instance of InstanceFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPreprocessUpdate(c *Client, f *InstanceFreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPreprocessUpdate flattens an instance of InstanceFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceFreezeRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceFreezeRecipeStepsRequestedTenantProjectMap expands the contents of InstanceFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceFreezeRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceFreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceFreezeRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceFreezeRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsRequestedTenantProject expands an instance of InstanceFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceFreezeRecipeStepsRequestedTenantProject(c *Client, f *InstanceFreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProject flattens an instance of InstanceFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceFreezeRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceFreezeRecipeStepsPermissionsInfoMap expands the contents of InstanceFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceFreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPermissionsInfoSlice expands the contents of InstanceFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceFreezeRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoMap flattens the contents of InstanceFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoSlice flattens the contents of InstanceFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceFreezeRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPermissionsInfo expands an instance of InstanceFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfo(c *Client, f *InstanceFreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfo flattens an instance of InstanceFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceFreezeRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceFreezeRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceFreezeRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceFreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceFreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceFreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceFreezeRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceFreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceFreezeRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceFreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceFreezeRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceFreezeRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceFreezeRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdate expands an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceFreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeMap expands the contents of InstancePreprocessUnfreezeRecipe into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeSlice expands the contents of InstancePreprocessUnfreezeRecipe into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeSlice(c *Client, f []InstancePreprocessUnfreezeRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeMap flattens the contents of InstancePreprocessUnfreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipe{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeSlice flattens the contents of InstancePreprocessUnfreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipe{}
	}

	items := make([]InstancePreprocessUnfreezeRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipe expands an instance of InstancePreprocessUnfreezeRecipe into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipe(c *Client, f *InstancePreprocessUnfreezeRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipe flattens an instance of InstancePreprocessUnfreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipe(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipe{}
	r.Steps = flattenInstancePreprocessUnfreezeRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsMap expands the contents of InstancePreprocessUnfreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsSlice expands the contents of InstancePreprocessUnfreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsMap flattens the contents of InstancePreprocessUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsSlice flattens the contents of InstancePreprocessUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeSteps{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeSteps expands an instance of InstancePreprocessUnfreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeSteps(c *Client, f *InstancePreprocessUnfreezeRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeSteps flattens an instance of InstancePreprocessUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeSteps(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessUnfreezeRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessUnfreezeRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusMap expands the contents of InstancePreprocessUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsStatus expands an instance of InstancePreprocessUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatus(c *Client, f *InstancePreprocessUnfreezeRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatus flattens an instance of InstancePreprocessUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusDetails expands an instance of InstancePreprocessUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusDetails(c *Client, f *InstancePreprocessUnfreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusDetails flattens an instance of InstancePreprocessUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfo expands an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs expands an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceUnfreezeRecipeMap expands the contents of InstanceUnfreezeRecipe into a JSON
// request object.
func expandInstanceUnfreezeRecipeMap(c *Client, f map[string]InstanceUnfreezeRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeSlice expands the contents of InstanceUnfreezeRecipe into a JSON
// request object.
func expandInstanceUnfreezeRecipeSlice(c *Client, f []InstanceUnfreezeRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeMap flattens the contents of InstanceUnfreezeRecipe from a JSON
// response object.
func flattenInstanceUnfreezeRecipeMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipe{}
	}

	items := make(map[string]InstanceUnfreezeRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeSlice flattens the contents of InstanceUnfreezeRecipe from a JSON
// response object.
func flattenInstanceUnfreezeRecipeSlice(c *Client, i interface{}) []InstanceUnfreezeRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipe{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipe{}
	}

	items := make([]InstanceUnfreezeRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipe expands an instance of InstanceUnfreezeRecipe into a JSON
// request object.
func expandInstanceUnfreezeRecipe(c *Client, f *InstanceUnfreezeRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUnfreezeRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipe flattens an instance of InstanceUnfreezeRecipe from a JSON
// response object.
func flattenInstanceUnfreezeRecipe(c *Client, i interface{}) *InstanceUnfreezeRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipe{}
	r.Steps = flattenInstanceUnfreezeRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceUnfreezeRecipeStepsMap expands the contents of InstanceUnfreezeRecipeSteps into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsMap(c *Client, f map[string]InstanceUnfreezeRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsSlice expands the contents of InstanceUnfreezeRecipeSteps into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsSlice(c *Client, f []InstanceUnfreezeRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsMap flattens the contents of InstanceUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeSteps{}
	}

	items := make(map[string]InstanceUnfreezeRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsSlice flattens the contents of InstanceUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeSteps{}
	}

	items := make([]InstanceUnfreezeRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeSteps expands an instance of InstanceUnfreezeRecipeSteps into a JSON
// request object.
func expandInstanceUnfreezeRecipeSteps(c *Client, f *InstanceUnfreezeRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeSteps flattens an instance of InstanceUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstanceUnfreezeRecipeSteps(c *Client, i interface{}) *InstanceUnfreezeRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceUnfreezeRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceUnfreezeRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceUnfreezeRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceUnfreezeRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceUnfreezeRecipeStepsStatusMap expands the contents of InstanceUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsStatusSlice expands the contents of InstanceUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusSlice(c *Client, f []InstanceUnfreezeRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsStatusMap flattens the contents of InstanceUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsStatus{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsStatusSlice flattens the contents of InstanceUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsStatus{}
	}

	items := make([]InstanceUnfreezeRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsStatus expands an instance of InstanceUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatus(c *Client, f *InstanceUnfreezeRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsStatus flattens an instance of InstanceUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatus(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceUnfreezeRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceUnfreezeRecipeStepsStatusDetailsMap expands the contents of InstanceUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsStatusDetailsSlice expands the contents of InstanceUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusDetailsSlice(c *Client, f []InstanceUnfreezeRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsStatusDetailsMap flattens the contents of InstanceUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsStatusDetailsSlice flattens the contents of InstanceUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsStatusDetails{}
	}

	items := make([]InstanceUnfreezeRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsStatusDetails expands an instance of InstanceUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusDetails(c *Client, f *InstanceUnfreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsStatusDetails flattens an instance of InstanceUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceUnfreezeRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceUnfreezeRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsQuotaRequestDeltas expands an instance of InstanceUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceUnfreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltas flattens an instance of InstanceUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPreprocessUpdateMap expands the contents of InstanceUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPreprocessUpdateSlice expands the contents of InstanceUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceUnfreezeRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPreprocessUpdateMap flattens the contents of InstanceUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPreprocessUpdate expands an instance of InstanceUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPreprocessUpdate(c *Client, f *InstanceUnfreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPreprocessUpdate flattens an instance of InstanceUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceUnfreezeRecipeStepsRequestedTenantProjectMap expands the contents of InstanceUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceUnfreezeRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceUnfreezeRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsRequestedTenantProject expands an instance of InstanceUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsRequestedTenantProject(c *Client, f *InstanceUnfreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProject flattens an instance of InstanceUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoMap expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoSlice expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceUnfreezeRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoMap flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoSlice flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfo expands an instance of InstanceUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfo(c *Client, f *InstanceUnfreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfo flattens an instance of InstanceUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate expands an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceReadonlyRecipeMap expands the contents of InstanceReadonlyRecipe into a JSON
// request object.
func expandInstanceReadonlyRecipeMap(c *Client, f map[string]InstanceReadonlyRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeSlice expands the contents of InstanceReadonlyRecipe into a JSON
// request object.
func expandInstanceReadonlyRecipeSlice(c *Client, f []InstanceReadonlyRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeMap flattens the contents of InstanceReadonlyRecipe from a JSON
// response object.
func flattenInstanceReadonlyRecipeMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipe{}
	}

	items := make(map[string]InstanceReadonlyRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeSlice flattens the contents of InstanceReadonlyRecipe from a JSON
// response object.
func flattenInstanceReadonlyRecipeSlice(c *Client, i interface{}) []InstanceReadonlyRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipe{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipe{}
	}

	items := make([]InstanceReadonlyRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipe expands an instance of InstanceReadonlyRecipe into a JSON
// request object.
func expandInstanceReadonlyRecipe(c *Client, f *InstanceReadonlyRecipe) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceReadonlyRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipe flattens an instance of InstanceReadonlyRecipe from a JSON
// response object.
func flattenInstanceReadonlyRecipe(c *Client, i interface{}) *InstanceReadonlyRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipe{}
	r.Steps = flattenInstanceReadonlyRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceReadonlyRecipeStepsMap expands the contents of InstanceReadonlyRecipeSteps into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsMap(c *Client, f map[string]InstanceReadonlyRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsSlice expands the contents of InstanceReadonlyRecipeSteps into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsSlice(c *Client, f []InstanceReadonlyRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsMap flattens the contents of InstanceReadonlyRecipeSteps from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeSteps{}
	}

	items := make(map[string]InstanceReadonlyRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsSlice flattens the contents of InstanceReadonlyRecipeSteps from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeSteps{}
	}

	items := make([]InstanceReadonlyRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeSteps expands an instance of InstanceReadonlyRecipeSteps into a JSON
// request object.
func expandInstanceReadonlyRecipeSteps(c *Client, f *InstanceReadonlyRecipeSteps) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeSteps flattens an instance of InstanceReadonlyRecipeSteps from a JSON
// response object.
func flattenInstanceReadonlyRecipeSteps(c *Client, i interface{}) *InstanceReadonlyRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeSteps{}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceReadonlyRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceReadonlyRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceReadonlyRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceReadonlyRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceReadonlyRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])

	return r
}

// expandInstanceReadonlyRecipeStepsStatusMap expands the contents of InstanceReadonlyRecipeStepsStatus into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusMap(c *Client, f map[string]InstanceReadonlyRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsStatusSlice expands the contents of InstanceReadonlyRecipeStepsStatus into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusSlice(c *Client, f []InstanceReadonlyRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsStatusMap flattens the contents of InstanceReadonlyRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsStatus{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsStatusSlice flattens the contents of InstanceReadonlyRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsStatus{}
	}

	items := make([]InstanceReadonlyRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsStatus expands an instance of InstanceReadonlyRecipeStepsStatus into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatus(c *Client, f *InstanceReadonlyRecipeStepsStatus) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsStatus flattens an instance of InstanceReadonlyRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatus(c *Client, i interface{}) *InstanceReadonlyRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsStatus{}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceReadonlyRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceReadonlyRecipeStepsStatusDetailsMap expands the contents of InstanceReadonlyRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceReadonlyRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsStatusDetailsSlice expands the contents of InstanceReadonlyRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusDetailsSlice(c *Client, f []InstanceReadonlyRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsStatusDetailsMap flattens the contents of InstanceReadonlyRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsStatusDetailsSlice flattens the contents of InstanceReadonlyRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsStatusDetails{}
	}

	items := make([]InstanceReadonlyRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsStatusDetails expands an instance of InstanceReadonlyRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusDetails(c *Client, f *InstanceReadonlyRecipeStepsStatusDetails) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsStatusDetails flattens an instance of InstanceReadonlyRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceReadonlyRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsStatusDetails{}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceReadonlyRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceReadonlyRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceReadonlyRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceReadonlyRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceReadonlyRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceReadonlyRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceReadonlyRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsQuotaRequestDeltas expands an instance of InstanceReadonlyRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceReadonlyRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsQuotaRequestDeltas flattens an instance of InstanceReadonlyRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceReadonlyRecipeStepsPreprocessUpdateMap expands the contents of InstanceReadonlyRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPreprocessUpdateSlice expands the contents of InstanceReadonlyRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceReadonlyRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPreprocessUpdateMap flattens the contents of InstanceReadonlyRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceReadonlyRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceReadonlyRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPreprocessUpdate expands an instance of InstanceReadonlyRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPreprocessUpdate(c *Client, f *InstanceReadonlyRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPreprocessUpdate flattens an instance of InstanceReadonlyRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPreprocessUpdate{}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceReadonlyRecipeStepsRequestedTenantProjectMap expands the contents of InstanceReadonlyRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceReadonlyRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceReadonlyRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceReadonlyRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceReadonlyRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceReadonlyRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceReadonlyRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsRequestedTenantProject expands an instance of InstanceReadonlyRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsRequestedTenantProject(c *Client, f *InstanceReadonlyRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProject flattens an instance of InstanceReadonlyRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceReadonlyRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsRequestedTenantProject{}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoMap expands the contents of InstanceReadonlyRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoSlice expands the contents of InstanceReadonlyRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceReadonlyRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoMap flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoSlice flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceReadonlyRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPermissionsInfo expands an instance of InstanceReadonlyRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfo(c *Client, f *InstanceReadonlyRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfo flattens an instance of InstanceReadonlyRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPermissionsInfo{}
	r.PolicyName = flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, m["apiAttrs"])

	return r
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsMap expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsSlice expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, f []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsMap flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsSlice flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs{}
	}

	items := make([]InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs expands an instance of InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c *Client, f *InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs flattens an instance of InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoApiAttrs(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPermissionsInfoApiAttrs{}

	return r
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceReadonlyRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceReadonlyRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate expands an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceReadonlyRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	r.KeyNotificationsInfo = flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, f.KeyConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfigs into keyConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfigs"] = v
	}
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	r.KeyConfigs = flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, m["keyConfigs"])
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])

	return r
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, f map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, f []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	}

	items := make([]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs expands an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, f *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, f.KeyConfig); err != nil {
		return nil, fmt.Errorf("error expanding KeyConfig into keyConfig: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyConfig"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs flattens an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs(c *Client, i interface{}) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigs{}
	r.KeyConfig = flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, m["keyConfig"])

	return r
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, f map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, f []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfigSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	}

	items := make([]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig expands an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, f *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig flattens an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig(c *Client, i interface{}) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyConfigsKeyConfig{}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])

	return r
}

// expandInstanceHistoryMap expands the contents of InstanceHistory into a JSON
// request object.
func expandInstanceHistoryMap(c *Client, f map[string]InstanceHistory) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceHistory(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceHistorySlice expands the contents of InstanceHistory into a JSON
// request object.
func expandInstanceHistorySlice(c *Client, f []InstanceHistory) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceHistory(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceHistoryMap flattens the contents of InstanceHistory from a JSON
// response object.
func flattenInstanceHistoryMap(c *Client, i interface{}) map[string]InstanceHistory {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceHistory{}
	}

	if len(a) == 0 {
		return map[string]InstanceHistory{}
	}

	items := make(map[string]InstanceHistory)
	for k, item := range a {
		items[k] = *flattenInstanceHistory(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceHistorySlice flattens the contents of InstanceHistory from a JSON
// response object.
func flattenInstanceHistorySlice(c *Client, i interface{}) []InstanceHistory {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceHistory{}
	}

	if len(a) == 0 {
		return []InstanceHistory{}
	}

	items := make([]InstanceHistory, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceHistory(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceHistory expands an instance of InstanceHistory into a JSON
// request object.
func expandInstanceHistory(c *Client, f *InstanceHistory) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}
	if v := f.Timestamp; !dcl.IsEmptyValueIndirect(v) {
		m["timestamp"] = v
	}
	if v := f.OperationHandle; !dcl.IsEmptyValueIndirect(v) {
		m["operationHandle"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.StepIndex; !dcl.IsEmptyValueIndirect(v) {
		m["stepIndex"] = v
	}
	if v := f.TenantProjectNumber; !dcl.IsEmptyValueIndirect(v) {
		m["tenantProjectNumber"] = v
	}
	if v := f.TenantProjectId; !dcl.IsEmptyValueIndirect(v) {
		m["tenantProjectId"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}

	return m, nil
}

// flattenInstanceHistory flattens an instance of InstanceHistory from a JSON
// response object.
func flattenInstanceHistory(c *Client, i interface{}) *InstanceHistory {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceHistory{}
	r.Timestamp = dcl.FlattenString(m["timestamp"])
	r.OperationHandle = dcl.FlattenString(m["operationHandle"])
	r.Description = dcl.FlattenString(m["description"])
	r.StepIndex = dcl.FlattenInteger(m["stepIndex"])
	r.TenantProjectNumber = dcl.FlattenInteger(m["tenantProjectNumber"])
	r.TenantProjectId = dcl.FlattenString(m["tenantProjectId"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])

	return r
}

// flattenInstanceSkuTierEnumSlice flattens the contents of InstanceSkuTierEnum from a JSON
// response object.
func flattenInstanceSkuTierEnumSlice(c *Client, i interface{}) []InstanceSkuTierEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceSkuTierEnum{}
	}

	if len(a) == 0 {
		return []InstanceSkuTierEnum{}
	}

	items := make([]InstanceSkuTierEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceSkuTierEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceSkuTierEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceSkuTierEnum with the same value as that string.
func flattenInstanceSkuTierEnum(i interface{}) *InstanceSkuTierEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceSkuTierEnumRef("")
	}

	return InstanceSkuTierEnumRef(s)
}

// flattenInstanceSkuSizeEnumSlice flattens the contents of InstanceSkuSizeEnum from a JSON
// response object.
func flattenInstanceSkuSizeEnumSlice(c *Client, i interface{}) []InstanceSkuSizeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceSkuSizeEnum{}
	}

	if len(a) == 0 {
		return []InstanceSkuSizeEnum{}
	}

	items := make([]InstanceSkuSizeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceSkuSizeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceSkuSizeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceSkuSizeEnum with the same value as that string.
func flattenInstanceSkuSizeEnum(i interface{}) *InstanceSkuSizeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceSkuSizeEnumRef("")
	}

	return InstanceSkuSizeEnumRef(s)
}

// flattenInstanceStateEnumSlice flattens the contents of InstanceStateEnum from a JSON
// response object.
func flattenInstanceStateEnumSlice(c *Client, i interface{}) []InstanceStateEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceStateEnum{}
	}

	if len(a) == 0 {
		return []InstanceStateEnum{}
	}

	items := make([]InstanceStateEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceStateEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceStateEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceStateEnum with the same value as that string.
func flattenInstanceStateEnum(i interface{}) *InstanceStateEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceStateEnumRef("")
	}

	return InstanceStateEnumRef(s)
}

// flattenInstancePreprocessCreateRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessCreateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessCreateRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessCreateRecipeStepsActionEnum(i interface{}) *InstancePreprocessCreateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessCreateRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessCreateRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceInitiateCreateRecipeStepsActionEnumSlice flattens the contents of InstanceInitiateCreateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsActionEnum{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateCreateRecipeStepsActionEnum with the same value as that string.
func flattenInstanceInitiateCreateRecipeStepsActionEnum(i interface{}) *InstanceInitiateCreateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateCreateRecipeStepsActionEnumRef("")
	}

	return InstanceInitiateCreateRecipeStepsActionEnumRef(s)
}

// flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceInitiateCreateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceCreateRecipeStepsActionEnumSlice flattens the contents of InstanceCreateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceCreateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsActionEnum{}
	}

	items := make([]InstanceCreateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceCreateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceCreateRecipeStepsActionEnum with the same value as that string.
func flattenInstanceCreateRecipeStepsActionEnum(i interface{}) *InstanceCreateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceCreateRecipeStepsActionEnumRef("")
	}

	return InstanceCreateRecipeStepsActionEnumRef(s)
}

// flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceCreateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceCreateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceDeleteRecipeStepsActionEnumSlice flattens the contents of InstanceDeleteRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsActionEnum{}
	}

	items := make([]InstanceDeleteRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceDeleteRecipeStepsActionEnum with the same value as that string.
func flattenInstanceDeleteRecipeStepsActionEnum(i interface{}) *InstanceDeleteRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceDeleteRecipeStepsActionEnumRef("")
	}

	return InstanceDeleteRecipeStepsActionEnumRef(s)
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceUpdateRecipeStepsActionEnumSlice flattens the contents of InstanceUpdateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsActionEnum{}
	}

	items := make([]InstanceUpdateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceUpdateRecipeStepsActionEnum with the same value as that string.
func flattenInstanceUpdateRecipeStepsActionEnum(i interface{}) *InstanceUpdateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceUpdateRecipeStepsActionEnumRef("")
	}

	return InstanceUpdateRecipeStepsActionEnumRef(s)
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessResetRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessResetRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessResetRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessResetRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessResetRecipeStepsActionEnum(i interface{}) *InstancePreprocessResetRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessResetRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessResetRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceInitiateResetRecipeStepsActionEnumSlice flattens the contents of InstanceInitiateResetRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsActionEnum{}
	}

	items := make([]InstanceInitiateResetRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateResetRecipeStepsActionEnum with the same value as that string.
func flattenInstanceInitiateResetRecipeStepsActionEnum(i interface{}) *InstanceInitiateResetRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateResetRecipeStepsActionEnumRef("")
	}

	return InstanceInitiateResetRecipeStepsActionEnumRef(s)
}

// flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceInitiateResetRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceResetRecipeStepsActionEnumSlice flattens the contents of InstanceResetRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceResetRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceResetRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsActionEnum{}
	}

	items := make([]InstanceResetRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceResetRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceResetRecipeStepsActionEnum with the same value as that string.
func flattenInstanceResetRecipeStepsActionEnum(i interface{}) *InstanceResetRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceResetRecipeStepsActionEnumRef("")
	}

	return InstanceResetRecipeStepsActionEnumRef(s)
}

// flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceResetRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceResetRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceResetRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceResetRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceResetRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceResetRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceResetRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessRepairRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessRepairRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessRepairRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessRepairRecipeStepsActionEnum(i interface{}) *InstancePreprocessRepairRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessRepairRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessRepairRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceInitiateRepairRecipeStepsActionEnumSlice flattens the contents of InstanceInitiateRepairRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsActionEnum{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateRepairRecipeStepsActionEnum with the same value as that string.
func flattenInstanceInitiateRepairRecipeStepsActionEnum(i interface{}) *InstanceInitiateRepairRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateRepairRecipeStepsActionEnumRef("")
	}

	return InstanceInitiateRepairRecipeStepsActionEnumRef(s)
}

// flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceInitiateRepairRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceRepairRecipeStepsActionEnumSlice flattens the contents of InstanceRepairRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceRepairRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsActionEnum{}
	}

	items := make([]InstanceRepairRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceRepairRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceRepairRecipeStepsActionEnum with the same value as that string.
func flattenInstanceRepairRecipeStepsActionEnum(i interface{}) *InstanceRepairRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceRepairRecipeStepsActionEnumRef("")
	}

	return InstanceRepairRecipeStepsActionEnumRef(s)
}

// flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceRepairRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceRepairRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessDeleteRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessDeleteRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessDeleteRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessDeleteRecipeStepsActionEnum(i interface{}) *InstancePreprocessDeleteRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessDeleteRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessDeleteRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceInitiateDeleteRecipeStepsActionEnumSlice flattens the contents of InstanceInitiateDeleteRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsActionEnum{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateDeleteRecipeStepsActionEnum with the same value as that string.
func flattenInstanceInitiateDeleteRecipeStepsActionEnum(i interface{}) *InstanceInitiateDeleteRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateDeleteRecipeStepsActionEnumRef("")
	}

	return InstanceInitiateDeleteRecipeStepsActionEnumRef(s)
}

// flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceInitiateDeleteRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessUpdateRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessUpdateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessUpdateRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessUpdateRecipeStepsActionEnum(i interface{}) *InstancePreprocessUpdateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessUpdateRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessUpdateRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceInitiateUpdateRecipeStepsActionEnumSlice flattens the contents of InstanceInitiateUpdateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsActionEnum{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateUpdateRecipeStepsActionEnum with the same value as that string.
func flattenInstanceInitiateUpdateRecipeStepsActionEnum(i interface{}) *InstanceInitiateUpdateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateUpdateRecipeStepsActionEnumRef("")
	}

	return InstanceInitiateUpdateRecipeStepsActionEnumRef(s)
}

// flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceInitiateUpdateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessFreezeRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessFreezeRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessFreezeRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessFreezeRecipeStepsActionEnum(i interface{}) *InstancePreprocessFreezeRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessFreezeRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessFreezeRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceFreezeRecipeStepsActionEnumSlice flattens the contents of InstanceFreezeRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsActionEnum{}
	}

	items := make([]InstanceFreezeRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceFreezeRecipeStepsActionEnum with the same value as that string.
func flattenInstanceFreezeRecipeStepsActionEnum(i interface{}) *InstanceFreezeRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceFreezeRecipeStepsActionEnumRef("")
	}

	return InstanceFreezeRecipeStepsActionEnumRef(s)
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessUnfreezeRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessUnfreezeRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessUnfreezeRecipeStepsActionEnum(i interface{}) *InstancePreprocessUnfreezeRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessUnfreezeRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessUnfreezeRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceUnfreezeRecipeStepsActionEnumSlice flattens the contents of InstanceUnfreezeRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsActionEnum{}
	}

	items := make([]InstanceUnfreezeRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceUnfreezeRecipeStepsActionEnum with the same value as that string.
func flattenInstanceUnfreezeRecipeStepsActionEnum(i interface{}) *InstanceUnfreezeRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceUnfreezeRecipeStepsActionEnumRef("")
	}

	return InstanceUnfreezeRecipeStepsActionEnumRef(s)
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceReadonlyRecipeStepsActionEnumSlice flattens the contents of InstanceReadonlyRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsActionEnum{}
	}

	items := make([]InstanceReadonlyRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceReadonlyRecipeStepsActionEnum with the same value as that string.
func flattenInstanceReadonlyRecipeStepsActionEnum(i interface{}) *InstanceReadonlyRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceReadonlyRecipeStepsActionEnumRef("")
	}

	return InstanceReadonlyRecipeStepsActionEnumRef(s)
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// This function returns a matcher that checks whether a serialized resource matches this resource
// in its parameters (as defined by the fields in a Get, which definitionally define resource
// identity).  This is useful in extracting the element from a List call.
func (r *Instance) matcher(c *Client) func([]byte) bool {
	return func(b []byte) bool {
		cr, err := unmarshalInstance(b, c)
		if err != nil {
			c.Config.Logger.Warning("failed to unmarshal provided resource in matcher.")
			return false
		}
		nr := r.urlNormalized()
		ncr := cr.urlNormalized()
		c.Config.Logger.Infof("looking for %v\nin %v", nr, ncr)

		if nr.Project == nil && ncr.Project == nil {
			c.Config.Logger.Info("Both Project fields null - considering equal.")
		} else if nr.Project == nil || ncr.Project == nil {
			c.Config.Logger.Info("Only one Project field is null - considering unequal.")
			return false
		} else if *nr.Project != *ncr.Project {
			return false
		}
		if nr.Location == nil && ncr.Location == nil {
			c.Config.Logger.Info("Both Location fields null - considering equal.")
		} else if nr.Location == nil || ncr.Location == nil {
			c.Config.Logger.Info("Only one Location field is null - considering unequal.")
			return false
		} else if *nr.Location != *ncr.Location {
			return false
		}
		if nr.Name == nil && ncr.Name == nil {
			c.Config.Logger.Info("Both Name fields null - considering equal.")
		} else if nr.Name == nil || ncr.Name == nil {
			c.Config.Logger.Info("Only one Name field is null - considering unequal.")
			return false
		} else if *nr.Name != *ncr.Name {
			return false
		}
		return true
	}
}
