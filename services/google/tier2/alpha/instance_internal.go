// Copyright 2021 Google LLC. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package alpha

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"strings"
	"time"

	"github.com/GoogleCloudPlatform/declarative-resource-client-library/dcl"
	"github.com/GoogleCloudPlatform/declarative-resource-client-library/dcl/operations"
)

func (r *Instance) validate() error {

	if err := dcl.Required(r, "name"); err != nil {
		return err
	}
	if err := dcl.RequiredParameter(r.Project, "Project"); err != nil {
		return err
	}
	if err := dcl.RequiredParameter(r.Location, "Location"); err != nil {
		return err
	}
	if !dcl.IsEmptyValueIndirect(r.Sku) {
		if err := r.Sku.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessCreateRecipe) {
		if err := r.PreprocessCreateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.CreateRecipe) {
		if err := r.CreateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.DeleteRecipe) {
		if err := r.DeleteRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.UpdateRecipe) {
		if err := r.UpdateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessResetRecipe) {
		if err := r.PreprocessResetRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ResetRecipe) {
		if err := r.ResetRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessRepairRecipe) {
		if err := r.PreprocessRepairRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RepairRecipe) {
		if err := r.RepairRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessDeleteRecipe) {
		if err := r.PreprocessDeleteRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdateRecipe) {
		if err := r.PreprocessUpdateRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessFreezeRecipe) {
		if err := r.PreprocessFreezeRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.FreezeRecipe) {
		if err := r.FreezeRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUnfreezeRecipe) {
		if err := r.PreprocessUnfreezeRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.UnfreezeRecipe) {
		if err := r.UnfreezeRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessReportInstanceHealthRecipe) {
		if err := r.PreprocessReportInstanceHealthRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ReportInstanceHealthRecipe) {
		if err := r.ReportInstanceHealthRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessGetRecipe) {
		if err := r.PreprocessGetRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.NotifyKeyAvailableRecipe) {
		if err := r.NotifyKeyAvailableRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.NotifyKeyUnavailableRecipe) {
		if err := r.NotifyKeyUnavailableRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ReadonlyRecipe) {
		if err := r.ReadonlyRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ReconcileRecipe) {
		if err := r.ReconcileRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessPassthroughRecipe) {
		if err := r.PreprocessPassthroughRecipe.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessReconcileRecipe) {
		if err := r.PreprocessReconcileRecipe.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceSku) validate() error {
	return nil
}
func (r *InstanceReferences) validate() error {
	if err := dcl.Required(r, "type"); err != nil {
		return err
	}
	if err := dcl.Required(r, "sourceResource"); err != nil {
		return err
	}
	return nil
}
func (r *InstanceReferencesDetails) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceGoogleprotobufstruct) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceCreateRecipe) validate() error {
	return nil
}
func (r *InstanceCreateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceCreateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceCreateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceDeleteRecipe) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceDeleteRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceDeleteRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceUpdateRecipe) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUpdateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUpdateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessResetRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceResetRecipe) validate() error {
	return nil
}
func (r *InstanceResetRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceResetRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceResetRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceRepairRecipe) validate() error {
	return nil
}
func (r *InstanceRepairRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceRepairRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceRepairRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceFreezeRecipe) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceFreezeRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceFreezeRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipe) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUnfreezeRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipe) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessGetRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipe) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipe) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipe) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReadonlyRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceReconcileRecipe) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReconcileRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReconcileRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipe) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeSteps) validate() error {
	if !dcl.IsEmptyValueIndirect(r.Status) {
		if err := r.Status.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.PreprocessUpdate) {
		if err := r.PreprocessUpdate.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.RequestedTenantProject) {
		if err := r.RequestedTenantProject.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsUpdate) {
		if err := r.KeyNotificationsUpdate.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsStatus) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsStatusDetails) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsPreprocessUpdate) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsRequestedTenantProject) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsPermissionsInfo) validate() error {
	if !dcl.IsEmptyValueIndirect(r.PolicyName) {
		if err := r.PolicyName.validate(); err != nil {
			return err
		}
	}
	if !dcl.IsEmptyValueIndirect(r.ApiAttrs) {
		if err := r.ApiAttrs.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate) validate() error {
	if !dcl.IsEmptyValueIndirect(r.KeyNotificationsInfo) {
		if err := r.KeyNotificationsInfo.validate(); err != nil {
			return err
		}
	}
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) validate() error {
	return nil
}
func (r *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) validate() error {
	return nil
}
func (r *InstanceHistory) validate() error {
	return nil
}

func instanceGetURL(userBasePath string, r *Instance) (string, error) {
	params := map[string]interface{}{
		"project":  dcl.ValueOrEmptyString(r.Project),
		"location": dcl.ValueOrEmptyString(r.Location),
		"name":     dcl.ValueOrEmptyString(r.Name),
	}
	return dcl.URL("projects/{{project}}/locations/{{location}}/instances/{{name}}", "https://arcus2tier2.sandbox.googleapis.com/v1alpha1/", userBasePath, params), nil
}

func instanceListURL(userBasePath, project, location string) (string, error) {
	params := map[string]interface{}{
		"project":  project,
		"location": location,
	}
	return dcl.URL("projects/{{project}}/locations/{{location}}/instances", "https://arcus2tier2.sandbox.googleapis.com/v1alpha1/", userBasePath, params), nil

}

func instanceCreateURL(userBasePath, project, location, name string) (string, error) {
	params := map[string]interface{}{
		"project":  project,
		"location": location,
		"name":     name,
	}
	return dcl.URL("projects/{{project}}/locations/{{location}}/instances?instanceId={{name}}", "https://arcus2tier2.sandbox.googleapis.com/v1alpha1/", userBasePath, params), nil

}

func instanceDeleteURL(userBasePath string, r *Instance) (string, error) {
	params := map[string]interface{}{
		"project":  dcl.ValueOrEmptyString(r.Project),
		"location": dcl.ValueOrEmptyString(r.Location),
		"name":     dcl.ValueOrEmptyString(r.Name),
	}
	return dcl.URL("projects/{{project}}/locations/{{location}}/instances/{{name}}", "https://arcus2tier2.sandbox.googleapis.com/v1alpha1/", userBasePath, params), nil
}

// instanceApiOperation represents a mutable operation in the underlying REST
// API such as Create, Update, or Delete.
type instanceApiOperation interface {
	do(context.Context, *Instance, *Client) error
}

// newUpdateInstanceUpdateInstanceRequest creates a request for an
// Instance resource's UpdateInstance update type by filling in the update
// fields based on the intended state of the resource.
func newUpdateInstanceUpdateInstanceRequest(ctx context.Context, f *Instance, c *Client) (map[string]interface{}, error) {
	req := map[string]interface{}{}

	if v, err := dcl.DeriveField("projects/%s/locations/%s/instances/%s", f.Name, f.Project, f.Location, f.Name); err != nil {
		return nil, fmt.Errorf("error expanding Name into name: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["name"] = v
	}
	if v := f.DisplayName; !dcl.IsEmptyValueIndirect(v) {
		req["displayName"] = v
	}
	if v := f.Labels; !dcl.IsEmptyValueIndirect(v) {
		req["labels"] = v
	}
	if v := f.Zone; !dcl.IsEmptyValueIndirect(v) {
		req["zone"] = v
	}
	if v := f.AlternativeZone; !dcl.IsEmptyValueIndirect(v) {
		req["alternativeZone"] = v
	}
	if v, err := expandInstanceSku(c, f.Sku); err != nil {
		return nil, fmt.Errorf("error expanding Sku into sku: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["sku"] = v
	}
	if v := f.AuthorizedNetworkId; !dcl.IsEmptyValueIndirect(v) {
		req["authorizedNetworkId"] = v
	}
	if v := f.ReservedIPRange; !dcl.IsEmptyValueIndirect(v) {
		req["reservedIpRange"] = v
	}
	if v, err := expandInstanceReferencesSlice(c, f.References); err != nil {
		return nil, fmt.Errorf("error expanding References into references: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["references"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipe(c, f.PreprocessCreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessCreateRecipe into preprocessCreateRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessCreateRecipe"] = v
	}
	if v, err := expandInstanceCreateRecipe(c, f.CreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding CreateRecipe into createRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["createRecipe"] = v
	}
	if v, err := expandInstanceDeleteRecipe(c, f.DeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding DeleteRecipe into deleteRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["deleteRecipe"] = v
	}
	if v, err := expandInstanceUpdateRecipe(c, f.UpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding UpdateRecipe into updateRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["updateRecipe"] = v
	}
	if v, err := expandInstancePreprocessResetRecipe(c, f.PreprocessResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessResetRecipe into preprocessResetRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessResetRecipe"] = v
	}
	if v, err := expandInstanceResetRecipe(c, f.ResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ResetRecipe into resetRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["resetRecipe"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipe(c, f.PreprocessRepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessRepairRecipe into preprocessRepairRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessRepairRecipe"] = v
	}
	if v, err := expandInstanceRepairRecipe(c, f.RepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding RepairRecipe into repairRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["repairRecipe"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipe(c, f.PreprocessDeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessDeleteRecipe into preprocessDeleteRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessDeleteRecipe"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipe(c, f.PreprocessUpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdateRecipe into preprocessUpdateRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessUpdateRecipe"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipe(c, f.PreprocessFreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessFreezeRecipe into preprocessFreezeRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessFreezeRecipe"] = v
	}
	if v, err := expandInstanceFreezeRecipe(c, f.FreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding FreezeRecipe into freezeRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["freezeRecipe"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipe(c, f.PreprocessUnfreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUnfreezeRecipe into preprocessUnfreezeRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessUnfreezeRecipe"] = v
	}
	if v, err := expandInstanceUnfreezeRecipe(c, f.UnfreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding UnfreezeRecipe into unfreezeRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["unfreezeRecipe"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipe(c, f.PreprocessReportInstanceHealthRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessReportInstanceHealthRecipe into preprocessReportInstanceHealthRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessReportInstanceHealthRecipe"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipe(c, f.ReportInstanceHealthRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ReportInstanceHealthRecipe into reportInstanceHealthRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["reportInstanceHealthRecipe"] = v
	}
	if v, err := expandInstancePreprocessGetRecipe(c, f.PreprocessGetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessGetRecipe into preprocessGetRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessGetRecipe"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipe(c, f.NotifyKeyAvailableRecipe); err != nil {
		return nil, fmt.Errorf("error expanding NotifyKeyAvailableRecipe into notifyKeyAvailableRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["notifyKeyAvailableRecipe"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipe(c, f.NotifyKeyUnavailableRecipe); err != nil {
		return nil, fmt.Errorf("error expanding NotifyKeyUnavailableRecipe into notifyKeyUnavailableRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["notifyKeyUnavailableRecipe"] = v
	}
	if v, err := expandInstanceReadonlyRecipe(c, f.ReadonlyRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ReadonlyRecipe into readonlyRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["readonlyRecipe"] = v
	}
	if v, err := expandInstanceReconcileRecipe(c, f.ReconcileRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ReconcileRecipe into reconcileRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["reconcileRecipe"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipe(c, f.PreprocessPassthroughRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessPassthroughRecipe into preprocessPassthroughRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessPassthroughRecipe"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipe(c, f.PreprocessReconcileRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessReconcileRecipe into preprocessReconcileRecipe: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["preprocessReconcileRecipe"] = v
	}
	if v := f.EnableCallHistory; !dcl.IsEmptyValueIndirect(v) {
		req["enableCallHistory"] = v
	}
	if v, err := expandInstanceHistorySlice(c, f.History); err != nil {
		return nil, fmt.Errorf("error expanding History into history: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		req["history"] = v
	}
	if v := f.PublicResourceViewOverride; !dcl.IsEmptyValueIndirect(v) {
		req["publicResourceViewOverride"] = v
	}
	if v := f.Uid; !dcl.IsEmptyValueIndirect(v) {
		req["uid"] = v
	}
	b, err := c.getInstanceRaw(ctx, f.urlNormalized())
	if err != nil {
		return nil, err
	}
	var m map[string]interface{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	rawEtag, err := dcl.GetMapEntry(
		m,
		[]string{"etag"},
	)
	if err != nil {
		c.Config.Logger.Warningf("Failed to fetch from JSON Path: %v", err)
	} else {
		req["etag"] = rawEtag.(string)
	}
	req["name"] = fmt.Sprintf("projects/%s/locations/%s/instances/%s", *f.Project, *f.Location, *f.Name)

	return req, nil
}

// marshalUpdateInstanceUpdateInstanceRequest converts the update into
// the final JSON request body.
func marshalUpdateInstanceUpdateInstanceRequest(c *Client, m map[string]interface{}) ([]byte, error) {

	return json.Marshal(m)
}

type updateInstanceUpdateInstanceOperation struct {
	// If the update operation has the REQUIRES_APPLY_OPTIONS trait, this will be populated.
	// Usually it will be nil - this is to prevent us from accidentally depending on apply
	// options, which should usually be unnecessary.
	ApplyOptions []dcl.ApplyOption
	Diffs        []*dcl.FieldDiff
}

// do creates a request and sends it to the appropriate URL. In most operations,
// do will transcribe a subset of the resource into a request object and send a
// PUT request to a single URL.

func (op *updateInstanceUpdateInstanceOperation) do(ctx context.Context, r *Instance, c *Client) error {
	_, err := c.GetInstance(ctx, r.urlNormalized())
	if err != nil {
		return err
	}

	u, err := r.updateURL(c.Config.BasePath, "UpdateInstance")
	if err != nil {
		return err
	}
	mask := dcl.UpdateMask(op.Diffs)
	u, err = dcl.AddQueryParams(u, map[string]string{"updateMask": mask})
	if err != nil {
		return err
	}

	req, err := newUpdateInstanceUpdateInstanceRequest(ctx, r, c)
	if err != nil {
		return err
	}

	c.Config.Logger.Infof("Created update: %#v", req)
	body, err := marshalUpdateInstanceUpdateInstanceRequest(c, req)
	if err != nil {
		return err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "PATCH", u, bytes.NewBuffer(body), c.Config.RetryProvider)
	if err != nil {
		return err
	}

	var o operations.StandardGCPOperation
	if err := dcl.ParseResponse(resp.Response, &o); err != nil {
		return err
	}
	err = o.Wait(ctx, c.Config, "https://arcus2tier2.sandbox.googleapis.com/v1alpha1/", "GET")

	if err != nil {
		return err
	}

	return nil
}

func (c *Client) listInstanceRaw(ctx context.Context, project, location, pageToken string, pageSize int32) ([]byte, error) {
	u, err := instanceListURL(c.Config.BasePath, project, location)
	if err != nil {
		return nil, err
	}

	m := make(map[string]string)
	if pageToken != "" {
		m["pageToken"] = pageToken
	}

	if pageSize != InstanceMaxPage {
		m["pageSize"] = fmt.Sprintf("%v", pageSize)
	}

	u, err = dcl.AddQueryParams(u, m)
	if err != nil {
		return nil, err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "GET", u, &bytes.Buffer{}, c.Config.RetryProvider)
	if err != nil {
		return nil, err
	}
	defer resp.Response.Body.Close()
	return ioutil.ReadAll(resp.Response.Body)
}

type listInstanceOperation struct {
	Instances []map[string]interface{} `json:"instances"`
	Token     string                   `json:"nextPageToken"`
}

func (c *Client) listInstance(ctx context.Context, project, location, pageToken string, pageSize int32) ([]*Instance, string, error) {
	b, err := c.listInstanceRaw(ctx, project, location, pageToken, pageSize)
	if err != nil {
		return nil, "", err
	}

	var m listInstanceOperation
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, "", err
	}

	var l []*Instance
	for _, v := range m.Instances {
		res, err := unmarshalMapInstance(v, c)
		if err != nil {
			return nil, m.Token, err
		}
		res.Project = &project
		res.Location = &location
		l = append(l, res)
	}

	return l, m.Token, nil
}

func (c *Client) deleteAllInstance(ctx context.Context, f func(*Instance) bool, resources []*Instance) error {
	var errors []string
	for _, res := range resources {
		if f(res) {
			// We do not want deleteAll to fail on a deletion or else it will stop deleting other resources.
			err := c.DeleteInstance(ctx, res)
			if err != nil {
				errors = append(errors, err.Error())
			}
		}
	}
	if len(errors) > 0 {
		return fmt.Errorf("%v", strings.Join(errors, "\n"))
	} else {
		return nil
	}
}

type deleteInstanceOperation struct{}

func (op *deleteInstanceOperation) do(ctx context.Context, r *Instance, c *Client) error {

	_, err := c.GetInstance(ctx, r.urlNormalized())

	if err != nil {
		if dcl.IsNotFound(err) {
			c.Config.Logger.Infof("Instance not found, returning. Original error: %v", err)
			return nil
		}
		c.Config.Logger.Warningf("GetInstance checking for existence. error: %v", err)
		return err
	}

	u, err := instanceDeleteURL(c.Config.BasePath, r.urlNormalized())
	if err != nil {
		return err
	}

	// Delete should never have a body
	body := &bytes.Buffer{}
	resp, err := dcl.SendRequest(ctx, c.Config, "DELETE", u, body, c.Config.RetryProvider)
	if err != nil {
		return err
	}

	// wait for object to be deleted.
	var o operations.StandardGCPOperation
	if err := dcl.ParseResponse(resp.Response, &o); err != nil {
		return err
	}
	if err := o.Wait(ctx, c.Config, "https://arcus2tier2.sandbox.googleapis.com/v1alpha1/", "GET"); err != nil {
		return err
	}

	// we saw a race condition where for some successful delete operation, the Get calls returned resources for a short duration.
	// this is the reason we are adding retry to handle that case.
	maxRetry := 10
	for i := 1; i <= maxRetry; i++ {
		_, err = c.GetInstance(ctx, r.urlNormalized())
		if !dcl.IsNotFound(err) {
			if i == maxRetry {
				return dcl.NotDeletedError{ExistingResource: r}
			}
			time.Sleep(1000 * time.Millisecond)
		} else {
			break
		}
	}
	return nil
}

// Create operations are similar to Update operations, although they do not have
// specific request objects. The Create request object is the json encoding of
// the resource, which is modified by res.marshal to form the base request body.
type createInstanceOperation struct {
	response map[string]interface{}
}

func (op *createInstanceOperation) FirstResponse() (map[string]interface{}, bool) {
	return op.response, len(op.response) > 0
}

func (op *createInstanceOperation) do(ctx context.Context, r *Instance, c *Client) error {
	c.Config.Logger.Infof("Attempting to create %v", r)

	project, location, name := r.createFields()
	u, err := instanceCreateURL(c.Config.BasePath, project, location, name)

	if err != nil {
		return err
	}

	req, err := r.marshal(c)
	if err != nil {
		return err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "POST", u, bytes.NewBuffer(req), c.Config.RetryProvider)
	if err != nil {
		return err
	}
	// wait for object to be created.
	var o operations.StandardGCPOperation
	if err := dcl.ParseResponse(resp.Response, &o); err != nil {
		return err
	}
	if err := o.Wait(ctx, c.Config, "https://arcus2tier2.sandbox.googleapis.com/v1alpha1/", "GET"); err != nil {
		c.Config.Logger.Warningf("Creation failed after waiting for operation: %v", err)
		return err
	}
	c.Config.Logger.Infof("Successfully waited for operation")
	op.response, _ = o.FirstResponse()

	if _, err := c.GetInstance(ctx, r.urlNormalized()); err != nil {
		c.Config.Logger.Warningf("get returned error: %v", err)
		return err
	}

	return nil
}

func (c *Client) getInstanceRaw(ctx context.Context, r *Instance) ([]byte, error) {

	u, err := instanceGetURL(c.Config.BasePath, r.urlNormalized())
	if err != nil {
		return nil, err
	}
	resp, err := dcl.SendRequest(ctx, c.Config, "GET", u, &bytes.Buffer{}, c.Config.RetryProvider)
	if err != nil {
		return nil, err
	}
	defer resp.Response.Body.Close()
	b, err := ioutil.ReadAll(resp.Response.Body)
	if err != nil {
		return nil, err
	}

	return b, nil
}

func (c *Client) instanceDiffsForRawDesired(ctx context.Context, rawDesired *Instance, opts ...dcl.ApplyOption) (initial, desired *Instance, diffs []*dcl.FieldDiff, err error) {
	c.Config.Logger.Info("Fetching initial state...")
	// First, let us see if the user provided a state hint.  If they did, we will start fetching based on that.
	var fetchState *Instance
	if sh := dcl.FetchStateHint(opts); sh != nil {
		if r, ok := sh.(*Instance); !ok {
			c.Config.Logger.Warningf("Initial state hint was of the wrong type; expected Instance, got %T", sh)
		} else {
			fetchState = r
		}
	}
	if fetchState == nil {
		fetchState = rawDesired
	}

	// 1.2: Retrieval of raw initial state from API
	rawInitial, err := c.GetInstance(ctx, fetchState.urlNormalized())
	if rawInitial == nil {
		if !dcl.IsNotFound(err) {
			c.Config.Logger.Warningf("Failed to retrieve whether a Instance resource already exists: %s", err)
			return nil, nil, nil, fmt.Errorf("failed to retrieve Instance resource: %v", err)
		}
		c.Config.Logger.Info("Found that Instance resource did not exist.")
		// Perform canonicalization to pick up defaults.
		desired, err = canonicalizeInstanceDesiredState(rawDesired, rawInitial)
		return nil, desired, nil, err
	}

	c.Config.Logger.Infof("Found initial state for Instance: %v", rawInitial)
	c.Config.Logger.Infof("Initial desired state for Instance: %v", rawDesired)

	// 1.3: Canonicalize raw initial state into initial state.
	initial, err = canonicalizeInstanceInitialState(rawInitial, rawDesired)
	if err != nil {
		return nil, nil, nil, err
	}
	c.Config.Logger.Infof("Canonicalized initial state for Instance: %v", initial)

	// 1.4: Canonicalize raw desired state into desired state.
	desired, err = canonicalizeInstanceDesiredState(rawDesired, rawInitial, opts...)
	if err != nil {
		return nil, nil, nil, err
	}
	c.Config.Logger.Infof("Canonicalized desired state for Instance: %v", desired)

	// 2.1: Comparison of initial and desired state.
	diffs, err = diffInstance(c, desired, initial, opts...)
	return initial, desired, diffs, err
}

func canonicalizeInstanceInitialState(rawInitial, rawDesired *Instance) (*Instance, error) {
	// TODO(magic-modules-eng): write canonicalizer once relevant traits are added.
	return rawInitial, nil
}

/*
* Canonicalizers
*
* These are responsible for converting either a user-specified config or a
* GCP API response to a standard format that can be used for difference checking.
* */

func canonicalizeInstanceDesiredState(rawDesired, rawInitial *Instance, opts ...dcl.ApplyOption) (*Instance, error) {

	if rawInitial == nil {
		// Since the initial state is empty, the desired state is all we have.
		// We canonicalize the remaining nested objects with nil to pick up defaults.
		rawDesired.Sku = canonicalizeInstanceSku(rawDesired.Sku, nil, opts...)
		rawDesired.PreprocessCreateRecipe = canonicalizeInstancePreprocessCreateRecipe(rawDesired.PreprocessCreateRecipe, nil, opts...)
		rawDesired.CreateRecipe = canonicalizeInstanceCreateRecipe(rawDesired.CreateRecipe, nil, opts...)
		rawDesired.DeleteRecipe = canonicalizeInstanceDeleteRecipe(rawDesired.DeleteRecipe, nil, opts...)
		rawDesired.UpdateRecipe = canonicalizeInstanceUpdateRecipe(rawDesired.UpdateRecipe, nil, opts...)
		rawDesired.PreprocessResetRecipe = canonicalizeInstancePreprocessResetRecipe(rawDesired.PreprocessResetRecipe, nil, opts...)
		rawDesired.ResetRecipe = canonicalizeInstanceResetRecipe(rawDesired.ResetRecipe, nil, opts...)
		rawDesired.PreprocessRepairRecipe = canonicalizeInstancePreprocessRepairRecipe(rawDesired.PreprocessRepairRecipe, nil, opts...)
		rawDesired.RepairRecipe = canonicalizeInstanceRepairRecipe(rawDesired.RepairRecipe, nil, opts...)
		rawDesired.PreprocessDeleteRecipe = canonicalizeInstancePreprocessDeleteRecipe(rawDesired.PreprocessDeleteRecipe, nil, opts...)
		rawDesired.PreprocessUpdateRecipe = canonicalizeInstancePreprocessUpdateRecipe(rawDesired.PreprocessUpdateRecipe, nil, opts...)
		rawDesired.PreprocessFreezeRecipe = canonicalizeInstancePreprocessFreezeRecipe(rawDesired.PreprocessFreezeRecipe, nil, opts...)
		rawDesired.FreezeRecipe = canonicalizeInstanceFreezeRecipe(rawDesired.FreezeRecipe, nil, opts...)
		rawDesired.PreprocessUnfreezeRecipe = canonicalizeInstancePreprocessUnfreezeRecipe(rawDesired.PreprocessUnfreezeRecipe, nil, opts...)
		rawDesired.UnfreezeRecipe = canonicalizeInstanceUnfreezeRecipe(rawDesired.UnfreezeRecipe, nil, opts...)
		rawDesired.PreprocessReportInstanceHealthRecipe = canonicalizeInstancePreprocessReportInstanceHealthRecipe(rawDesired.PreprocessReportInstanceHealthRecipe, nil, opts...)
		rawDesired.ReportInstanceHealthRecipe = canonicalizeInstanceReportInstanceHealthRecipe(rawDesired.ReportInstanceHealthRecipe, nil, opts...)
		rawDesired.PreprocessGetRecipe = canonicalizeInstancePreprocessGetRecipe(rawDesired.PreprocessGetRecipe, nil, opts...)
		rawDesired.NotifyKeyAvailableRecipe = canonicalizeInstanceNotifyKeyAvailableRecipe(rawDesired.NotifyKeyAvailableRecipe, nil, opts...)
		rawDesired.NotifyKeyUnavailableRecipe = canonicalizeInstanceNotifyKeyUnavailableRecipe(rawDesired.NotifyKeyUnavailableRecipe, nil, opts...)
		rawDesired.ReadonlyRecipe = canonicalizeInstanceReadonlyRecipe(rawDesired.ReadonlyRecipe, nil, opts...)
		rawDesired.ReconcileRecipe = canonicalizeInstanceReconcileRecipe(rawDesired.ReconcileRecipe, nil, opts...)
		rawDesired.PreprocessPassthroughRecipe = canonicalizeInstancePreprocessPassthroughRecipe(rawDesired.PreprocessPassthroughRecipe, nil, opts...)
		rawDesired.PreprocessReconcileRecipe = canonicalizeInstancePreprocessReconcileRecipe(rawDesired.PreprocessReconcileRecipe, nil, opts...)

		return rawDesired, nil
	}

	if dcl.PartialSelfLinkToSelfLink(rawDesired.Name, rawInitial.Name) {
		rawDesired.Name = rawInitial.Name
	}
	if dcl.StringCanonicalize(rawDesired.DisplayName, rawInitial.DisplayName) {
		rawDesired.DisplayName = rawInitial.DisplayName
	}
	if dcl.IsZeroValue(rawDesired.Labels) {
		rawDesired.Labels = rawInitial.Labels
	}
	if dcl.StringCanonicalize(rawDesired.Zone, rawInitial.Zone) {
		rawDesired.Zone = rawInitial.Zone
	}
	if dcl.StringCanonicalize(rawDesired.AlternativeZone, rawInitial.AlternativeZone) {
		rawDesired.AlternativeZone = rawInitial.AlternativeZone
	}
	rawDesired.Sku = canonicalizeInstanceSku(rawDesired.Sku, rawInitial.Sku, opts...)
	if dcl.StringCanonicalize(rawDesired.AuthorizedNetworkId, rawInitial.AuthorizedNetworkId) {
		rawDesired.AuthorizedNetworkId = rawInitial.AuthorizedNetworkId
	}
	if dcl.StringCanonicalize(rawDesired.ReservedIPRange, rawInitial.ReservedIPRange) {
		rawDesired.ReservedIPRange = rawInitial.ReservedIPRange
	}
	if dcl.IsZeroValue(rawDesired.References) {
		rawDesired.References = rawInitial.References
	}
	rawDesired.PreprocessCreateRecipe = canonicalizeInstancePreprocessCreateRecipe(rawDesired.PreprocessCreateRecipe, rawInitial.PreprocessCreateRecipe, opts...)
	rawDesired.CreateRecipe = canonicalizeInstanceCreateRecipe(rawDesired.CreateRecipe, rawInitial.CreateRecipe, opts...)
	rawDesired.DeleteRecipe = canonicalizeInstanceDeleteRecipe(rawDesired.DeleteRecipe, rawInitial.DeleteRecipe, opts...)
	rawDesired.UpdateRecipe = canonicalizeInstanceUpdateRecipe(rawDesired.UpdateRecipe, rawInitial.UpdateRecipe, opts...)
	rawDesired.PreprocessResetRecipe = canonicalizeInstancePreprocessResetRecipe(rawDesired.PreprocessResetRecipe, rawInitial.PreprocessResetRecipe, opts...)
	rawDesired.ResetRecipe = canonicalizeInstanceResetRecipe(rawDesired.ResetRecipe, rawInitial.ResetRecipe, opts...)
	rawDesired.PreprocessRepairRecipe = canonicalizeInstancePreprocessRepairRecipe(rawDesired.PreprocessRepairRecipe, rawInitial.PreprocessRepairRecipe, opts...)
	rawDesired.RepairRecipe = canonicalizeInstanceRepairRecipe(rawDesired.RepairRecipe, rawInitial.RepairRecipe, opts...)
	rawDesired.PreprocessDeleteRecipe = canonicalizeInstancePreprocessDeleteRecipe(rawDesired.PreprocessDeleteRecipe, rawInitial.PreprocessDeleteRecipe, opts...)
	rawDesired.PreprocessUpdateRecipe = canonicalizeInstancePreprocessUpdateRecipe(rawDesired.PreprocessUpdateRecipe, rawInitial.PreprocessUpdateRecipe, opts...)
	rawDesired.PreprocessFreezeRecipe = canonicalizeInstancePreprocessFreezeRecipe(rawDesired.PreprocessFreezeRecipe, rawInitial.PreprocessFreezeRecipe, opts...)
	rawDesired.FreezeRecipe = canonicalizeInstanceFreezeRecipe(rawDesired.FreezeRecipe, rawInitial.FreezeRecipe, opts...)
	rawDesired.PreprocessUnfreezeRecipe = canonicalizeInstancePreprocessUnfreezeRecipe(rawDesired.PreprocessUnfreezeRecipe, rawInitial.PreprocessUnfreezeRecipe, opts...)
	rawDesired.UnfreezeRecipe = canonicalizeInstanceUnfreezeRecipe(rawDesired.UnfreezeRecipe, rawInitial.UnfreezeRecipe, opts...)
	rawDesired.PreprocessReportInstanceHealthRecipe = canonicalizeInstancePreprocessReportInstanceHealthRecipe(rawDesired.PreprocessReportInstanceHealthRecipe, rawInitial.PreprocessReportInstanceHealthRecipe, opts...)
	rawDesired.ReportInstanceHealthRecipe = canonicalizeInstanceReportInstanceHealthRecipe(rawDesired.ReportInstanceHealthRecipe, rawInitial.ReportInstanceHealthRecipe, opts...)
	rawDesired.PreprocessGetRecipe = canonicalizeInstancePreprocessGetRecipe(rawDesired.PreprocessGetRecipe, rawInitial.PreprocessGetRecipe, opts...)
	rawDesired.NotifyKeyAvailableRecipe = canonicalizeInstanceNotifyKeyAvailableRecipe(rawDesired.NotifyKeyAvailableRecipe, rawInitial.NotifyKeyAvailableRecipe, opts...)
	rawDesired.NotifyKeyUnavailableRecipe = canonicalizeInstanceNotifyKeyUnavailableRecipe(rawDesired.NotifyKeyUnavailableRecipe, rawInitial.NotifyKeyUnavailableRecipe, opts...)
	rawDesired.ReadonlyRecipe = canonicalizeInstanceReadonlyRecipe(rawDesired.ReadonlyRecipe, rawInitial.ReadonlyRecipe, opts...)
	rawDesired.ReconcileRecipe = canonicalizeInstanceReconcileRecipe(rawDesired.ReconcileRecipe, rawInitial.ReconcileRecipe, opts...)
	rawDesired.PreprocessPassthroughRecipe = canonicalizeInstancePreprocessPassthroughRecipe(rawDesired.PreprocessPassthroughRecipe, rawInitial.PreprocessPassthroughRecipe, opts...)
	rawDesired.PreprocessReconcileRecipe = canonicalizeInstancePreprocessReconcileRecipe(rawDesired.PreprocessReconcileRecipe, rawInitial.PreprocessReconcileRecipe, opts...)
	if dcl.BoolCanonicalize(rawDesired.EnableCallHistory, rawInitial.EnableCallHistory) {
		rawDesired.EnableCallHistory = rawInitial.EnableCallHistory
	}
	if dcl.IsZeroValue(rawDesired.History) {
		rawDesired.History = rawInitial.History
	}
	if dcl.StringCanonicalize(rawDesired.PublicResourceViewOverride, rawInitial.PublicResourceViewOverride) {
		rawDesired.PublicResourceViewOverride = rawInitial.PublicResourceViewOverride
	}
	if dcl.StringCanonicalize(rawDesired.Uid, rawInitial.Uid) {
		rawDesired.Uid = rawInitial.Uid
	}
	if dcl.NameToSelfLink(rawDesired.Project, rawInitial.Project) {
		rawDesired.Project = rawInitial.Project
	}
	if dcl.NameToSelfLink(rawDesired.Location, rawInitial.Location) {
		rawDesired.Location = rawInitial.Location
	}

	return rawDesired, nil
}

func canonicalizeInstanceNewState(c *Client, rawNew, rawDesired *Instance) (*Instance, error) {

	if dcl.IsEmptyValueIndirect(rawNew.Name) && dcl.IsEmptyValueIndirect(rawDesired.Name) {
		rawNew.Name = rawDesired.Name
	} else {
		if dcl.PartialSelfLinkToSelfLink(rawDesired.Name, rawNew.Name) {
			rawNew.Name = rawDesired.Name
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.DisplayName) && dcl.IsEmptyValueIndirect(rawDesired.DisplayName) {
		rawNew.DisplayName = rawDesired.DisplayName
	} else {
		if dcl.StringCanonicalize(rawDesired.DisplayName, rawNew.DisplayName) {
			rawNew.DisplayName = rawDesired.DisplayName
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.Labels) && dcl.IsEmptyValueIndirect(rawDesired.Labels) {
		rawNew.Labels = rawDesired.Labels
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.Zone) && dcl.IsEmptyValueIndirect(rawDesired.Zone) {
		rawNew.Zone = rawDesired.Zone
	} else {
		if dcl.StringCanonicalize(rawDesired.Zone, rawNew.Zone) {
			rawNew.Zone = rawDesired.Zone
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.AlternativeZone) && dcl.IsEmptyValueIndirect(rawDesired.AlternativeZone) {
		rawNew.AlternativeZone = rawDesired.AlternativeZone
	} else {
		if dcl.StringCanonicalize(rawDesired.AlternativeZone, rawNew.AlternativeZone) {
			rawNew.AlternativeZone = rawDesired.AlternativeZone
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.Sku) && dcl.IsEmptyValueIndirect(rawDesired.Sku) {
		rawNew.Sku = rawDesired.Sku
	} else {
		rawNew.Sku = canonicalizeNewInstanceSku(c, rawDesired.Sku, rawNew.Sku)
	}

	if dcl.IsEmptyValueIndirect(rawNew.AuthorizedNetworkId) && dcl.IsEmptyValueIndirect(rawDesired.AuthorizedNetworkId) {
		rawNew.AuthorizedNetworkId = rawDesired.AuthorizedNetworkId
	} else {
		if dcl.StringCanonicalize(rawDesired.AuthorizedNetworkId, rawNew.AuthorizedNetworkId) {
			rawNew.AuthorizedNetworkId = rawDesired.AuthorizedNetworkId
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.ReservedIPRange) && dcl.IsEmptyValueIndirect(rawDesired.ReservedIPRange) {
		rawNew.ReservedIPRange = rawDesired.ReservedIPRange
	} else {
		if dcl.StringCanonicalize(rawDesired.ReservedIPRange, rawNew.ReservedIPRange) {
			rawNew.ReservedIPRange = rawDesired.ReservedIPRange
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.Host) && dcl.IsEmptyValueIndirect(rawDesired.Host) {
		rawNew.Host = rawDesired.Host
	} else {
		if dcl.StringCanonicalize(rawDesired.Host, rawNew.Host) {
			rawNew.Host = rawDesired.Host
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.Port) && dcl.IsEmptyValueIndirect(rawDesired.Port) {
		rawNew.Port = rawDesired.Port
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.CurrentZone) && dcl.IsEmptyValueIndirect(rawDesired.CurrentZone) {
		rawNew.CurrentZone = rawDesired.CurrentZone
	} else {
		if dcl.StringCanonicalize(rawDesired.CurrentZone, rawNew.CurrentZone) {
			rawNew.CurrentZone = rawDesired.CurrentZone
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.CreateTime) && dcl.IsEmptyValueIndirect(rawDesired.CreateTime) {
		rawNew.CreateTime = rawDesired.CreateTime
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.State) && dcl.IsEmptyValueIndirect(rawDesired.State) {
		rawNew.State = rawDesired.State
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.StatusMessage) && dcl.IsEmptyValueIndirect(rawDesired.StatusMessage) {
		rawNew.StatusMessage = rawDesired.StatusMessage
	} else {
		if dcl.StringCanonicalize(rawDesired.StatusMessage, rawNew.StatusMessage) {
			rawNew.StatusMessage = rawDesired.StatusMessage
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.UpdateTime) && dcl.IsEmptyValueIndirect(rawDesired.UpdateTime) {
		rawNew.UpdateTime = rawDesired.UpdateTime
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.MutateUserId) && dcl.IsEmptyValueIndirect(rawDesired.MutateUserId) {
		rawNew.MutateUserId = rawDesired.MutateUserId
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.ReadUserId) && dcl.IsEmptyValueIndirect(rawDesired.ReadUserId) {
		rawNew.ReadUserId = rawDesired.ReadUserId
	} else {
	}

	if dcl.IsEmptyValueIndirect(rawNew.References) && dcl.IsEmptyValueIndirect(rawDesired.References) {
		rawNew.References = rawDesired.References
	} else {
		rawNew.References = canonicalizeNewInstanceReferencesSlice(c, rawDesired.References, rawNew.References)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessCreateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessCreateRecipe) {
		rawNew.PreprocessCreateRecipe = rawDesired.PreprocessCreateRecipe
	} else {
		rawNew.PreprocessCreateRecipe = canonicalizeNewInstancePreprocessCreateRecipe(c, rawDesired.PreprocessCreateRecipe, rawNew.PreprocessCreateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.CreateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.CreateRecipe) {
		rawNew.CreateRecipe = rawDesired.CreateRecipe
	} else {
		rawNew.CreateRecipe = canonicalizeNewInstanceCreateRecipe(c, rawDesired.CreateRecipe, rawNew.CreateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.DeleteRecipe) && dcl.IsEmptyValueIndirect(rawDesired.DeleteRecipe) {
		rawNew.DeleteRecipe = rawDesired.DeleteRecipe
	} else {
		rawNew.DeleteRecipe = canonicalizeNewInstanceDeleteRecipe(c, rawDesired.DeleteRecipe, rawNew.DeleteRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.UpdateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.UpdateRecipe) {
		rawNew.UpdateRecipe = rawDesired.UpdateRecipe
	} else {
		rawNew.UpdateRecipe = canonicalizeNewInstanceUpdateRecipe(c, rawDesired.UpdateRecipe, rawNew.UpdateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessResetRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessResetRecipe) {
		rawNew.PreprocessResetRecipe = rawDesired.PreprocessResetRecipe
	} else {
		rawNew.PreprocessResetRecipe = canonicalizeNewInstancePreprocessResetRecipe(c, rawDesired.PreprocessResetRecipe, rawNew.PreprocessResetRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.ResetRecipe) && dcl.IsEmptyValueIndirect(rawDesired.ResetRecipe) {
		rawNew.ResetRecipe = rawDesired.ResetRecipe
	} else {
		rawNew.ResetRecipe = canonicalizeNewInstanceResetRecipe(c, rawDesired.ResetRecipe, rawNew.ResetRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessRepairRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessRepairRecipe) {
		rawNew.PreprocessRepairRecipe = rawDesired.PreprocessRepairRecipe
	} else {
		rawNew.PreprocessRepairRecipe = canonicalizeNewInstancePreprocessRepairRecipe(c, rawDesired.PreprocessRepairRecipe, rawNew.PreprocessRepairRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.RepairRecipe) && dcl.IsEmptyValueIndirect(rawDesired.RepairRecipe) {
		rawNew.RepairRecipe = rawDesired.RepairRecipe
	} else {
		rawNew.RepairRecipe = canonicalizeNewInstanceRepairRecipe(c, rawDesired.RepairRecipe, rawNew.RepairRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessDeleteRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessDeleteRecipe) {
		rawNew.PreprocessDeleteRecipe = rawDesired.PreprocessDeleteRecipe
	} else {
		rawNew.PreprocessDeleteRecipe = canonicalizeNewInstancePreprocessDeleteRecipe(c, rawDesired.PreprocessDeleteRecipe, rawNew.PreprocessDeleteRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessUpdateRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessUpdateRecipe) {
		rawNew.PreprocessUpdateRecipe = rawDesired.PreprocessUpdateRecipe
	} else {
		rawNew.PreprocessUpdateRecipe = canonicalizeNewInstancePreprocessUpdateRecipe(c, rawDesired.PreprocessUpdateRecipe, rawNew.PreprocessUpdateRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessFreezeRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessFreezeRecipe) {
		rawNew.PreprocessFreezeRecipe = rawDesired.PreprocessFreezeRecipe
	} else {
		rawNew.PreprocessFreezeRecipe = canonicalizeNewInstancePreprocessFreezeRecipe(c, rawDesired.PreprocessFreezeRecipe, rawNew.PreprocessFreezeRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.FreezeRecipe) && dcl.IsEmptyValueIndirect(rawDesired.FreezeRecipe) {
		rawNew.FreezeRecipe = rawDesired.FreezeRecipe
	} else {
		rawNew.FreezeRecipe = canonicalizeNewInstanceFreezeRecipe(c, rawDesired.FreezeRecipe, rawNew.FreezeRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessUnfreezeRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessUnfreezeRecipe) {
		rawNew.PreprocessUnfreezeRecipe = rawDesired.PreprocessUnfreezeRecipe
	} else {
		rawNew.PreprocessUnfreezeRecipe = canonicalizeNewInstancePreprocessUnfreezeRecipe(c, rawDesired.PreprocessUnfreezeRecipe, rawNew.PreprocessUnfreezeRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.UnfreezeRecipe) && dcl.IsEmptyValueIndirect(rawDesired.UnfreezeRecipe) {
		rawNew.UnfreezeRecipe = rawDesired.UnfreezeRecipe
	} else {
		rawNew.UnfreezeRecipe = canonicalizeNewInstanceUnfreezeRecipe(c, rawDesired.UnfreezeRecipe, rawNew.UnfreezeRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessReportInstanceHealthRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessReportInstanceHealthRecipe) {
		rawNew.PreprocessReportInstanceHealthRecipe = rawDesired.PreprocessReportInstanceHealthRecipe
	} else {
		rawNew.PreprocessReportInstanceHealthRecipe = canonicalizeNewInstancePreprocessReportInstanceHealthRecipe(c, rawDesired.PreprocessReportInstanceHealthRecipe, rawNew.PreprocessReportInstanceHealthRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.ReportInstanceHealthRecipe) && dcl.IsEmptyValueIndirect(rawDesired.ReportInstanceHealthRecipe) {
		rawNew.ReportInstanceHealthRecipe = rawDesired.ReportInstanceHealthRecipe
	} else {
		rawNew.ReportInstanceHealthRecipe = canonicalizeNewInstanceReportInstanceHealthRecipe(c, rawDesired.ReportInstanceHealthRecipe, rawNew.ReportInstanceHealthRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessGetRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessGetRecipe) {
		rawNew.PreprocessGetRecipe = rawDesired.PreprocessGetRecipe
	} else {
		rawNew.PreprocessGetRecipe = canonicalizeNewInstancePreprocessGetRecipe(c, rawDesired.PreprocessGetRecipe, rawNew.PreprocessGetRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.NotifyKeyAvailableRecipe) && dcl.IsEmptyValueIndirect(rawDesired.NotifyKeyAvailableRecipe) {
		rawNew.NotifyKeyAvailableRecipe = rawDesired.NotifyKeyAvailableRecipe
	} else {
		rawNew.NotifyKeyAvailableRecipe = canonicalizeNewInstanceNotifyKeyAvailableRecipe(c, rawDesired.NotifyKeyAvailableRecipe, rawNew.NotifyKeyAvailableRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.NotifyKeyUnavailableRecipe) && dcl.IsEmptyValueIndirect(rawDesired.NotifyKeyUnavailableRecipe) {
		rawNew.NotifyKeyUnavailableRecipe = rawDesired.NotifyKeyUnavailableRecipe
	} else {
		rawNew.NotifyKeyUnavailableRecipe = canonicalizeNewInstanceNotifyKeyUnavailableRecipe(c, rawDesired.NotifyKeyUnavailableRecipe, rawNew.NotifyKeyUnavailableRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.ReadonlyRecipe) && dcl.IsEmptyValueIndirect(rawDesired.ReadonlyRecipe) {
		rawNew.ReadonlyRecipe = rawDesired.ReadonlyRecipe
	} else {
		rawNew.ReadonlyRecipe = canonicalizeNewInstanceReadonlyRecipe(c, rawDesired.ReadonlyRecipe, rawNew.ReadonlyRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.ReconcileRecipe) && dcl.IsEmptyValueIndirect(rawDesired.ReconcileRecipe) {
		rawNew.ReconcileRecipe = rawDesired.ReconcileRecipe
	} else {
		rawNew.ReconcileRecipe = canonicalizeNewInstanceReconcileRecipe(c, rawDesired.ReconcileRecipe, rawNew.ReconcileRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessPassthroughRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessPassthroughRecipe) {
		rawNew.PreprocessPassthroughRecipe = rawDesired.PreprocessPassthroughRecipe
	} else {
		rawNew.PreprocessPassthroughRecipe = canonicalizeNewInstancePreprocessPassthroughRecipe(c, rawDesired.PreprocessPassthroughRecipe, rawNew.PreprocessPassthroughRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PreprocessReconcileRecipe) && dcl.IsEmptyValueIndirect(rawDesired.PreprocessReconcileRecipe) {
		rawNew.PreprocessReconcileRecipe = rawDesired.PreprocessReconcileRecipe
	} else {
		rawNew.PreprocessReconcileRecipe = canonicalizeNewInstancePreprocessReconcileRecipe(c, rawDesired.PreprocessReconcileRecipe, rawNew.PreprocessReconcileRecipe)
	}

	if dcl.IsEmptyValueIndirect(rawNew.EnableCallHistory) && dcl.IsEmptyValueIndirect(rawDesired.EnableCallHistory) {
		rawNew.EnableCallHistory = rawDesired.EnableCallHistory
	} else {
		if dcl.BoolCanonicalize(rawDesired.EnableCallHistory, rawNew.EnableCallHistory) {
			rawNew.EnableCallHistory = rawDesired.EnableCallHistory
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.History) && dcl.IsEmptyValueIndirect(rawDesired.History) {
		rawNew.History = rawDesired.History
	} else {
		rawNew.History = canonicalizeNewInstanceHistorySlice(c, rawDesired.History, rawNew.History)
	}

	if dcl.IsEmptyValueIndirect(rawNew.PublicResourceViewOverride) && dcl.IsEmptyValueIndirect(rawDesired.PublicResourceViewOverride) {
		rawNew.PublicResourceViewOverride = rawDesired.PublicResourceViewOverride
	} else {
		if dcl.StringCanonicalize(rawDesired.PublicResourceViewOverride, rawNew.PublicResourceViewOverride) {
			rawNew.PublicResourceViewOverride = rawDesired.PublicResourceViewOverride
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.ExtraInfo) && dcl.IsEmptyValueIndirect(rawDesired.ExtraInfo) {
		rawNew.ExtraInfo = rawDesired.ExtraInfo
	} else {
		if dcl.StringCanonicalize(rawDesired.ExtraInfo, rawNew.ExtraInfo) {
			rawNew.ExtraInfo = rawDesired.ExtraInfo
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.Uid) && dcl.IsEmptyValueIndirect(rawDesired.Uid) {
		rawNew.Uid = rawDesired.Uid
	} else {
		if dcl.StringCanonicalize(rawDesired.Uid, rawNew.Uid) {
			rawNew.Uid = rawDesired.Uid
		}
	}

	if dcl.IsEmptyValueIndirect(rawNew.Etag) && dcl.IsEmptyValueIndirect(rawDesired.Etag) {
		rawNew.Etag = rawDesired.Etag
	} else {
		if dcl.StringCanonicalize(rawDesired.Etag, rawNew.Etag) {
			rawNew.Etag = rawDesired.Etag
		}
	}

	rawNew.Project = rawDesired.Project

	rawNew.Location = rawDesired.Location

	return rawNew, nil
}

func canonicalizeInstanceSku(des, initial *InstanceSku, opts ...dcl.ApplyOption) *InstanceSku {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Tier) {
		des.Tier = initial.Tier
	}
	if dcl.IsZeroValue(des.Size) {
		des.Size = initial.Size
	}

	return des
}

func canonicalizeNewInstanceSku(c *Client, des, nw *InstanceSku) *InstanceSku {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Tier) {
		nw.Tier = des.Tier
	}
	if dcl.IsZeroValue(nw.Size) {
		nw.Size = des.Size
	}

	return nw
}

func canonicalizeNewInstanceSkuSet(c *Client, des, nw []InstanceSku) []InstanceSku {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceSku
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceSkuNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceSkuSlice(c *Client, des, nw []InstanceSku) []InstanceSku {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceSku
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceSku(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReferences(des, initial *InstanceReferences, opts ...dcl.ApplyOption) *InstanceReferences {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.SourceResource, initial.SourceResource) || dcl.IsZeroValue(des.SourceResource) {
		des.SourceResource = initial.SourceResource
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceReferences(c *Client, des, nw *InstanceReferences) *InstanceReferences {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Name) {
		nw.Name = des.Name
	}
	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.SourceResource, nw.SourceResource) {
		nw.SourceResource = des.SourceResource
	}
	nw.Details = canonicalizeNewInstanceReferencesDetailsSlice(c, des.Details, nw.Details)
	if dcl.IsZeroValue(nw.CreateTime) {
		nw.CreateTime = des.CreateTime
	}

	return nw
}

func canonicalizeNewInstanceReferencesSet(c *Client, des, nw []InstanceReferences) []InstanceReferences {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReferences
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReferencesNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReferencesSlice(c *Client, des, nw []InstanceReferences) []InstanceReferences {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReferences
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReferences(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReferencesDetails(des, initial *InstanceReferencesDetails, opts ...dcl.ApplyOption) *InstanceReferencesDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceReferencesDetails(c *Client, des, nw *InstanceReferencesDetails) *InstanceReferencesDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceReferencesDetailsSet(c *Client, des, nw []InstanceReferencesDetails) []InstanceReferencesDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReferencesDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReferencesDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReferencesDetailsSlice(c *Client, des, nw []InstanceReferencesDetails) []InstanceReferencesDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReferencesDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReferencesDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipe(des, initial *InstancePreprocessCreateRecipe, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipe(c *Client, des, nw *InstancePreprocessCreateRecipe) *InstancePreprocessCreateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessCreateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeSet(c *Client, des, nw []InstancePreprocessCreateRecipe) []InstancePreprocessCreateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeSlice(c *Client, des, nw []InstancePreprocessCreateRecipe) []InstancePreprocessCreateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeSteps(des, initial *InstancePreprocessCreateRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessCreateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessCreateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessCreateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeSteps(c *Client, des, nw *InstancePreprocessCreateRecipeSteps) *InstancePreprocessCreateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessCreateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsSet(c *Client, des, nw []InstancePreprocessCreateRecipeSteps) []InstancePreprocessCreateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeSteps) []InstancePreprocessCreateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsStatus(des, initial *InstancePreprocessCreateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatus(c *Client, des, nw *InstancePreprocessCreateRecipeStepsStatus) *InstancePreprocessCreateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsStatus) []InstancePreprocessCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsStatus) []InstancePreprocessCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsStatusDetails(des, initial *InstancePreprocessCreateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessCreateRecipeStepsStatusDetails) *InstancePreprocessCreateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsStatusDetails) []InstancePreprocessCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsStatusDetails) []InstancePreprocessCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessCreateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPreprocessUpdate) *InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPreprocessUpdate) []InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPreprocessUpdate) []InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessCreateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessCreateRecipeStepsRequestedTenantProject) *InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsRequestedTenantProject) []InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsRequestedTenantProject) []InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfo(des, initial *InstancePreprocessCreateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPermissionsInfo) *InstancePreprocessCreateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfo) []InstancePreprocessCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfo) []InstancePreprocessCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceGoogleprotobufstruct(des, initial *InstanceGoogleprotobufstruct, opts ...dcl.ApplyOption) *InstanceGoogleprotobufstruct {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	return des
}

func canonicalizeNewInstanceGoogleprotobufstruct(c *Client, des, nw *InstanceGoogleprotobufstruct) *InstanceGoogleprotobufstruct {
	if des == nil || nw == nil {
		return nw
	}

	return nw
}

func canonicalizeNewInstanceGoogleprotobufstructSet(c *Client, des, nw []InstanceGoogleprotobufstruct) []InstanceGoogleprotobufstruct {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceGoogleprotobufstruct
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceGoogleprotobufstructNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceGoogleprotobufstructSlice(c *Client, des, nw []InstanceGoogleprotobufstruct) []InstanceGoogleprotobufstruct {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceGoogleprotobufstruct
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceGoogleprotobufstruct(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipe(des, initial *InstanceCreateRecipe, opts ...dcl.ApplyOption) *InstanceCreateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceCreateRecipe(c *Client, des, nw *InstanceCreateRecipe) *InstanceCreateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceCreateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeSet(c *Client, des, nw []InstanceCreateRecipe) []InstanceCreateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeSlice(c *Client, des, nw []InstanceCreateRecipe) []InstanceCreateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeSteps(des, initial *InstanceCreateRecipeSteps, opts ...dcl.ApplyOption) *InstanceCreateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceCreateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceCreateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceCreateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeSteps(c *Client, des, nw *InstanceCreateRecipeSteps) *InstanceCreateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceCreateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsSet(c *Client, des, nw []InstanceCreateRecipeSteps) []InstanceCreateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsSlice(c *Client, des, nw []InstanceCreateRecipeSteps) []InstanceCreateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsStatus(des, initial *InstanceCreateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsStatus(c *Client, des, nw *InstanceCreateRecipeStepsStatus) *InstanceCreateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceCreateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsStatusSet(c *Client, des, nw []InstanceCreateRecipeStepsStatus) []InstanceCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsStatusSlice(c *Client, des, nw []InstanceCreateRecipeStepsStatus) []InstanceCreateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsStatusDetails(des, initial *InstanceCreateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsStatusDetails(c *Client, des, nw *InstanceCreateRecipeStepsStatusDetails) *InstanceCreateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceCreateRecipeStepsStatusDetails) []InstanceCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceCreateRecipeStepsStatusDetails) []InstanceCreateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsQuotaRequestDeltas(des, initial *InstanceCreateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceCreateRecipeStepsQuotaRequestDeltas) *InstanceCreateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceCreateRecipeStepsQuotaRequestDeltas) []InstanceCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceCreateRecipeStepsQuotaRequestDeltas) []InstanceCreateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPreprocessUpdate(des, initial *InstanceCreateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceCreateRecipeStepsPreprocessUpdate) *InstanceCreateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceCreateRecipeStepsPreprocessUpdate) []InstanceCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceCreateRecipeStepsPreprocessUpdate) []InstanceCreateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsRequestedTenantProject(des, initial *InstanceCreateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceCreateRecipeStepsRequestedTenantProject) *InstanceCreateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceCreateRecipeStepsRequestedTenantProject) []InstanceCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceCreateRecipeStepsRequestedTenantProject) []InstanceCreateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPermissionsInfo(des, initial *InstanceCreateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceCreateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceCreateRecipeStepsPermissionsInfo) *InstanceCreateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfo) []InstanceCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfo) []InstanceCreateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceCreateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceCreateRecipeStepsPermissionsInfoPolicyName) *InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoPolicyName) []InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoPolicyName) []InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceCreateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceCreateRecipeStepsPermissionsInfoIamPermissions) *InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoIamPermissions) []InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceCreateRecipeStepsPermissionsInfoIamPermissions) []InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdate(des, initial *InstanceCreateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceCreateRecipeStepsKeyNotificationsUpdate) *InstanceCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdate) []InstanceCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdate) []InstanceCreateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipe(des, initial *InstanceDeleteRecipe, opts ...dcl.ApplyOption) *InstanceDeleteRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipe(c *Client, des, nw *InstanceDeleteRecipe) *InstanceDeleteRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceDeleteRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeSet(c *Client, des, nw []InstanceDeleteRecipe) []InstanceDeleteRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeSlice(c *Client, des, nw []InstanceDeleteRecipe) []InstanceDeleteRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeSteps(des, initial *InstanceDeleteRecipeSteps, opts ...dcl.ApplyOption) *InstanceDeleteRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceDeleteRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceDeleteRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceDeleteRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeSteps(c *Client, des, nw *InstanceDeleteRecipeSteps) *InstanceDeleteRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceDeleteRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsSet(c *Client, des, nw []InstanceDeleteRecipeSteps) []InstanceDeleteRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsSlice(c *Client, des, nw []InstanceDeleteRecipeSteps) []InstanceDeleteRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsStatus(des, initial *InstanceDeleteRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsStatus(c *Client, des, nw *InstanceDeleteRecipeStepsStatus) *InstanceDeleteRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceDeleteRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusSet(c *Client, des, nw []InstanceDeleteRecipeStepsStatus) []InstanceDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusSlice(c *Client, des, nw []InstanceDeleteRecipeStepsStatus) []InstanceDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsStatusDetails(des, initial *InstanceDeleteRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusDetails(c *Client, des, nw *InstanceDeleteRecipeStepsStatusDetails) *InstanceDeleteRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceDeleteRecipeStepsStatusDetails) []InstanceDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceDeleteRecipeStepsStatusDetails) []InstanceDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsQuotaRequestDeltas(des, initial *InstanceDeleteRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceDeleteRecipeStepsQuotaRequestDeltas) *InstanceDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceDeleteRecipeStepsQuotaRequestDeltas) []InstanceDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceDeleteRecipeStepsQuotaRequestDeltas) []InstanceDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPreprocessUpdate(des, initial *InstanceDeleteRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceDeleteRecipeStepsPreprocessUpdate) *InstanceDeleteRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceDeleteRecipeStepsPreprocessUpdate) []InstanceDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPreprocessUpdate) []InstanceDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsRequestedTenantProject(des, initial *InstanceDeleteRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceDeleteRecipeStepsRequestedTenantProject) *InstanceDeleteRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceDeleteRecipeStepsRequestedTenantProject) []InstanceDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceDeleteRecipeStepsRequestedTenantProject) []InstanceDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPermissionsInfo(des, initial *InstanceDeleteRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceDeleteRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceDeleteRecipeStepsPermissionsInfo) *InstanceDeleteRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfo) []InstanceDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfo) []InstanceDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceDeleteRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceDeleteRecipeStepsPermissionsInfoPolicyName) *InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoPolicyName) []InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoPolicyName) []InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdate(des, initial *InstanceDeleteRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceDeleteRecipeStepsKeyNotificationsUpdate) *InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdate) []InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdate) []InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipe(des, initial *InstanceUpdateRecipe, opts ...dcl.ApplyOption) *InstanceUpdateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipe(c *Client, des, nw *InstanceUpdateRecipe) *InstanceUpdateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceUpdateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeSet(c *Client, des, nw []InstanceUpdateRecipe) []InstanceUpdateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeSlice(c *Client, des, nw []InstanceUpdateRecipe) []InstanceUpdateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeSteps(des, initial *InstanceUpdateRecipeSteps, opts ...dcl.ApplyOption) *InstanceUpdateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceUpdateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceUpdateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceUpdateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeSteps(c *Client, des, nw *InstanceUpdateRecipeSteps) *InstanceUpdateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceUpdateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsSet(c *Client, des, nw []InstanceUpdateRecipeSteps) []InstanceUpdateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsSlice(c *Client, des, nw []InstanceUpdateRecipeSteps) []InstanceUpdateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsStatus(des, initial *InstanceUpdateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsStatus(c *Client, des, nw *InstanceUpdateRecipeStepsStatus) *InstanceUpdateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceUpdateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusSet(c *Client, des, nw []InstanceUpdateRecipeStepsStatus) []InstanceUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusSlice(c *Client, des, nw []InstanceUpdateRecipeStepsStatus) []InstanceUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsStatusDetails(des, initial *InstanceUpdateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusDetails(c *Client, des, nw *InstanceUpdateRecipeStepsStatusDetails) *InstanceUpdateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceUpdateRecipeStepsStatusDetails) []InstanceUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceUpdateRecipeStepsStatusDetails) []InstanceUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsQuotaRequestDeltas(des, initial *InstanceUpdateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceUpdateRecipeStepsQuotaRequestDeltas) *InstanceUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceUpdateRecipeStepsQuotaRequestDeltas) []InstanceUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceUpdateRecipeStepsQuotaRequestDeltas) []InstanceUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPreprocessUpdate(des, initial *InstanceUpdateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceUpdateRecipeStepsPreprocessUpdate) *InstanceUpdateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceUpdateRecipeStepsPreprocessUpdate) []InstanceUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPreprocessUpdate) []InstanceUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsRequestedTenantProject(des, initial *InstanceUpdateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceUpdateRecipeStepsRequestedTenantProject) *InstanceUpdateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceUpdateRecipeStepsRequestedTenantProject) []InstanceUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceUpdateRecipeStepsRequestedTenantProject) []InstanceUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPermissionsInfo(des, initial *InstanceUpdateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceUpdateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceUpdateRecipeStepsPermissionsInfo) *InstanceUpdateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfo) []InstanceUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfo) []InstanceUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceUpdateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceUpdateRecipeStepsPermissionsInfoPolicyName) *InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoPolicyName) []InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoPolicyName) []InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdate(des, initial *InstanceUpdateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceUpdateRecipeStepsKeyNotificationsUpdate) *InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdate) []InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdate) []InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipe(des, initial *InstancePreprocessResetRecipe, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipe(c *Client, des, nw *InstancePreprocessResetRecipe) *InstancePreprocessResetRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessResetRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeSet(c *Client, des, nw []InstancePreprocessResetRecipe) []InstancePreprocessResetRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeSlice(c *Client, des, nw []InstancePreprocessResetRecipe) []InstancePreprocessResetRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeSteps(des, initial *InstancePreprocessResetRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessResetRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessResetRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessResetRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeSteps(c *Client, des, nw *InstancePreprocessResetRecipeSteps) *InstancePreprocessResetRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessResetRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsSet(c *Client, des, nw []InstancePreprocessResetRecipeSteps) []InstancePreprocessResetRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsSlice(c *Client, des, nw []InstancePreprocessResetRecipeSteps) []InstancePreprocessResetRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsStatus(des, initial *InstancePreprocessResetRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatus(c *Client, des, nw *InstancePreprocessResetRecipeStepsStatus) *InstancePreprocessResetRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsStatus) []InstancePreprocessResetRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsStatus) []InstancePreprocessResetRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsStatusDetails(des, initial *InstancePreprocessResetRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessResetRecipeStepsStatusDetails) *InstancePreprocessResetRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsStatusDetails) []InstancePreprocessResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsStatusDetails) []InstancePreprocessResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessResetRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessResetRecipeStepsQuotaRequestDeltas) *InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsQuotaRequestDeltas) []InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsQuotaRequestDeltas) []InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessResetRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessResetRecipeStepsPreprocessUpdate) *InstancePreprocessResetRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPreprocessUpdate) []InstancePreprocessResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPreprocessUpdate) []InstancePreprocessResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessResetRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessResetRecipeStepsRequestedTenantProject) *InstancePreprocessResetRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsRequestedTenantProject) []InstancePreprocessResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsRequestedTenantProject) []InstancePreprocessResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfo(des, initial *InstancePreprocessResetRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessResetRecipeStepsPermissionsInfo) *InstancePreprocessResetRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfo) []InstancePreprocessResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfo) []InstancePreprocessResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipe(des, initial *InstanceResetRecipe, opts ...dcl.ApplyOption) *InstanceResetRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceResetRecipe(c *Client, des, nw *InstanceResetRecipe) *InstanceResetRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceResetRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeSet(c *Client, des, nw []InstanceResetRecipe) []InstanceResetRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeSlice(c *Client, des, nw []InstanceResetRecipe) []InstanceResetRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeSteps(des, initial *InstanceResetRecipeSteps, opts ...dcl.ApplyOption) *InstanceResetRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceResetRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceResetRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceResetRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceResetRecipeSteps(c *Client, des, nw *InstanceResetRecipeSteps) *InstanceResetRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceResetRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceResetRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceResetRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceResetRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsSet(c *Client, des, nw []InstanceResetRecipeSteps) []InstanceResetRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsSlice(c *Client, des, nw []InstanceResetRecipeSteps) []InstanceResetRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsStatus(des, initial *InstanceResetRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsStatus(c *Client, des, nw *InstanceResetRecipeStepsStatus) *InstanceResetRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceResetRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsStatusSet(c *Client, des, nw []InstanceResetRecipeStepsStatus) []InstanceResetRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsStatusSlice(c *Client, des, nw []InstanceResetRecipeStepsStatus) []InstanceResetRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsStatusDetails(des, initial *InstanceResetRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsStatusDetails(c *Client, des, nw *InstanceResetRecipeStepsStatusDetails) *InstanceResetRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceResetRecipeStepsStatusDetails) []InstanceResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceResetRecipeStepsStatusDetails) []InstanceResetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsQuotaRequestDeltas(des, initial *InstanceResetRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceResetRecipeStepsQuotaRequestDeltas) *InstanceResetRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceResetRecipeStepsQuotaRequestDeltas) []InstanceResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceResetRecipeStepsQuotaRequestDeltas) []InstanceResetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPreprocessUpdate(des, initial *InstanceResetRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceResetRecipeStepsPreprocessUpdate) *InstanceResetRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceResetRecipeStepsPreprocessUpdate) []InstanceResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceResetRecipeStepsPreprocessUpdate) []InstanceResetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsRequestedTenantProject(des, initial *InstanceResetRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceResetRecipeStepsRequestedTenantProject) *InstanceResetRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceResetRecipeStepsRequestedTenantProject) []InstanceResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceResetRecipeStepsRequestedTenantProject) []InstanceResetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPermissionsInfo(des, initial *InstanceResetRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceResetRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceResetRecipeStepsPermissionsInfo) *InstanceResetRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfo) []InstanceResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfo) []InstanceResetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceResetRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceResetRecipeStepsPermissionsInfoPolicyName) *InstanceResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoPolicyName) []InstanceResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoPolicyName) []InstanceResetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceResetRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceResetRecipeStepsPermissionsInfoIamPermissions) *InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoIamPermissions) []InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceResetRecipeStepsPermissionsInfoIamPermissions) []InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdate(des, initial *InstanceResetRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceResetRecipeStepsKeyNotificationsUpdate) *InstanceResetRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdate) []InstanceResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdate) []InstanceResetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipe(des, initial *InstancePreprocessRepairRecipe, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipe(c *Client, des, nw *InstancePreprocessRepairRecipe) *InstancePreprocessRepairRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessRepairRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeSet(c *Client, des, nw []InstancePreprocessRepairRecipe) []InstancePreprocessRepairRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeSlice(c *Client, des, nw []InstancePreprocessRepairRecipe) []InstancePreprocessRepairRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeSteps(des, initial *InstancePreprocessRepairRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessRepairRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessRepairRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessRepairRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeSteps(c *Client, des, nw *InstancePreprocessRepairRecipeSteps) *InstancePreprocessRepairRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessRepairRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsSet(c *Client, des, nw []InstancePreprocessRepairRecipeSteps) []InstancePreprocessRepairRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeSteps) []InstancePreprocessRepairRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsStatus(des, initial *InstancePreprocessRepairRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatus(c *Client, des, nw *InstancePreprocessRepairRecipeStepsStatus) *InstancePreprocessRepairRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsStatus) []InstancePreprocessRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsStatus) []InstancePreprocessRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsStatusDetails(des, initial *InstancePreprocessRepairRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessRepairRecipeStepsStatusDetails) *InstancePreprocessRepairRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsStatusDetails) []InstancePreprocessRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsStatusDetails) []InstancePreprocessRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessRepairRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPreprocessUpdate) *InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPreprocessUpdate) []InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPreprocessUpdate) []InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessRepairRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessRepairRecipeStepsRequestedTenantProject) *InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsRequestedTenantProject) []InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsRequestedTenantProject) []InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfo(des, initial *InstancePreprocessRepairRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPermissionsInfo) *InstancePreprocessRepairRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfo) []InstancePreprocessRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfo) []InstancePreprocessRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipe(des, initial *InstanceRepairRecipe, opts ...dcl.ApplyOption) *InstanceRepairRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceRepairRecipe(c *Client, des, nw *InstanceRepairRecipe) *InstanceRepairRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceRepairRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeSet(c *Client, des, nw []InstanceRepairRecipe) []InstanceRepairRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeSlice(c *Client, des, nw []InstanceRepairRecipe) []InstanceRepairRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeSteps(des, initial *InstanceRepairRecipeSteps, opts ...dcl.ApplyOption) *InstanceRepairRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceRepairRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceRepairRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceRepairRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeSteps(c *Client, des, nw *InstanceRepairRecipeSteps) *InstanceRepairRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceRepairRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsSet(c *Client, des, nw []InstanceRepairRecipeSteps) []InstanceRepairRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsSlice(c *Client, des, nw []InstanceRepairRecipeSteps) []InstanceRepairRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsStatus(des, initial *InstanceRepairRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsStatus(c *Client, des, nw *InstanceRepairRecipeStepsStatus) *InstanceRepairRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceRepairRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsStatusSet(c *Client, des, nw []InstanceRepairRecipeStepsStatus) []InstanceRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsStatusSlice(c *Client, des, nw []InstanceRepairRecipeStepsStatus) []InstanceRepairRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsStatusDetails(des, initial *InstanceRepairRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsStatusDetails(c *Client, des, nw *InstanceRepairRecipeStepsStatusDetails) *InstanceRepairRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceRepairRecipeStepsStatusDetails) []InstanceRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceRepairRecipeStepsStatusDetails) []InstanceRepairRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsQuotaRequestDeltas(des, initial *InstanceRepairRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceRepairRecipeStepsQuotaRequestDeltas) *InstanceRepairRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceRepairRecipeStepsQuotaRequestDeltas) []InstanceRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceRepairRecipeStepsQuotaRequestDeltas) []InstanceRepairRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPreprocessUpdate(des, initial *InstanceRepairRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceRepairRecipeStepsPreprocessUpdate) *InstanceRepairRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceRepairRecipeStepsPreprocessUpdate) []InstanceRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceRepairRecipeStepsPreprocessUpdate) []InstanceRepairRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsRequestedTenantProject(des, initial *InstanceRepairRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceRepairRecipeStepsRequestedTenantProject) *InstanceRepairRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceRepairRecipeStepsRequestedTenantProject) []InstanceRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceRepairRecipeStepsRequestedTenantProject) []InstanceRepairRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPermissionsInfo(des, initial *InstanceRepairRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceRepairRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceRepairRecipeStepsPermissionsInfo) *InstanceRepairRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfo) []InstanceRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfo) []InstanceRepairRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceRepairRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceRepairRecipeStepsPermissionsInfoPolicyName) *InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoPolicyName) []InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoPolicyName) []InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceRepairRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceRepairRecipeStepsPermissionsInfoIamPermissions) *InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoIamPermissions) []InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceRepairRecipeStepsPermissionsInfoIamPermissions) []InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdate(des, initial *InstanceRepairRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceRepairRecipeStepsKeyNotificationsUpdate) *InstanceRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdate) []InstanceRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdate) []InstanceRepairRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipe(des, initial *InstancePreprocessDeleteRecipe, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipe(c *Client, des, nw *InstancePreprocessDeleteRecipe) *InstancePreprocessDeleteRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessDeleteRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeSet(c *Client, des, nw []InstancePreprocessDeleteRecipe) []InstancePreprocessDeleteRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeSlice(c *Client, des, nw []InstancePreprocessDeleteRecipe) []InstancePreprocessDeleteRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeSteps(des, initial *InstancePreprocessDeleteRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessDeleteRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessDeleteRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessDeleteRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeSteps(c *Client, des, nw *InstancePreprocessDeleteRecipeSteps) *InstancePreprocessDeleteRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessDeleteRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeSteps) []InstancePreprocessDeleteRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeSteps) []InstancePreprocessDeleteRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsStatus(des, initial *InstancePreprocessDeleteRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatus(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsStatus) *InstancePreprocessDeleteRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsStatus) []InstancePreprocessDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsStatus) []InstancePreprocessDeleteRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsStatusDetails(des, initial *InstancePreprocessDeleteRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsStatusDetails) *InstancePreprocessDeleteRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsStatusDetails) []InstancePreprocessDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsStatusDetails) []InstancePreprocessDeleteRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessDeleteRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPreprocessUpdate) *InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPreprocessUpdate) []InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPreprocessUpdate) []InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessDeleteRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsRequestedTenantProject) *InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsRequestedTenantProject) []InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsRequestedTenantProject) []InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfo(des, initial *InstancePreprocessDeleteRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPermissionsInfo) *InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfo) []InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfo) []InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipe(des, initial *InstancePreprocessUpdateRecipe, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipe(c *Client, des, nw *InstancePreprocessUpdateRecipe) *InstancePreprocessUpdateRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessUpdateRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeSet(c *Client, des, nw []InstancePreprocessUpdateRecipe) []InstancePreprocessUpdateRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeSlice(c *Client, des, nw []InstancePreprocessUpdateRecipe) []InstancePreprocessUpdateRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeSteps(des, initial *InstancePreprocessUpdateRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessUpdateRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessUpdateRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessUpdateRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeSteps(c *Client, des, nw *InstancePreprocessUpdateRecipeSteps) *InstancePreprocessUpdateRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessUpdateRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeSteps) []InstancePreprocessUpdateRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeSteps) []InstancePreprocessUpdateRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsStatus(des, initial *InstancePreprocessUpdateRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatus(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsStatus) *InstancePreprocessUpdateRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsStatus) []InstancePreprocessUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsStatus) []InstancePreprocessUpdateRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsStatusDetails(des, initial *InstancePreprocessUpdateRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsStatusDetails) *InstancePreprocessUpdateRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsStatusDetails) []InstancePreprocessUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsStatusDetails) []InstancePreprocessUpdateRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessUpdateRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPreprocessUpdate) *InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPreprocessUpdate) []InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPreprocessUpdate) []InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessUpdateRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsRequestedTenantProject) *InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsRequestedTenantProject) []InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsRequestedTenantProject) []InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfo(des, initial *InstancePreprocessUpdateRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPermissionsInfo) *InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfo) []InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfo) []InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipe(des, initial *InstancePreprocessFreezeRecipe, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipe(c *Client, des, nw *InstancePreprocessFreezeRecipe) *InstancePreprocessFreezeRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessFreezeRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeSet(c *Client, des, nw []InstancePreprocessFreezeRecipe) []InstancePreprocessFreezeRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeSlice(c *Client, des, nw []InstancePreprocessFreezeRecipe) []InstancePreprocessFreezeRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeSteps(des, initial *InstancePreprocessFreezeRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessFreezeRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessFreezeRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessFreezeRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeSteps(c *Client, des, nw *InstancePreprocessFreezeRecipeSteps) *InstancePreprocessFreezeRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessFreezeRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeSteps) []InstancePreprocessFreezeRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeSteps) []InstancePreprocessFreezeRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsStatus(des, initial *InstancePreprocessFreezeRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatus(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsStatus) *InstancePreprocessFreezeRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsStatus) []InstancePreprocessFreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsStatus) []InstancePreprocessFreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsStatusDetails(des, initial *InstancePreprocessFreezeRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsStatusDetails) *InstancePreprocessFreezeRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsStatusDetails) []InstancePreprocessFreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsStatusDetails) []InstancePreprocessFreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessFreezeRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPreprocessUpdate) *InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPreprocessUpdate) []InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPreprocessUpdate) []InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessFreezeRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsRequestedTenantProject) *InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsRequestedTenantProject) []InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsRequestedTenantProject) []InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfo(des, initial *InstancePreprocessFreezeRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPermissionsInfo) *InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfo) []InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfo) []InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipe(des, initial *InstanceFreezeRecipe, opts ...dcl.ApplyOption) *InstanceFreezeRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipe(c *Client, des, nw *InstanceFreezeRecipe) *InstanceFreezeRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceFreezeRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeSet(c *Client, des, nw []InstanceFreezeRecipe) []InstanceFreezeRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeSlice(c *Client, des, nw []InstanceFreezeRecipe) []InstanceFreezeRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeSteps(des, initial *InstanceFreezeRecipeSteps, opts ...dcl.ApplyOption) *InstanceFreezeRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceFreezeRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceFreezeRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceFreezeRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeSteps(c *Client, des, nw *InstanceFreezeRecipeSteps) *InstanceFreezeRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceFreezeRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsSet(c *Client, des, nw []InstanceFreezeRecipeSteps) []InstanceFreezeRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsSlice(c *Client, des, nw []InstanceFreezeRecipeSteps) []InstanceFreezeRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsStatus(des, initial *InstanceFreezeRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsStatus(c *Client, des, nw *InstanceFreezeRecipeStepsStatus) *InstanceFreezeRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceFreezeRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusSet(c *Client, des, nw []InstanceFreezeRecipeStepsStatus) []InstanceFreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusSlice(c *Client, des, nw []InstanceFreezeRecipeStepsStatus) []InstanceFreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsStatusDetails(des, initial *InstanceFreezeRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusDetails(c *Client, des, nw *InstanceFreezeRecipeStepsStatusDetails) *InstanceFreezeRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceFreezeRecipeStepsStatusDetails) []InstanceFreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceFreezeRecipeStepsStatusDetails) []InstanceFreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsQuotaRequestDeltas(des, initial *InstanceFreezeRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceFreezeRecipeStepsQuotaRequestDeltas) *InstanceFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceFreezeRecipeStepsQuotaRequestDeltas) []InstanceFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceFreezeRecipeStepsQuotaRequestDeltas) []InstanceFreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPreprocessUpdate(des, initial *InstanceFreezeRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceFreezeRecipeStepsPreprocessUpdate) *InstanceFreezeRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceFreezeRecipeStepsPreprocessUpdate) []InstanceFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPreprocessUpdate) []InstanceFreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsRequestedTenantProject(des, initial *InstanceFreezeRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceFreezeRecipeStepsRequestedTenantProject) *InstanceFreezeRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceFreezeRecipeStepsRequestedTenantProject) []InstanceFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceFreezeRecipeStepsRequestedTenantProject) []InstanceFreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPermissionsInfo(des, initial *InstanceFreezeRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceFreezeRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceFreezeRecipeStepsPermissionsInfo) *InstanceFreezeRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfo) []InstanceFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfo) []InstanceFreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceFreezeRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceFreezeRecipeStepsPermissionsInfoPolicyName) *InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoPolicyName) []InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoPolicyName) []InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdate(des, initial *InstanceFreezeRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceFreezeRecipeStepsKeyNotificationsUpdate) *InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdate) []InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdate) []InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipe(des, initial *InstancePreprocessUnfreezeRecipe, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipe(c *Client, des, nw *InstancePreprocessUnfreezeRecipe) *InstancePreprocessUnfreezeRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipe) []InstancePreprocessUnfreezeRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipe) []InstancePreprocessUnfreezeRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeSteps(des, initial *InstancePreprocessUnfreezeRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessUnfreezeRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeSteps(c *Client, des, nw *InstancePreprocessUnfreezeRecipeSteps) *InstancePreprocessUnfreezeRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeSteps) []InstancePreprocessUnfreezeRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeSteps) []InstancePreprocessUnfreezeRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsStatus(des, initial *InstancePreprocessUnfreezeRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatus(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsStatus) *InstancePreprocessUnfreezeRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsStatus) []InstancePreprocessUnfreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsStatus) []InstancePreprocessUnfreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsStatusDetails(des, initial *InstancePreprocessUnfreezeRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsStatusDetails) *InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsStatusDetails) []InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsStatusDetails) []InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(des, initial *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipe(des, initial *InstanceUnfreezeRecipe, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipe(c *Client, des, nw *InstanceUnfreezeRecipe) *InstanceUnfreezeRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceUnfreezeRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeSet(c *Client, des, nw []InstanceUnfreezeRecipe) []InstanceUnfreezeRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeSlice(c *Client, des, nw []InstanceUnfreezeRecipe) []InstanceUnfreezeRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeSteps(des, initial *InstanceUnfreezeRecipeSteps, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceUnfreezeRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceUnfreezeRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceUnfreezeRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeSteps(c *Client, des, nw *InstanceUnfreezeRecipeSteps) *InstanceUnfreezeRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceUnfreezeRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsSet(c *Client, des, nw []InstanceUnfreezeRecipeSteps) []InstanceUnfreezeRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsSlice(c *Client, des, nw []InstanceUnfreezeRecipeSteps) []InstanceUnfreezeRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsStatus(des, initial *InstanceUnfreezeRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatus(c *Client, des, nw *InstanceUnfreezeRecipeStepsStatus) *InstanceUnfreezeRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsStatus) []InstanceUnfreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsStatus) []InstanceUnfreezeRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsStatusDetails(des, initial *InstanceUnfreezeRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetails(c *Client, des, nw *InstanceUnfreezeRecipeStepsStatusDetails) *InstanceUnfreezeRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsStatusDetails) []InstanceUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsStatusDetails) []InstanceUnfreezeRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsQuotaRequestDeltas(des, initial *InstanceUnfreezeRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceUnfreezeRecipeStepsQuotaRequestDeltas) *InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsQuotaRequestDeltas) []InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsQuotaRequestDeltas) []InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPreprocessUpdate(des, initial *InstanceUnfreezeRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceUnfreezeRecipeStepsPreprocessUpdate) *InstanceUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPreprocessUpdate) []InstanceUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPreprocessUpdate) []InstanceUnfreezeRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsRequestedTenantProject(des, initial *InstanceUnfreezeRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceUnfreezeRecipeStepsRequestedTenantProject) *InstanceUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsRequestedTenantProject) []InstanceUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsRequestedTenantProject) []InstanceUnfreezeRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfo(des, initial *InstanceUnfreezeRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceUnfreezeRecipeStepsPermissionsInfo) *InstanceUnfreezeRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfo) []InstanceUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfo) []InstanceUnfreezeRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(des, initial *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipe(des, initial *InstancePreprocessReportInstanceHealthRecipe, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipe(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipe) *InstancePreprocessReportInstanceHealthRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipe) []InstancePreprocessReportInstanceHealthRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipe) []InstancePreprocessReportInstanceHealthRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeSteps(des, initial *InstancePreprocessReportInstanceHealthRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeSteps(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeSteps) *InstancePreprocessReportInstanceHealthRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeSteps) []InstancePreprocessReportInstanceHealthRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeSteps) []InstancePreprocessReportInstanceHealthRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsStatus(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatus(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsStatus) *InstancePreprocessReportInstanceHealthRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsStatus) []InstancePreprocessReportInstanceHealthRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsStatus) []InstancePreprocessReportInstanceHealthRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails) *InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails) []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails) []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas) *InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas) []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas) []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate) *InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate) []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate) []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject) *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject) []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject) []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipe(des, initial *InstanceReportInstanceHealthRecipe, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipe(c *Client, des, nw *InstanceReportInstanceHealthRecipe) *InstanceReportInstanceHealthRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceReportInstanceHealthRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeSet(c *Client, des, nw []InstanceReportInstanceHealthRecipe) []InstanceReportInstanceHealthRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipe) []InstanceReportInstanceHealthRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeSteps(des, initial *InstanceReportInstanceHealthRecipeSteps, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceReportInstanceHealthRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeSteps(c *Client, des, nw *InstanceReportInstanceHealthRecipeSteps) *InstanceReportInstanceHealthRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeSteps) []InstanceReportInstanceHealthRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeSteps) []InstanceReportInstanceHealthRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsStatus(des, initial *InstanceReportInstanceHealthRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatus(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsStatus) *InstanceReportInstanceHealthRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatusSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsStatus) []InstanceReportInstanceHealthRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatusSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsStatus) []InstanceReportInstanceHealthRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsStatusDetails(des, initial *InstanceReportInstanceHealthRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatusDetails(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsStatusDetails) *InstanceReportInstanceHealthRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsStatusDetails) []InstanceReportInstanceHealthRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsStatusDetails) []InstanceReportInstanceHealthRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(des, initial *InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas) *InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas) []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas) []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(des, initial *InstanceReportInstanceHealthRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsPreprocessUpdate) *InstanceReportInstanceHealthRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate) []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate) []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(des, initial *InstanceReportInstanceHealthRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsRequestedTenantProject) *InstanceReportInstanceHealthRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject) []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject) []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsPermissionsInfo(des, initial *InstanceReportInstanceHealthRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsPermissionsInfo) *InstanceReportInstanceHealthRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsPermissionsInfo) []InstanceReportInstanceHealthRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsPermissionsInfo) []InstanceReportInstanceHealthRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) *InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) *InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(des, initial *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipe(des, initial *InstancePreprocessGetRecipe, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipe(c *Client, des, nw *InstancePreprocessGetRecipe) *InstancePreprocessGetRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessGetRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeSet(c *Client, des, nw []InstancePreprocessGetRecipe) []InstancePreprocessGetRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeSlice(c *Client, des, nw []InstancePreprocessGetRecipe) []InstancePreprocessGetRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeSteps(des, initial *InstancePreprocessGetRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessGetRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessGetRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessGetRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeSteps(c *Client, des, nw *InstancePreprocessGetRecipeSteps) *InstancePreprocessGetRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessGetRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessGetRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessGetRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessGetRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsSet(c *Client, des, nw []InstancePreprocessGetRecipeSteps) []InstancePreprocessGetRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsSlice(c *Client, des, nw []InstancePreprocessGetRecipeSteps) []InstancePreprocessGetRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsStatus(des, initial *InstancePreprocessGetRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsStatus(c *Client, des, nw *InstancePreprocessGetRecipeStepsStatus) *InstancePreprocessGetRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessGetRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsStatus) []InstancePreprocessGetRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsStatus) []InstancePreprocessGetRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsStatusDetails(des, initial *InstancePreprocessGetRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessGetRecipeStepsStatusDetails) *InstancePreprocessGetRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsStatusDetails) []InstancePreprocessGetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsStatusDetails) []InstancePreprocessGetRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessGetRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessGetRecipeStepsQuotaRequestDeltas) *InstancePreprocessGetRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsQuotaRequestDeltas) []InstancePreprocessGetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsQuotaRequestDeltas) []InstancePreprocessGetRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessGetRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessGetRecipeStepsPreprocessUpdate) *InstancePreprocessGetRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsPreprocessUpdate) []InstancePreprocessGetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsPreprocessUpdate) []InstancePreprocessGetRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessGetRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessGetRecipeStepsRequestedTenantProject) *InstancePreprocessGetRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsRequestedTenantProject) []InstancePreprocessGetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsRequestedTenantProject) []InstancePreprocessGetRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsPermissionsInfo(des, initial *InstancePreprocessGetRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessGetRecipeStepsPermissionsInfo) *InstancePreprocessGetRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsPermissionsInfo) []InstancePreprocessGetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsPermissionsInfo) []InstancePreprocessGetRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessGetRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessGetRecipeStepsKeyNotificationsUpdate) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipe(des, initial *InstanceNotifyKeyAvailableRecipe, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipe(c *Client, des, nw *InstanceNotifyKeyAvailableRecipe) *InstanceNotifyKeyAvailableRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipe) []InstanceNotifyKeyAvailableRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipe) []InstanceNotifyKeyAvailableRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeSteps(des, initial *InstanceNotifyKeyAvailableRecipeSteps, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceNotifyKeyAvailableRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeSteps(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeSteps) *InstanceNotifyKeyAvailableRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeSteps) []InstanceNotifyKeyAvailableRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeSteps) []InstanceNotifyKeyAvailableRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsStatus(des, initial *InstanceNotifyKeyAvailableRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatus(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsStatus) *InstanceNotifyKeyAvailableRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatusSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsStatus) []InstanceNotifyKeyAvailableRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatusSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsStatus) []InstanceNotifyKeyAvailableRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsStatusDetails(des, initial *InstanceNotifyKeyAvailableRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatusDetails(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsStatusDetails) *InstanceNotifyKeyAvailableRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsStatusDetails) []InstanceNotifyKeyAvailableRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsStatusDetails) []InstanceNotifyKeyAvailableRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(des, initial *InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas) *InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas) []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas) []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(des, initial *InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate) *InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate) []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate) []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(des, initial *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject) *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject) []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject) []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(des, initial *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(des, initial *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipe(des, initial *InstanceNotifyKeyUnavailableRecipe, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipe(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipe) *InstanceNotifyKeyUnavailableRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipe) []InstanceNotifyKeyUnavailableRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipe) []InstanceNotifyKeyUnavailableRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeSteps(des, initial *InstanceNotifyKeyUnavailableRecipeSteps, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceNotifyKeyUnavailableRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeSteps(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeSteps) *InstanceNotifyKeyUnavailableRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeSteps) []InstanceNotifyKeyUnavailableRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeSteps) []InstanceNotifyKeyUnavailableRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsStatus(des, initial *InstanceNotifyKeyUnavailableRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatus(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsStatus) *InstanceNotifyKeyUnavailableRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatusSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsStatus) []InstanceNotifyKeyUnavailableRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatusSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsStatus) []InstanceNotifyKeyUnavailableRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(des, initial *InstanceNotifyKeyUnavailableRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsStatusDetails) *InstanceNotifyKeyUnavailableRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails) []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails) []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(des, initial *InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas) *InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas) []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas) []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(des, initial *InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate) *InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate) []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate) []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(des, initial *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject) *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject) []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject) []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(des, initial *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(des, initial *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipe(des, initial *InstanceReadonlyRecipe, opts ...dcl.ApplyOption) *InstanceReadonlyRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipe(c *Client, des, nw *InstanceReadonlyRecipe) *InstanceReadonlyRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceReadonlyRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeSet(c *Client, des, nw []InstanceReadonlyRecipe) []InstanceReadonlyRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeSlice(c *Client, des, nw []InstanceReadonlyRecipe) []InstanceReadonlyRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeSteps(des, initial *InstanceReadonlyRecipeSteps, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceReadonlyRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceReadonlyRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceReadonlyRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeSteps(c *Client, des, nw *InstanceReadonlyRecipeSteps) *InstanceReadonlyRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceReadonlyRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsSet(c *Client, des, nw []InstanceReadonlyRecipeSteps) []InstanceReadonlyRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsSlice(c *Client, des, nw []InstanceReadonlyRecipeSteps) []InstanceReadonlyRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsStatus(des, initial *InstanceReadonlyRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatus(c *Client, des, nw *InstanceReadonlyRecipeStepsStatus) *InstanceReadonlyRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceReadonlyRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusSet(c *Client, des, nw []InstanceReadonlyRecipeStepsStatus) []InstanceReadonlyRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsStatus) []InstanceReadonlyRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsStatusDetails(des, initial *InstanceReadonlyRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusDetails(c *Client, des, nw *InstanceReadonlyRecipeStepsStatusDetails) *InstanceReadonlyRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceReadonlyRecipeStepsStatusDetails) []InstanceReadonlyRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsStatusDetails) []InstanceReadonlyRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsQuotaRequestDeltas(des, initial *InstanceReadonlyRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceReadonlyRecipeStepsQuotaRequestDeltas) *InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceReadonlyRecipeStepsQuotaRequestDeltas) []InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsQuotaRequestDeltas) []InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPreprocessUpdate(des, initial *InstanceReadonlyRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceReadonlyRecipeStepsPreprocessUpdate) *InstanceReadonlyRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPreprocessUpdate) []InstanceReadonlyRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPreprocessUpdate) []InstanceReadonlyRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsRequestedTenantProject(des, initial *InstanceReadonlyRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceReadonlyRecipeStepsRequestedTenantProject) *InstanceReadonlyRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceReadonlyRecipeStepsRequestedTenantProject) []InstanceReadonlyRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsRequestedTenantProject) []InstanceReadonlyRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPermissionsInfo(des, initial *InstanceReadonlyRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceReadonlyRecipeStepsPermissionsInfo) *InstanceReadonlyRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfo) []InstanceReadonlyRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfo) []InstanceReadonlyRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdate(des, initial *InstanceReadonlyRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceReadonlyRecipeStepsKeyNotificationsUpdate) *InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdate) []InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdate) []InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipe(des, initial *InstanceReconcileRecipe, opts ...dcl.ApplyOption) *InstanceReconcileRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipe(c *Client, des, nw *InstanceReconcileRecipe) *InstanceReconcileRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstanceReconcileRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeSet(c *Client, des, nw []InstanceReconcileRecipe) []InstanceReconcileRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeSlice(c *Client, des, nw []InstanceReconcileRecipe) []InstanceReconcileRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeSteps(des, initial *InstanceReconcileRecipeSteps, opts ...dcl.ApplyOption) *InstanceReconcileRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstanceReconcileRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstanceReconcileRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstanceReconcileRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstanceReconcileRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeSteps(c *Client, des, nw *InstanceReconcileRecipeSteps) *InstanceReconcileRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstanceReconcileRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstanceReconcileRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstanceReconcileRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstanceReconcileRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsSet(c *Client, des, nw []InstanceReconcileRecipeSteps) []InstanceReconcileRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsSlice(c *Client, des, nw []InstanceReconcileRecipeSteps) []InstanceReconcileRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsStatus(des, initial *InstanceReconcileRecipeStepsStatus, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsStatus(c *Client, des, nw *InstanceReconcileRecipeStepsStatus) *InstanceReconcileRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstanceReconcileRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsStatusSet(c *Client, des, nw []InstanceReconcileRecipeStepsStatus) []InstanceReconcileRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsStatusSlice(c *Client, des, nw []InstanceReconcileRecipeStepsStatus) []InstanceReconcileRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsStatusDetails(des, initial *InstanceReconcileRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsStatusDetails(c *Client, des, nw *InstanceReconcileRecipeStepsStatusDetails) *InstanceReconcileRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsStatusDetailsSet(c *Client, des, nw []InstanceReconcileRecipeStepsStatusDetails) []InstanceReconcileRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstanceReconcileRecipeStepsStatusDetails) []InstanceReconcileRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsQuotaRequestDeltas(des, initial *InstanceReconcileRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstanceReconcileRecipeStepsQuotaRequestDeltas) *InstanceReconcileRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstanceReconcileRecipeStepsQuotaRequestDeltas) []InstanceReconcileRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstanceReconcileRecipeStepsQuotaRequestDeltas) []InstanceReconcileRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsPreprocessUpdate(des, initial *InstanceReconcileRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsPreprocessUpdate(c *Client, des, nw *InstanceReconcileRecipeStepsPreprocessUpdate) *InstanceReconcileRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstanceReconcileRecipeStepsPreprocessUpdate) []InstanceReconcileRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstanceReconcileRecipeStepsPreprocessUpdate) []InstanceReconcileRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsRequestedTenantProject(des, initial *InstanceReconcileRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsRequestedTenantProject(c *Client, des, nw *InstanceReconcileRecipeStepsRequestedTenantProject) *InstanceReconcileRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstanceReconcileRecipeStepsRequestedTenantProject) []InstanceReconcileRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstanceReconcileRecipeStepsRequestedTenantProject) []InstanceReconcileRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsPermissionsInfo(des, initial *InstanceReconcileRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstanceReconcileRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfo(c *Client, des, nw *InstanceReconcileRecipeStepsPermissionsInfo) *InstanceReconcileRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstanceReconcileRecipeStepsPermissionsInfo) []InstanceReconcileRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstanceReconcileRecipeStepsPermissionsInfo) []InstanceReconcileRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsPermissionsInfoPolicyName(des, initial *InstanceReconcileRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstanceReconcileRecipeStepsPermissionsInfoPolicyName) *InstanceReconcileRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstanceReconcileRecipeStepsPermissionsInfoPolicyName) []InstanceReconcileRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstanceReconcileRecipeStepsPermissionsInfoPolicyName) []InstanceReconcileRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(des, initial *InstanceReconcileRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstanceReconcileRecipeStepsPermissionsInfoIamPermissions) *InstanceReconcileRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions) []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions) []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsKeyNotificationsUpdate(des, initial *InstanceReconcileRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstanceReconcileRecipeStepsKeyNotificationsUpdate) *InstanceReconcileRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstanceReconcileRecipeStepsKeyNotificationsUpdate) []InstanceReconcileRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstanceReconcileRecipeStepsKeyNotificationsUpdate) []InstanceReconcileRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipe(des, initial *InstancePreprocessPassthroughRecipe, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipe(c *Client, des, nw *InstancePreprocessPassthroughRecipe) *InstancePreprocessPassthroughRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessPassthroughRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeSet(c *Client, des, nw []InstancePreprocessPassthroughRecipe) []InstancePreprocessPassthroughRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipe) []InstancePreprocessPassthroughRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeSteps(des, initial *InstancePreprocessPassthroughRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessPassthroughRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeSteps(c *Client, des, nw *InstancePreprocessPassthroughRecipeSteps) *InstancePreprocessPassthroughRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeSteps) []InstancePreprocessPassthroughRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeSteps) []InstancePreprocessPassthroughRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsStatus(des, initial *InstancePreprocessPassthroughRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatus(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsStatus) *InstancePreprocessPassthroughRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsStatus) []InstancePreprocessPassthroughRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsStatus) []InstancePreprocessPassthroughRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsStatusDetails(des, initial *InstancePreprocessPassthroughRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsStatusDetails) *InstancePreprocessPassthroughRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsStatusDetails) []InstancePreprocessPassthroughRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsStatusDetails) []InstancePreprocessPassthroughRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas) *InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas) []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas) []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessPassthroughRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsPreprocessUpdate) *InstancePreprocessPassthroughRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate) []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate) []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessPassthroughRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsRequestedTenantProject) *InstancePreprocessPassthroughRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject) []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject) []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsPermissionsInfo(des, initial *InstancePreprocessPassthroughRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsPermissionsInfo) *InstancePreprocessPassthroughRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsPermissionsInfo) []InstancePreprocessPassthroughRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsPermissionsInfo) []InstancePreprocessPassthroughRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipe(des, initial *InstancePreprocessReconcileRecipe, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipe {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Steps) {
		des.Steps = initial.Steps
	}
	if dcl.BoolCanonicalize(des.HonorCancelRequest, initial.HonorCancelRequest) || dcl.IsZeroValue(des.HonorCancelRequest) {
		des.HonorCancelRequest = initial.HonorCancelRequest
	}
	if dcl.IsZeroValue(des.IgnoreRecipeAfter) {
		des.IgnoreRecipeAfter = initial.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(des.VerifyDeadlineSecondsBelow) {
		des.VerifyDeadlineSecondsBelow = initial.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, initial.PopulateOperationResult) || dcl.IsZeroValue(des.PopulateOperationResult) {
		des.PopulateOperationResult = initial.PopulateOperationResult
	}
	if dcl.IsZeroValue(des.ReadonlyRecipeStartTime) {
		des.ReadonlyRecipeStartTime = initial.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(des.ResourceNamesStoredInClhWithDelay) {
		des.ResourceNamesStoredInClhWithDelay = initial.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(des.DelayToStoreResourcesInClhDbNanos) {
		des.DelayToStoreResourcesInClhDbNanos = initial.DelayToStoreResourcesInClhDbNanos
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipe(c *Client, des, nw *InstancePreprocessReconcileRecipe) *InstancePreprocessReconcileRecipe {
	if des == nil || nw == nil {
		return nw
	}

	nw.Steps = canonicalizeNewInstancePreprocessReconcileRecipeStepsSlice(c, des.Steps, nw.Steps)
	if dcl.BoolCanonicalize(des.HonorCancelRequest, nw.HonorCancelRequest) {
		nw.HonorCancelRequest = des.HonorCancelRequest
	}
	if dcl.IsZeroValue(nw.IgnoreRecipeAfter) {
		nw.IgnoreRecipeAfter = des.IgnoreRecipeAfter
	}
	if dcl.IsZeroValue(nw.VerifyDeadlineSecondsBelow) {
		nw.VerifyDeadlineSecondsBelow = des.VerifyDeadlineSecondsBelow
	}
	if dcl.BoolCanonicalize(des.PopulateOperationResult, nw.PopulateOperationResult) {
		nw.PopulateOperationResult = des.PopulateOperationResult
	}
	if dcl.IsZeroValue(nw.ReadonlyRecipeStartTime) {
		nw.ReadonlyRecipeStartTime = des.ReadonlyRecipeStartTime
	}
	if dcl.IsZeroValue(nw.ResourceNamesStoredInClhWithDelay) {
		nw.ResourceNamesStoredInClhWithDelay = des.ResourceNamesStoredInClhWithDelay
	}
	if dcl.IsZeroValue(nw.DelayToStoreResourcesInClhDbNanos) {
		nw.DelayToStoreResourcesInClhDbNanos = des.DelayToStoreResourcesInClhDbNanos
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeSet(c *Client, des, nw []InstancePreprocessReconcileRecipe) []InstancePreprocessReconcileRecipe {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipe
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeSlice(c *Client, des, nw []InstancePreprocessReconcileRecipe) []InstancePreprocessReconcileRecipe {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipe
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipe(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeSteps(des, initial *InstancePreprocessReconcileRecipeSteps, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeSteps {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.RelativeTime) {
		des.RelativeTime = initial.RelativeTime
	}
	if dcl.IsZeroValue(des.SleepDuration) {
		des.SleepDuration = initial.SleepDuration
	}
	if dcl.IsZeroValue(des.Action) {
		des.Action = initial.Action
	}
	des.Status = canonicalizeInstancePreprocessReconcileRecipeStepsStatus(des.Status, initial.Status, opts...)
	if dcl.StringCanonicalize(des.ErrorSpace, initial.ErrorSpace) || dcl.IsZeroValue(des.ErrorSpace) {
		des.ErrorSpace = initial.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}
	if dcl.IsZeroValue(des.ResourceMetadataSize) {
		des.ResourceMetadataSize = initial.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.UpdatedRepeatOperationDelaySec) {
		des.UpdatedRepeatOperationDelaySec = initial.UpdatedRepeatOperationDelaySec
	}
	if dcl.IsZeroValue(des.QuotaRequestDeltas) {
		des.QuotaRequestDeltas = initial.QuotaRequestDeltas
	}
	des.PreprocessUpdate = canonicalizeInstancePreprocessReconcileRecipeStepsPreprocessUpdate(des.PreprocessUpdate, initial.PreprocessUpdate, opts...)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}
	des.RequestedTenantProject = canonicalizeInstancePreprocessReconcileRecipeStepsRequestedTenantProject(des.RequestedTenantProject, initial.RequestedTenantProject, opts...)
	if dcl.IsZeroValue(des.PermissionsInfo) {
		des.PermissionsInfo = initial.PermissionsInfo
	}
	des.KeyNotificationsUpdate = canonicalizeInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(des.KeyNotificationsUpdate, initial.KeyNotificationsUpdate, opts...)
	if dcl.IsZeroValue(des.ClhDataUpdateTime) {
		des.ClhDataUpdateTime = initial.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, initial.PublicErrorMessage) || dcl.IsZeroValue(des.PublicErrorMessage) {
		des.PublicErrorMessage = initial.PublicErrorMessage
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeSteps(c *Client, des, nw *InstancePreprocessReconcileRecipeSteps) *InstancePreprocessReconcileRecipeSteps {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.RelativeTime) {
		nw.RelativeTime = des.RelativeTime
	}
	if dcl.IsZeroValue(nw.SleepDuration) {
		nw.SleepDuration = des.SleepDuration
	}
	if dcl.IsZeroValue(nw.Action) {
		nw.Action = des.Action
	}
	nw.Status = canonicalizeNewInstancePreprocessReconcileRecipeStepsStatus(c, des.Status, nw.Status)
	if dcl.StringCanonicalize(des.ErrorSpace, nw.ErrorSpace) {
		nw.ErrorSpace = des.ErrorSpace
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}
	if dcl.IsZeroValue(nw.ResourceMetadataSize) {
		nw.ResourceMetadataSize = des.ResourceMetadataSize
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.UpdatedRepeatOperationDelaySec) {
		nw.UpdatedRepeatOperationDelaySec = des.UpdatedRepeatOperationDelaySec
	}
	nw.QuotaRequestDeltas = canonicalizeNewInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSlice(c, des.QuotaRequestDeltas, nw.QuotaRequestDeltas)
	nw.PreprocessUpdate = canonicalizeNewInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c, des.PreprocessUpdate, nw.PreprocessUpdate)
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}
	nw.RequestedTenantProject = canonicalizeNewInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c, des.RequestedTenantProject, nw.RequestedTenantProject)
	nw.PermissionsInfo = canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoSlice(c, des.PermissionsInfo, nw.PermissionsInfo)
	nw.KeyNotificationsUpdate = canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c, des.KeyNotificationsUpdate, nw.KeyNotificationsUpdate)
	if dcl.IsZeroValue(nw.ClhDataUpdateTime) {
		nw.ClhDataUpdateTime = des.ClhDataUpdateTime
	}
	if dcl.StringCanonicalize(des.PublicErrorMessage, nw.PublicErrorMessage) {
		nw.PublicErrorMessage = des.PublicErrorMessage
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsSet(c *Client, des, nw []InstancePreprocessReconcileRecipeSteps) []InstancePreprocessReconcileRecipeSteps {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeSteps
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeSteps) []InstancePreprocessReconcileRecipeSteps {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeSteps
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeSteps(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsStatus(des, initial *InstancePreprocessReconcileRecipeStepsStatus, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsStatus {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Code) {
		des.Code = initial.Code
	}
	if dcl.StringCanonicalize(des.Message, initial.Message) || dcl.IsZeroValue(des.Message) {
		des.Message = initial.Message
	}
	if dcl.IsZeroValue(des.Details) {
		des.Details = initial.Details
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsStatus(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsStatus) *InstancePreprocessReconcileRecipeStepsStatus {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Code) {
		nw.Code = des.Code
	}
	if dcl.StringCanonicalize(des.Message, nw.Message) {
		nw.Message = des.Message
	}
	nw.Details = canonicalizeNewInstancePreprocessReconcileRecipeStepsStatusDetailsSlice(c, des.Details, nw.Details)

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsStatusSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsStatus) []InstancePreprocessReconcileRecipeStepsStatus {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsStatus
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsStatusNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsStatusSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsStatus) []InstancePreprocessReconcileRecipeStepsStatus {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsStatus
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsStatus(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsStatusDetails(des, initial *InstancePreprocessReconcileRecipeStepsStatusDetails, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsStatusDetails {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.TypeUrl, initial.TypeUrl) || dcl.IsZeroValue(des.TypeUrl) {
		des.TypeUrl = initial.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, initial.Value) || dcl.IsZeroValue(des.Value) {
		des.Value = initial.Value
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsStatusDetails(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsStatusDetails) *InstancePreprocessReconcileRecipeStepsStatusDetails {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.TypeUrl, nw.TypeUrl) {
		nw.TypeUrl = des.TypeUrl
	}
	if dcl.StringCanonicalize(des.Value, nw.Value) {
		nw.Value = des.Value
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsStatusDetailsSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsStatusDetails) []InstancePreprocessReconcileRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsStatusDetails
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsStatusDetailsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsStatusDetailsSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsStatusDetails) []InstancePreprocessReconcileRecipeStepsStatusDetails {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsStatusDetails
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsStatusDetails(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(des, initial *InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.MetricName, initial.MetricName) || dcl.IsZeroValue(des.MetricName) {
		des.MetricName = initial.MetricName
	}
	if dcl.IsZeroValue(des.Amount) {
		des.Amount = initial.Amount
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas) *InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.MetricName, nw.MetricName) {
		nw.MetricName = des.MetricName
	}
	if dcl.IsZeroValue(nw.Amount) {
		nw.Amount = des.Amount
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas) []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas) []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsPreprocessUpdate(des, initial *InstancePreprocessReconcileRecipeStepsPreprocessUpdate, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsPreprocessUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, initial.LatencySloBucketName) || dcl.IsZeroValue(des.LatencySloBucketName) {
		des.LatencySloBucketName = initial.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, initial.PublicOperationMetadata) || dcl.IsZeroValue(des.PublicOperationMetadata) {
		des.PublicOperationMetadata = initial.PublicOperationMetadata
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsPreprocessUpdate) *InstancePreprocessReconcileRecipeStepsPreprocessUpdate {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.LatencySloBucketName, nw.LatencySloBucketName) {
		nw.LatencySloBucketName = des.LatencySloBucketName
	}
	if dcl.StringCanonicalize(des.PublicOperationMetadata, nw.PublicOperationMetadata) {
		nw.PublicOperationMetadata = des.PublicOperationMetadata
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPreprocessUpdateSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsPreprocessUpdate) []InstancePreprocessReconcileRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsPreprocessUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsPreprocessUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPreprocessUpdateSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsPreprocessUpdate) []InstancePreprocessReconcileRecipeStepsPreprocessUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsPreprocessUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsRequestedTenantProject(des, initial *InstancePreprocessReconcileRecipeStepsRequestedTenantProject, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsRequestedTenantProject {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Tag, initial.Tag) || dcl.IsZeroValue(des.Tag) {
		des.Tag = initial.Tag
	}
	if dcl.StringCanonicalize(des.Folder, initial.Folder) || dcl.IsZeroValue(des.Folder) {
		des.Folder = initial.Folder
	}
	if dcl.IsZeroValue(des.Scope) {
		des.Scope = initial.Scope
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsRequestedTenantProject) *InstancePreprocessReconcileRecipeStepsRequestedTenantProject {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Tag, nw.Tag) {
		nw.Tag = des.Tag
	}
	if dcl.StringCanonicalize(des.Folder, nw.Folder) {
		nw.Folder = des.Folder
	}
	if dcl.IsZeroValue(nw.Scope) {
		nw.Scope = des.Scope
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsRequestedTenantProjectSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsRequestedTenantProject) []InstancePreprocessReconcileRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsRequestedTenantProject
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsRequestedTenantProjectNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsRequestedTenantProjectSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsRequestedTenantProject) []InstancePreprocessReconcileRecipeStepsRequestedTenantProject {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsRequestedTenantProject
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsPermissionsInfo(des, initial *InstancePreprocessReconcileRecipeStepsPermissionsInfo, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsPermissionsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.PolicyName = canonicalizeInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(des.PolicyName, initial.PolicyName, opts...)
	if dcl.IsZeroValue(des.IamPermissions) {
		des.IamPermissions = initial.IamPermissions
	}
	if dcl.StringCanonicalize(des.ResourcePath, initial.ResourcePath) || dcl.IsZeroValue(des.ResourcePath) {
		des.ResourcePath = initial.ResourcePath
	}
	des.ApiAttrs = canonicalizeInstanceGoogleprotobufstruct(des.ApiAttrs, initial.ApiAttrs, opts...)

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfo(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsPermissionsInfo) *InstancePreprocessReconcileRecipeStepsPermissionsInfo {
	if des == nil || nw == nil {
		return nw
	}

	nw.PolicyName = canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c, des.PolicyName, nw.PolicyName)
	nw.IamPermissions = canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c, des.IamPermissions, nw.IamPermissions)
	if dcl.StringCanonicalize(des.ResourcePath, nw.ResourcePath) {
		nw.ResourcePath = des.ResourcePath
	}
	nw.ApiAttrs = canonicalizeNewInstanceGoogleprotobufstruct(c, des.ApiAttrs, nw.ApiAttrs)

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsPermissionsInfo) []InstancePreprocessReconcileRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsPermissionsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsPermissionsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsPermissionsInfo) []InstancePreprocessReconcileRecipeStepsPermissionsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsPermissionsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(des, initial *InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Type, initial.Type) || dcl.IsZeroValue(des.Type) {
		des.Type = initial.Type
	}
	if dcl.StringCanonicalize(des.Id, initial.Id) || dcl.IsZeroValue(des.Id) {
		des.Id = initial.Id
	}
	if dcl.StringCanonicalize(des.Region, initial.Region) || dcl.IsZeroValue(des.Region) {
		des.Region = initial.Region
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName) *InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Type, nw.Type) {
		nw.Type = des.Type
	}
	if dcl.StringCanonicalize(des.Id, nw.Id) {
		nw.Id = des.Id
	}
	if dcl.StringCanonicalize(des.Region, nw.Region) {
		nw.Region = des.Region
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName) []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(des, initial *InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.Permission, initial.Permission) || dcl.IsZeroValue(des.Permission) {
		des.Permission = initial.Permission
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions) *InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.Permission, nw.Permission) {
		nw.Permission = des.Permission
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions) []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(des, initial *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	des.KeyNotificationsInfo = canonicalizeInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des.KeyNotificationsInfo, initial.KeyNotificationsInfo, opts...)

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate {
	if des == nil || nw == nil {
		return nw
	}

	nw.KeyNotificationsInfo = canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, des.KeyNotificationsInfo, nw.KeyNotificationsInfo)

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(des, initial *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.DataVersion) {
		des.DataVersion = initial.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, initial.Delegate) || dcl.IsZeroValue(des.Delegate) {
		des.Delegate = initial.Delegate
	}
	if dcl.IsZeroValue(des.KeyNotificationConfigs) {
		des.KeyNotificationConfigs = initial.KeyNotificationConfigs
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.DataVersion) {
		nw.DataVersion = des.DataVersion
	}
	if dcl.StringCanonicalize(des.Delegate, nw.Delegate) {
		nw.Delegate = des.Delegate
	}
	nw.KeyNotificationConfigs = canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, des.KeyNotificationConfigs, nw.KeyNotificationConfigs)

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &d, &n))
	}

	return items
}

func canonicalizeInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(des, initial *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, opts ...dcl.ApplyOption) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, initial.KeyOrVersionName) || dcl.IsZeroValue(des.KeyOrVersionName) {
		des.KeyOrVersionName = initial.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, initial.Grant) || dcl.IsZeroValue(des.Grant) {
		des.Grant = initial.Grant
	}
	if dcl.IsZeroValue(des.DelegatorGaiaId) {
		des.DelegatorGaiaId = initial.DelegatorGaiaId
	}

	return des
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, des, nw *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.StringCanonicalize(des.KeyOrVersionName, nw.KeyOrVersionName) {
		nw.KeyOrVersionName = des.KeyOrVersionName
	}
	if dcl.StringCanonicalize(des.Grant, nw.Grant) {
		nw.Grant = des.Grant
	}
	if dcl.IsZeroValue(nw.DelegatorGaiaId) {
		nw.DelegatorGaiaId = des.DelegatorGaiaId
	}

	return nw
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSet(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}
	var reorderedNew []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, des, nw []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &d, &n))
	}

	return items
}

func canonicalizeInstanceHistory(des, initial *InstanceHistory, opts ...dcl.ApplyOption) *InstanceHistory {
	if des == nil {
		return initial
	}
	if des.empty {
		return des
	}

	if initial == nil {
		return des
	}

	if dcl.IsZeroValue(des.Timestamp) {
		des.Timestamp = initial.Timestamp
	}
	if dcl.StringCanonicalize(des.OperationHandle, initial.OperationHandle) || dcl.IsZeroValue(des.OperationHandle) {
		des.OperationHandle = initial.OperationHandle
	}
	if dcl.StringCanonicalize(des.Description, initial.Description) || dcl.IsZeroValue(des.Description) {
		des.Description = initial.Description
	}
	if dcl.IsZeroValue(des.StepIndex) {
		des.StepIndex = initial.StepIndex
	}
	if dcl.IsZeroValue(des.TenantProjectNumber) {
		des.TenantProjectNumber = initial.TenantProjectNumber
	}
	if dcl.StringCanonicalize(des.TenantProjectId, initial.TenantProjectId) || dcl.IsZeroValue(des.TenantProjectId) {
		des.TenantProjectId = initial.TenantProjectId
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, initial.P4ServiceAccount) || dcl.IsZeroValue(des.P4ServiceAccount) {
		des.P4ServiceAccount = initial.P4ServiceAccount
	}

	return des
}

func canonicalizeNewInstanceHistory(c *Client, des, nw *InstanceHistory) *InstanceHistory {
	if des == nil || nw == nil {
		return nw
	}

	if dcl.IsZeroValue(nw.Timestamp) {
		nw.Timestamp = des.Timestamp
	}
	if dcl.StringCanonicalize(des.OperationHandle, nw.OperationHandle) {
		nw.OperationHandle = des.OperationHandle
	}
	if dcl.StringCanonicalize(des.Description, nw.Description) {
		nw.Description = des.Description
	}
	if dcl.IsZeroValue(nw.StepIndex) {
		nw.StepIndex = des.StepIndex
	}
	if dcl.IsZeroValue(nw.TenantProjectNumber) {
		nw.TenantProjectNumber = des.TenantProjectNumber
	}
	if dcl.StringCanonicalize(des.TenantProjectId, nw.TenantProjectId) {
		nw.TenantProjectId = des.TenantProjectId
	}
	if dcl.StringCanonicalize(des.P4ServiceAccount, nw.P4ServiceAccount) {
		nw.P4ServiceAccount = des.P4ServiceAccount
	}

	return nw
}

func canonicalizeNewInstanceHistorySet(c *Client, des, nw []InstanceHistory) []InstanceHistory {
	if des == nil {
		return nw
	}
	var reorderedNew []InstanceHistory
	for _, d := range des {
		matchedNew := -1
		for idx, n := range nw {
			if diffs, _ := compareInstanceHistoryNewStyle(&d, &n, dcl.FieldName{}); len(diffs) == 0 {
				matchedNew = idx
				break
			}
		}
		if matchedNew != -1 {
			reorderedNew = append(reorderedNew, nw[matchedNew])
			nw = append(nw[:matchedNew], nw[matchedNew+1:]...)
		}
	}
	reorderedNew = append(reorderedNew, nw...)

	return reorderedNew
}

func canonicalizeNewInstanceHistorySlice(c *Client, des, nw []InstanceHistory) []InstanceHistory {
	if des == nil {
		return nw
	}

	// Lengths are unequal. A diff will occur later, so we shouldn't canonicalize.
	// Return the original array.
	if len(des) != len(nw) {
		return nw
	}

	var items []InstanceHistory
	for i, d := range des {
		n := nw[i]
		items = append(items, *canonicalizeNewInstanceHistory(c, &d, &n))
	}

	return items
}

// The differ returns a list of diffs, along with a list of operations that should be taken
// to remedy them. Right now, it does not attempt to consolidate operations - if several
// fields can be fixed with a patch update, it will perform the patch several times.
// Diffs on some fields will be ignored if the `desired` state has an empty (nil)
// value. This empty value indicates that the user does not care about the state for
// the field. Empty fields on the actual object will cause diffs.
// TODO(magic-modules-eng): for efficiency in some resources, add batching.
func diffInstance(c *Client, desired, actual *Instance, opts ...dcl.ApplyOption) ([]*dcl.FieldDiff, error) {
	if desired == nil || actual == nil {
		return nil, fmt.Errorf("nil resource passed to diff - always a programming error: %#v, %#v", desired, actual)
	}

	var fn dcl.FieldName
	var newDiffs []*dcl.FieldDiff
	// New style diffs.
	if ds, err := dcl.Diff(desired.Name, actual.Name, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Name")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DisplayName, actual.DisplayName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DisplayName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Labels, actual.Labels, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Labels")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Zone, actual.Zone, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Zone")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.AlternativeZone, actual.AlternativeZone, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("AlternativeZone")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Sku, actual.Sku, dcl.Info{ObjectFunction: compareInstanceSkuNewStyle, EmptyObject: EmptyInstanceSku, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Sku")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.AuthorizedNetworkId, actual.AuthorizedNetworkId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("AuthorizedNetworkId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReservedIPRange, actual.ReservedIPRange, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReservedIpRange")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Host, actual.Host, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Host")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Port, actual.Port, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Port")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CurrentZone, actual.CurrentZone, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("CurrentZone")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CreateTime, actual.CreateTime, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("CreateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.State, actual.State, dcl.Info{OutputOnly: true, Type: "EnumType", OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("State")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.StatusMessage, actual.StatusMessage, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("StatusMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdateTime, actual.UpdateTime, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("UpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.MutateUserId, actual.MutateUserId, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("MutateUserId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadUserId, actual.ReadUserId, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("ReadUserId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.References, actual.References, dcl.Info{ObjectFunction: compareInstanceReferencesNewStyle, EmptyObject: EmptyInstanceReferences, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("References")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessCreateRecipe, actual.PreprocessCreateRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessCreateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CreateRecipe, actual.CreateRecipe, dcl.Info{ObjectFunction: compareInstanceCreateRecipeNewStyle, EmptyObject: EmptyInstanceCreateRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("CreateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DeleteRecipe, actual.DeleteRecipe, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeNewStyle, EmptyObject: EmptyInstanceDeleteRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DeleteRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdateRecipe, actual.UpdateRecipe, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeNewStyle, EmptyObject: EmptyInstanceUpdateRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessResetRecipe, actual.PreprocessResetRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessResetRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResetRecipe, actual.ResetRecipe, dcl.Info{ObjectFunction: compareInstanceResetRecipeNewStyle, EmptyObject: EmptyInstanceResetRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResetRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessRepairRecipe, actual.PreprocessRepairRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessRepairRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RepairRecipe, actual.RepairRecipe, dcl.Info{ObjectFunction: compareInstanceRepairRecipeNewStyle, EmptyObject: EmptyInstanceRepairRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RepairRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessDeleteRecipe, actual.PreprocessDeleteRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessDeleteRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdateRecipe, actual.PreprocessUpdateRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdateRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessFreezeRecipe, actual.PreprocessFreezeRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessFreezeRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.FreezeRecipe, actual.FreezeRecipe, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeNewStyle, EmptyObject: EmptyInstanceFreezeRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("FreezeRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUnfreezeRecipe, actual.PreprocessUnfreezeRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUnfreezeRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UnfreezeRecipe, actual.UnfreezeRecipe, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UnfreezeRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessReportInstanceHealthRecipe, actual.PreprocessReportInstanceHealthRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessReportInstanceHealthRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReportInstanceHealthRecipe, actual.ReportInstanceHealthRecipe, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReportInstanceHealthRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessGetRecipe, actual.PreprocessGetRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessGetRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NotifyKeyAvailableRecipe, actual.NotifyKeyAvailableRecipe, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("NotifyKeyAvailableRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.NotifyKeyUnavailableRecipe, actual.NotifyKeyUnavailableRecipe, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("NotifyKeyUnavailableRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipe, actual.ReadonlyRecipe, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeNewStyle, EmptyObject: EmptyInstanceReadonlyRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReconcileRecipe, actual.ReconcileRecipe, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeNewStyle, EmptyObject: EmptyInstanceReconcileRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReconcileRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessPassthroughRecipe, actual.PreprocessPassthroughRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessPassthroughRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessReconcileRecipe, actual.PreprocessReconcileRecipe, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipe, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessReconcileRecipe")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.EnableCallHistory, actual.EnableCallHistory, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("EnableCallHistory")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.History, actual.History, dcl.Info{ObjectFunction: compareInstanceHistoryNewStyle, EmptyObject: EmptyInstanceHistory, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("History")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicResourceViewOverride, actual.PublicResourceViewOverride, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicResourceViewOverride")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ExtraInfo, actual.ExtraInfo, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("ExtraInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Uid, actual.Uid, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Uid")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Etag, actual.Etag, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Etag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Project, actual.Project, dcl.Info{OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Project")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Location, actual.Location, dcl.Info{OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Location")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		newDiffs = append(newDiffs, ds...)
	}

	return newDiffs, nil
}
func compareInstanceSkuNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceSku)
	if !ok {
		desiredNotPointer, ok := d.(InstanceSku)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceSku or *InstanceSku", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceSku)
	if !ok {
		actualNotPointer, ok := a.(InstanceSku)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceSku", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tier, actual.Tier, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tier")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Size, actual.Size, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Size")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReferencesNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReferences)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReferences)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReferences or *InstanceReferences", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReferences)
	if !ok {
		actualNotPointer, ok := a.(InstanceReferences)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReferences", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Name, actual.Name, dcl.Info{OutputOnly: true, Type: "ReferenceType", OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("Name")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SourceResource, actual.SourceResource, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SourceResource")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceReferencesDetailsNewStyle, EmptyObject: EmptyInstanceReferencesDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.CreateTime, actual.CreateTime, dcl.Info{OutputOnly: true, OperationSelector: dcl.RequiresRecreate()}, fn.AddNest("CreateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReferencesDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReferencesDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReferencesDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReferencesDetails or *InstanceReferencesDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReferencesDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceReferencesDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReferencesDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipe or *InstancePreprocessCreateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeSteps or *InstancePreprocessCreateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsStatus or *InstancePreprocessCreateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsStatusDetails or *InstancePreprocessCreateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsQuotaRequestDeltas or *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPreprocessUpdate or *InstancePreprocessCreateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsRequestedTenantProject or *InstancePreprocessCreateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfo or *InstancePreprocessCreateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceGoogleprotobufstructNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate or *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipe or *InstanceCreateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsNewStyle, EmptyObject: EmptyInstanceCreateRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeSteps or *InstanceCreateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsStatus or *InstanceCreateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsStatusDetails or *InstanceCreateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsQuotaRequestDeltas or *InstanceCreateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPreprocessUpdate or *InstanceCreateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsRequestedTenantProject or *InstanceCreateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfo or *InstanceCreateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfoPolicyName or *InstanceCreateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfoIamPermissions or *InstanceCreateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdate or *InstanceCreateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipe or *InstanceDeleteRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsNewStyle, EmptyObject: EmptyInstanceDeleteRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeSteps or *InstanceDeleteRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsStatus or *InstanceDeleteRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsStatusDetails or *InstanceDeleteRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsQuotaRequestDeltas or *InstanceDeleteRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPreprocessUpdate or *InstanceDeleteRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsRequestedTenantProject or *InstanceDeleteRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfo or *InstanceDeleteRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfoPolicyName or *InstanceDeleteRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfoIamPermissions or *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdate or *InstanceDeleteRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipe or *InstanceUpdateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsNewStyle, EmptyObject: EmptyInstanceUpdateRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeSteps or *InstanceUpdateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsStatus or *InstanceUpdateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsStatusDetails or *InstanceUpdateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsQuotaRequestDeltas or *InstanceUpdateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPreprocessUpdate or *InstanceUpdateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsRequestedTenantProject or *InstanceUpdateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfo or *InstanceUpdateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfoPolicyName or *InstanceUpdateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfoIamPermissions or *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdate or *InstanceUpdateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipe or *InstancePreprocessResetRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeSteps or *InstancePreprocessResetRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsStatus or *InstancePreprocessResetRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsStatusDetails or *InstancePreprocessResetRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsQuotaRequestDeltas or *InstancePreprocessResetRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPreprocessUpdate or *InstancePreprocessResetRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsRequestedTenantProject or *InstancePreprocessResetRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfo or *InstancePreprocessResetRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdate or *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipe or *InstanceResetRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsNewStyle, EmptyObject: EmptyInstanceResetRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeSteps or *InstanceResetRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsStatus or *InstanceResetRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsStatusDetails or *InstanceResetRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsQuotaRequestDeltas or *InstanceResetRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPreprocessUpdate or *InstanceResetRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsRequestedTenantProject or *InstanceResetRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfo or *InstanceResetRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfoPolicyName or *InstanceResetRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfoIamPermissions or *InstanceResetRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdate or *InstanceResetRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipe or *InstancePreprocessRepairRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeSteps or *InstancePreprocessRepairRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsStatus or *InstancePreprocessRepairRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsStatusDetails or *InstancePreprocessRepairRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsQuotaRequestDeltas or *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPreprocessUpdate or *InstancePreprocessRepairRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsRequestedTenantProject or *InstancePreprocessRepairRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfo or *InstancePreprocessRepairRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate or *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipe or *InstanceRepairRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsNewStyle, EmptyObject: EmptyInstanceRepairRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeSteps or *InstanceRepairRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsStatus or *InstanceRepairRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsStatusDetails or *InstanceRepairRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsQuotaRequestDeltas or *InstanceRepairRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPreprocessUpdate or *InstanceRepairRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsRequestedTenantProject or *InstanceRepairRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfo or *InstanceRepairRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfoPolicyName or *InstanceRepairRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfoIamPermissions or *InstanceRepairRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdate or *InstanceRepairRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipe or *InstancePreprocessDeleteRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeSteps or *InstancePreprocessDeleteRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsStatus or *InstancePreprocessDeleteRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsStatusDetails or *InstancePreprocessDeleteRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas or *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPreprocessUpdate or *InstancePreprocessDeleteRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsRequestedTenantProject or *InstancePreprocessDeleteRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfo or *InstancePreprocessDeleteRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate or *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipe or *InstancePreprocessUpdateRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeSteps or *InstancePreprocessUpdateRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsStatus or *InstancePreprocessUpdateRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsStatusDetails or *InstancePreprocessUpdateRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas or *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPreprocessUpdate or *InstancePreprocessUpdateRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsRequestedTenantProject or *InstancePreprocessUpdateRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfo or *InstancePreprocessUpdateRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate or *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipe or *InstancePreprocessFreezeRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeSteps or *InstancePreprocessFreezeRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsStatus or *InstancePreprocessFreezeRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsStatusDetails or *InstancePreprocessFreezeRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas or *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPreprocessUpdate or *InstancePreprocessFreezeRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsRequestedTenantProject or *InstancePreprocessFreezeRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfo or *InstancePreprocessFreezeRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate or *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipe or *InstanceFreezeRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsNewStyle, EmptyObject: EmptyInstanceFreezeRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeSteps or *InstanceFreezeRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsStatus or *InstanceFreezeRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsStatusDetails or *InstanceFreezeRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsQuotaRequestDeltas or *InstanceFreezeRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPreprocessUpdate or *InstanceFreezeRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsRequestedTenantProject or *InstanceFreezeRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfo or *InstanceFreezeRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfoPolicyName or *InstanceFreezeRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfoIamPermissions or *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdate or *InstanceFreezeRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipe or *InstancePreprocessUnfreezeRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeSteps or *InstancePreprocessUnfreezeRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsStatus or *InstancePreprocessUnfreezeRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsStatusDetails or *InstancePreprocessUnfreezeRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas or *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate or *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject or *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfo or *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate or *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipe or *InstanceUnfreezeRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeSteps or *InstanceUnfreezeRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsStatus or *InstanceUnfreezeRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsStatusDetails or *InstanceUnfreezeRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsQuotaRequestDeltas or *InstanceUnfreezeRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPreprocessUpdate or *InstanceUnfreezeRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsRequestedTenantProject or *InstanceUnfreezeRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfo or *InstanceUnfreezeRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName or *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions or *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdate or *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipe or *InstancePreprocessReportInstanceHealthRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeSteps or *InstancePreprocessReportInstanceHealthRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsStatus or *InstancePreprocessReportInstanceHealthRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails or *InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas or *InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate or *InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject or *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo or *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate or *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipe or *InstanceReportInstanceHealthRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeSteps or *InstanceReportInstanceHealthRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsStatus or *InstanceReportInstanceHealthRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsStatusDetails or *InstanceReportInstanceHealthRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas or *InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsPreprocessUpdate or *InstanceReportInstanceHealthRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsRequestedTenantProject or *InstanceReportInstanceHealthRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsPermissionsInfo or *InstanceReportInstanceHealthRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName or *InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions or *InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate or *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipe or *InstancePreprocessGetRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeSteps or *InstancePreprocessGetRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsStatus or *InstancePreprocessGetRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsStatusDetails or *InstancePreprocessGetRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsQuotaRequestDeltas or *InstancePreprocessGetRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsPreprocessUpdate or *InstancePreprocessGetRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsRequestedTenantProject or *InstancePreprocessGetRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsPermissionsInfo or *InstancePreprocessGetRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsKeyNotificationsUpdate or *InstancePreprocessGetRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipe or *InstanceNotifyKeyAvailableRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeSteps or *InstanceNotifyKeyAvailableRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsStatus or *InstanceNotifyKeyAvailableRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsStatusDetails or *InstanceNotifyKeyAvailableRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas or *InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate or *InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject or *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo or *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName or *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions or *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate or *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipe or *InstanceNotifyKeyUnavailableRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeSteps or *InstanceNotifyKeyUnavailableRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsStatus or *InstanceNotifyKeyUnavailableRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsStatusDetails or *InstanceNotifyKeyUnavailableRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas or *InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate or *InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject or *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo or *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName or *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions or *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate or *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipe or *InstanceReadonlyRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeSteps or *InstanceReadonlyRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsStatus or *InstanceReadonlyRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsStatusDetails or *InstanceReadonlyRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsQuotaRequestDeltas or *InstanceReadonlyRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPreprocessUpdate or *InstanceReadonlyRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsRequestedTenantProject or *InstanceReadonlyRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfo or *InstanceReadonlyRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfoPolicyName or *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions or *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdate or *InstanceReadonlyRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipe or *InstanceReconcileRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsNewStyle, EmptyObject: EmptyInstanceReconcileRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeSteps or *InstanceReconcileRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsStatusNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsStatus or *InstanceReconcileRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsStatusDetails or *InstanceReconcileRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsQuotaRequestDeltas or *InstanceReconcileRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsPreprocessUpdate or *InstanceReconcileRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsRequestedTenantProject or *InstanceReconcileRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsPermissionsInfo or *InstanceReconcileRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsPermissionsInfoPolicyName or *InstanceReconcileRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsPermissionsInfoIamPermissions or *InstanceReconcileRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsKeyNotificationsUpdate or *InstanceReconcileRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipe or *InstancePreprocessPassthroughRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeSteps or *InstancePreprocessPassthroughRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsStatus or *InstancePreprocessPassthroughRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsStatusDetails or *InstancePreprocessPassthroughRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas or *InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsPreprocessUpdate or *InstancePreprocessPassthroughRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsRequestedTenantProject or *InstancePreprocessPassthroughRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsPermissionsInfo or *InstancePreprocessPassthroughRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate or *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipe)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipe or *InstancePreprocessReconcileRecipe", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipe)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipe)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipe", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Steps, actual.Steps, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeSteps, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Steps")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.HonorCancelRequest, actual.HonorCancelRequest, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("HonorCancelRequest")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IgnoreRecipeAfter, actual.IgnoreRecipeAfter, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IgnoreRecipeAfter")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.VerifyDeadlineSecondsBelow, actual.VerifyDeadlineSecondsBelow, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("VerifyDeadlineSecondsBelow")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PopulateOperationResult, actual.PopulateOperationResult, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PopulateOperationResult")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ReadonlyRecipeStartTime, actual.ReadonlyRecipeStartTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ReadonlyRecipeStartTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceNamesStoredInClhWithDelay, actual.ResourceNamesStoredInClhWithDelay, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceNamesStoredInClhWithDelay")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelayToStoreResourcesInClhDbNanos, actual.DelayToStoreResourcesInClhDbNanos, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelayToStoreResourcesInClhDbNanos")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeSteps)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeSteps or *InstancePreprocessReconcileRecipeSteps", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeSteps)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeSteps)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeSteps", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.RelativeTime, actual.RelativeTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RelativeTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.SleepDuration, actual.SleepDuration, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("SleepDuration")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Action, actual.Action, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Action")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Status, actual.Status, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsStatusNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsStatus, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Status")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ErrorSpace, actual.ErrorSpace, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ErrorSpace")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourceMetadataSize, actual.ResourceMetadataSize, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourceMetadataSize")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.UpdatedRepeatOperationDelaySec, actual.UpdatedRepeatOperationDelaySec, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("UpdatedRepeatOperationDelaySec")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.QuotaRequestDeltas, actual.QuotaRequestDeltas, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("QuotaRequestDeltas")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PreprocessUpdate, actual.PreprocessUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsPreprocessUpdateNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsPreprocessUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PreprocessUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.RequestedTenantProject, actual.RequestedTenantProject, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsRequestedTenantProjectNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsRequestedTenantProject, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("RequestedTenantProject")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PermissionsInfo, actual.PermissionsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsPermissionsInfoNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsPermissionsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PermissionsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsUpdate, actual.KeyNotificationsUpdate, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsUpdate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ClhDataUpdateTime, actual.ClhDataUpdateTime, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ClhDataUpdateTime")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicErrorMessage, actual.PublicErrorMessage, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicErrorMessage")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsStatusNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsStatus)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsStatus or *InstancePreprocessReconcileRecipeStepsStatus", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsStatus)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsStatus)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsStatus", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Code, actual.Code, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Code")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Message, actual.Message, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Message")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Details, actual.Details, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsStatusDetailsNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsStatusDetails, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Details")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsStatusDetailsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsStatusDetails)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsStatusDetails or *InstancePreprocessReconcileRecipeStepsStatusDetails", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsStatusDetails)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsStatusDetails)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsStatusDetails", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.TypeUrl, actual.TypeUrl, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TypeUrl")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Value, actual.Value, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Value")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas or *InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.MetricName, actual.MetricName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("MetricName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Amount, actual.Amount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Amount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsPreprocessUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsPreprocessUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsPreprocessUpdate or *InstancePreprocessReconcileRecipeStepsPreprocessUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsPreprocessUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsPreprocessUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsPreprocessUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.LatencySloBucketName, actual.LatencySloBucketName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("LatencySloBucketName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.PublicOperationMetadata, actual.PublicOperationMetadata, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PublicOperationMetadata")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsRequestedTenantProjectNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsRequestedTenantProject)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsRequestedTenantProject or *InstancePreprocessReconcileRecipeStepsRequestedTenantProject", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsRequestedTenantProject)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsRequestedTenantProject)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsRequestedTenantProject", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Tag, actual.Tag, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Tag")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Folder, actual.Folder, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Folder")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Scope, actual.Scope, dcl.Info{Type: "EnumType", OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Scope")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsPermissionsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsPermissionsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsPermissionsInfo or *InstancePreprocessReconcileRecipeStepsPermissionsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsPermissionsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsPermissionsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsPermissionsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.PolicyName, actual.PolicyName, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("PolicyName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.IamPermissions, actual.IamPermissions, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("IamPermissions")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ResourcePath, actual.ResourcePath, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ResourcePath")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.ApiAttrs, actual.ApiAttrs, dcl.Info{ObjectFunction: compareInstanceGoogleprotobufstructNewStyle, EmptyObject: EmptyInstanceGoogleprotobufstruct, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("ApiAttrs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName or *InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Type, actual.Type, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Type")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Id, actual.Id, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Id")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Region, actual.Region, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Region")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions or *InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Permission, actual.Permission, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Permission")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate or *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyNotificationsInfo, actual.KeyNotificationsInfo, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationsInfo")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo or *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.DataVersion, actual.DataVersion, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DataVersion")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Delegate, actual.Delegate, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Delegate")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.KeyNotificationConfigs, actual.KeyNotificationConfigs, dcl.Info{ObjectFunction: compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle, EmptyObject: EmptyInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyNotificationConfigs")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		desiredNotPointer, ok := d.(InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs or *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	if !ok {
		actualNotPointer, ok := a.(InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.KeyOrVersionName, actual.KeyOrVersionName, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("KeyOrVersionName")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Grant, actual.Grant, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Grant")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.DelegatorGaiaId, actual.DelegatorGaiaId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("DelegatorGaiaId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

func compareInstanceHistoryNewStyle(d, a interface{}, fn dcl.FieldName) ([]*dcl.FieldDiff, error) {
	var diffs []*dcl.FieldDiff

	desired, ok := d.(*InstanceHistory)
	if !ok {
		desiredNotPointer, ok := d.(InstanceHistory)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceHistory or *InstanceHistory", d)
		}
		desired = &desiredNotPointer
	}
	actual, ok := a.(*InstanceHistory)
	if !ok {
		actualNotPointer, ok := a.(InstanceHistory)
		if !ok {
			return nil, fmt.Errorf("obj %v is not a InstanceHistory", a)
		}
		actual = &actualNotPointer
	}

	if ds, err := dcl.Diff(desired.Timestamp, actual.Timestamp, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Timestamp")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.OperationHandle, actual.OperationHandle, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("OperationHandle")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.Description, actual.Description, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("Description")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.StepIndex, actual.StepIndex, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("StepIndex")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TenantProjectNumber, actual.TenantProjectNumber, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TenantProjectNumber")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.TenantProjectId, actual.TenantProjectId, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("TenantProjectId")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}

	if ds, err := dcl.Diff(desired.P4ServiceAccount, actual.P4ServiceAccount, dcl.Info{OperationSelector: dcl.TriggersOperation("updateInstanceUpdateInstanceOperation")}, fn.AddNest("P4ServiceAccount")); len(ds) != 0 || err != nil {
		if err != nil {
			return nil, err
		}
		diffs = append(diffs, ds...)
	}
	return diffs, nil
}

// urlNormalized returns a copy of the resource struct with values normalized
// for URL substitutions. For instance, it converts long-form self-links to
// short-form so they can be substituted in.
func (r *Instance) urlNormalized() *Instance {
	normalized := dcl.Copy(*r).(Instance)
	normalized.Name = dcl.SelfLinkToName(r.Name)
	normalized.DisplayName = dcl.SelfLinkToName(r.DisplayName)
	normalized.Zone = dcl.SelfLinkToName(r.Zone)
	normalized.AlternativeZone = dcl.SelfLinkToName(r.AlternativeZone)
	normalized.AuthorizedNetworkId = dcl.SelfLinkToName(r.AuthorizedNetworkId)
	normalized.ReservedIPRange = dcl.SelfLinkToName(r.ReservedIPRange)
	normalized.Host = dcl.SelfLinkToName(r.Host)
	normalized.CurrentZone = dcl.SelfLinkToName(r.CurrentZone)
	normalized.StatusMessage = dcl.SelfLinkToName(r.StatusMessage)
	normalized.PublicResourceViewOverride = dcl.SelfLinkToName(r.PublicResourceViewOverride)
	normalized.ExtraInfo = dcl.SelfLinkToName(r.ExtraInfo)
	normalized.Uid = dcl.SelfLinkToName(r.Uid)
	normalized.Etag = dcl.SelfLinkToName(r.Etag)
	normalized.Project = dcl.SelfLinkToName(r.Project)
	normalized.Location = dcl.SelfLinkToName(r.Location)
	return &normalized
}

func (r *Instance) getFields() (string, string, string) {
	n := r.urlNormalized()
	return dcl.ValueOrEmptyString(n.Project), dcl.ValueOrEmptyString(n.Location), dcl.ValueOrEmptyString(n.Name)
}

func (r *Instance) createFields() (string, string, string) {
	n := r.urlNormalized()
	return dcl.ValueOrEmptyString(n.Project), dcl.ValueOrEmptyString(n.Location), dcl.ValueOrEmptyString(n.Name)
}

func (r *Instance) deleteFields() (string, string, string) {
	n := r.urlNormalized()
	return dcl.ValueOrEmptyString(n.Project), dcl.ValueOrEmptyString(n.Location), dcl.ValueOrEmptyString(n.Name)
}

func (r *Instance) updateURL(userBasePath, updateName string) (string, error) {
	n := r.urlNormalized()
	if updateName == "UpdateInstance" {
		fields := map[string]interface{}{
			"project":  dcl.ValueOrEmptyString(n.Project),
			"location": dcl.ValueOrEmptyString(n.Location),
			"name":     dcl.ValueOrEmptyString(n.Name),
		}
		return dcl.URL("projects/{{project}}/locations/{{location}}/instances/{{name}}", "https://arcus2tier2.sandbox.googleapis.com/v1alpha1/", userBasePath, fields), nil

	}
	return "", fmt.Errorf("unknown update name: %s", updateName)
}

// marshal encodes the Instance resource into JSON for a Create request, and
// performs transformations from the resource schema to the API schema if
// necessary.
func (r *Instance) marshal(c *Client) ([]byte, error) {
	m, err := expandInstance(c, r)
	if err != nil {
		return nil, fmt.Errorf("error marshalling Instance: %w", err)
	}

	return json.Marshal(m)
}

// unmarshalInstance decodes JSON responses into the Instance resource schema.
func unmarshalInstance(b []byte, c *Client) (*Instance, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return unmarshalMapInstance(m, c)
}

func unmarshalMapInstance(m map[string]interface{}, c *Client) (*Instance, error) {

	return flattenInstance(c, m), nil
}

// expandInstance expands Instance into a JSON request object.
func expandInstance(c *Client, f *Instance) (map[string]interface{}, error) {
	m := make(map[string]interface{})
	if v, err := dcl.DeriveField("projects/%s/locations/%s/instances/%s", f.Name, f.Project, f.Location, f.Name); err != nil {
		return nil, fmt.Errorf("error expanding Name into name: %w", err)
	} else if v != nil {
		m["name"] = v
	}
	if v := f.DisplayName; !dcl.IsEmptyValueIndirect(v) {
		m["displayName"] = v
	}
	if v := f.Labels; !dcl.IsEmptyValueIndirect(v) {
		m["labels"] = v
	}
	if v := f.Zone; !dcl.IsEmptyValueIndirect(v) {
		m["zone"] = v
	}
	if v := f.AlternativeZone; !dcl.IsEmptyValueIndirect(v) {
		m["alternativeZone"] = v
	}
	if v, err := expandInstanceSku(c, f.Sku); err != nil {
		return nil, fmt.Errorf("error expanding Sku into sku: %w", err)
	} else if v != nil {
		m["sku"] = v
	}
	if v := f.AuthorizedNetworkId; !dcl.IsEmptyValueIndirect(v) {
		m["authorizedNetworkId"] = v
	}
	if v := f.ReservedIPRange; !dcl.IsEmptyValueIndirect(v) {
		m["reservedIpRange"] = v
	}
	if v := f.Host; !dcl.IsEmptyValueIndirect(v) {
		m["host"] = v
	}
	if v := f.Port; !dcl.IsEmptyValueIndirect(v) {
		m["port"] = v
	}
	if v := f.CurrentZone; !dcl.IsEmptyValueIndirect(v) {
		m["currentZone"] = v
	}
	if v := f.CreateTime; !dcl.IsEmptyValueIndirect(v) {
		m["createTime"] = v
	}
	if v := f.State; !dcl.IsEmptyValueIndirect(v) {
		m["state"] = v
	}
	if v := f.StatusMessage; !dcl.IsEmptyValueIndirect(v) {
		m["statusMessage"] = v
	}
	if v := f.UpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["updateTime"] = v
	}
	if v := f.MutateUserId; !dcl.IsEmptyValueIndirect(v) {
		m["mutateUserId"] = v
	}
	if v := f.ReadUserId; !dcl.IsEmptyValueIndirect(v) {
		m["readUserId"] = v
	}
	if v, err := expandInstanceReferencesSlice(c, f.References); err != nil {
		return nil, fmt.Errorf("error expanding References into references: %w", err)
	} else if v != nil {
		m["references"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipe(c, f.PreprocessCreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessCreateRecipe into preprocessCreateRecipe: %w", err)
	} else if v != nil {
		m["preprocessCreateRecipe"] = v
	}
	if v, err := expandInstanceCreateRecipe(c, f.CreateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding CreateRecipe into createRecipe: %w", err)
	} else if v != nil {
		m["createRecipe"] = v
	}
	if v, err := expandInstanceDeleteRecipe(c, f.DeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding DeleteRecipe into deleteRecipe: %w", err)
	} else if v != nil {
		m["deleteRecipe"] = v
	}
	if v, err := expandInstanceUpdateRecipe(c, f.UpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding UpdateRecipe into updateRecipe: %w", err)
	} else if v != nil {
		m["updateRecipe"] = v
	}
	if v, err := expandInstancePreprocessResetRecipe(c, f.PreprocessResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessResetRecipe into preprocessResetRecipe: %w", err)
	} else if v != nil {
		m["preprocessResetRecipe"] = v
	}
	if v, err := expandInstanceResetRecipe(c, f.ResetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ResetRecipe into resetRecipe: %w", err)
	} else if v != nil {
		m["resetRecipe"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipe(c, f.PreprocessRepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessRepairRecipe into preprocessRepairRecipe: %w", err)
	} else if v != nil {
		m["preprocessRepairRecipe"] = v
	}
	if v, err := expandInstanceRepairRecipe(c, f.RepairRecipe); err != nil {
		return nil, fmt.Errorf("error expanding RepairRecipe into repairRecipe: %w", err)
	} else if v != nil {
		m["repairRecipe"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipe(c, f.PreprocessDeleteRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessDeleteRecipe into preprocessDeleteRecipe: %w", err)
	} else if v != nil {
		m["preprocessDeleteRecipe"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipe(c, f.PreprocessUpdateRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdateRecipe into preprocessUpdateRecipe: %w", err)
	} else if v != nil {
		m["preprocessUpdateRecipe"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipe(c, f.PreprocessFreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessFreezeRecipe into preprocessFreezeRecipe: %w", err)
	} else if v != nil {
		m["preprocessFreezeRecipe"] = v
	}
	if v, err := expandInstanceFreezeRecipe(c, f.FreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding FreezeRecipe into freezeRecipe: %w", err)
	} else if v != nil {
		m["freezeRecipe"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipe(c, f.PreprocessUnfreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUnfreezeRecipe into preprocessUnfreezeRecipe: %w", err)
	} else if v != nil {
		m["preprocessUnfreezeRecipe"] = v
	}
	if v, err := expandInstanceUnfreezeRecipe(c, f.UnfreezeRecipe); err != nil {
		return nil, fmt.Errorf("error expanding UnfreezeRecipe into unfreezeRecipe: %w", err)
	} else if v != nil {
		m["unfreezeRecipe"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipe(c, f.PreprocessReportInstanceHealthRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessReportInstanceHealthRecipe into preprocessReportInstanceHealthRecipe: %w", err)
	} else if v != nil {
		m["preprocessReportInstanceHealthRecipe"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipe(c, f.ReportInstanceHealthRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ReportInstanceHealthRecipe into reportInstanceHealthRecipe: %w", err)
	} else if v != nil {
		m["reportInstanceHealthRecipe"] = v
	}
	if v, err := expandInstancePreprocessGetRecipe(c, f.PreprocessGetRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessGetRecipe into preprocessGetRecipe: %w", err)
	} else if v != nil {
		m["preprocessGetRecipe"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipe(c, f.NotifyKeyAvailableRecipe); err != nil {
		return nil, fmt.Errorf("error expanding NotifyKeyAvailableRecipe into notifyKeyAvailableRecipe: %w", err)
	} else if v != nil {
		m["notifyKeyAvailableRecipe"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipe(c, f.NotifyKeyUnavailableRecipe); err != nil {
		return nil, fmt.Errorf("error expanding NotifyKeyUnavailableRecipe into notifyKeyUnavailableRecipe: %w", err)
	} else if v != nil {
		m["notifyKeyUnavailableRecipe"] = v
	}
	if v, err := expandInstanceReadonlyRecipe(c, f.ReadonlyRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ReadonlyRecipe into readonlyRecipe: %w", err)
	} else if v != nil {
		m["readonlyRecipe"] = v
	}
	if v, err := expandInstanceReconcileRecipe(c, f.ReconcileRecipe); err != nil {
		return nil, fmt.Errorf("error expanding ReconcileRecipe into reconcileRecipe: %w", err)
	} else if v != nil {
		m["reconcileRecipe"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipe(c, f.PreprocessPassthroughRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessPassthroughRecipe into preprocessPassthroughRecipe: %w", err)
	} else if v != nil {
		m["preprocessPassthroughRecipe"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipe(c, f.PreprocessReconcileRecipe); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessReconcileRecipe into preprocessReconcileRecipe: %w", err)
	} else if v != nil {
		m["preprocessReconcileRecipe"] = v
	}
	if v := f.EnableCallHistory; !dcl.IsEmptyValueIndirect(v) {
		m["enableCallHistory"] = v
	}
	if v, err := expandInstanceHistorySlice(c, f.History); err != nil {
		return nil, fmt.Errorf("error expanding History into history: %w", err)
	} else if v != nil {
		m["history"] = v
	}
	if v := f.PublicResourceViewOverride; !dcl.IsEmptyValueIndirect(v) {
		m["publicResourceViewOverride"] = v
	}
	if v := f.ExtraInfo; !dcl.IsEmptyValueIndirect(v) {
		m["extraInfo"] = v
	}
	if v := f.Uid; !dcl.IsEmptyValueIndirect(v) {
		m["uid"] = v
	}
	if v := f.Etag; !dcl.IsEmptyValueIndirect(v) {
		m["etag"] = v
	}
	if v, err := dcl.EmptyValue(); err != nil {
		return nil, fmt.Errorf("error expanding Project into project: %w", err)
	} else if v != nil {
		m["project"] = v
	}
	if v, err := dcl.EmptyValue(); err != nil {
		return nil, fmt.Errorf("error expanding Location into location: %w", err)
	} else if v != nil {
		m["location"] = v
	}

	return m, nil
}

// flattenInstance flattens Instance from a JSON request object into the
// Instance type.
func flattenInstance(c *Client, i interface{}) *Instance {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}
	if len(m) == 0 {
		return nil
	}

	res := &Instance{}
	res.Name = dcl.FlattenString(m["name"])
	res.DisplayName = dcl.FlattenString(m["displayName"])
	res.Labels = dcl.FlattenKeyValuePairs(m["labels"])
	res.Zone = dcl.FlattenString(m["zone"])
	res.AlternativeZone = dcl.FlattenString(m["alternativeZone"])
	res.Sku = flattenInstanceSku(c, m["sku"])
	res.AuthorizedNetworkId = dcl.FlattenString(m["authorizedNetworkId"])
	res.ReservedIPRange = dcl.FlattenString(m["reservedIpRange"])
	res.Host = dcl.FlattenString(m["host"])
	res.Port = dcl.FlattenInteger(m["port"])
	res.CurrentZone = dcl.FlattenString(m["currentZone"])
	res.CreateTime = dcl.FlattenString(m["createTime"])
	res.State = flattenInstanceStateEnum(m["state"])
	res.StatusMessage = dcl.FlattenString(m["statusMessage"])
	res.UpdateTime = dcl.FlattenString(m["updateTime"])
	res.MutateUserId = dcl.FlattenInteger(m["mutateUserId"])
	res.ReadUserId = dcl.FlattenInteger(m["readUserId"])
	res.References = flattenInstanceReferencesSlice(c, m["references"])
	res.PreprocessCreateRecipe = flattenInstancePreprocessCreateRecipe(c, m["preprocessCreateRecipe"])
	res.CreateRecipe = flattenInstanceCreateRecipe(c, m["createRecipe"])
	res.DeleteRecipe = flattenInstanceDeleteRecipe(c, m["deleteRecipe"])
	res.UpdateRecipe = flattenInstanceUpdateRecipe(c, m["updateRecipe"])
	res.PreprocessResetRecipe = flattenInstancePreprocessResetRecipe(c, m["preprocessResetRecipe"])
	res.ResetRecipe = flattenInstanceResetRecipe(c, m["resetRecipe"])
	res.PreprocessRepairRecipe = flattenInstancePreprocessRepairRecipe(c, m["preprocessRepairRecipe"])
	res.RepairRecipe = flattenInstanceRepairRecipe(c, m["repairRecipe"])
	res.PreprocessDeleteRecipe = flattenInstancePreprocessDeleteRecipe(c, m["preprocessDeleteRecipe"])
	res.PreprocessUpdateRecipe = flattenInstancePreprocessUpdateRecipe(c, m["preprocessUpdateRecipe"])
	res.PreprocessFreezeRecipe = flattenInstancePreprocessFreezeRecipe(c, m["preprocessFreezeRecipe"])
	res.FreezeRecipe = flattenInstanceFreezeRecipe(c, m["freezeRecipe"])
	res.PreprocessUnfreezeRecipe = flattenInstancePreprocessUnfreezeRecipe(c, m["preprocessUnfreezeRecipe"])
	res.UnfreezeRecipe = flattenInstanceUnfreezeRecipe(c, m["unfreezeRecipe"])
	res.PreprocessReportInstanceHealthRecipe = flattenInstancePreprocessReportInstanceHealthRecipe(c, m["preprocessReportInstanceHealthRecipe"])
	res.ReportInstanceHealthRecipe = flattenInstanceReportInstanceHealthRecipe(c, m["reportInstanceHealthRecipe"])
	res.PreprocessGetRecipe = flattenInstancePreprocessGetRecipe(c, m["preprocessGetRecipe"])
	res.NotifyKeyAvailableRecipe = flattenInstanceNotifyKeyAvailableRecipe(c, m["notifyKeyAvailableRecipe"])
	res.NotifyKeyUnavailableRecipe = flattenInstanceNotifyKeyUnavailableRecipe(c, m["notifyKeyUnavailableRecipe"])
	res.ReadonlyRecipe = flattenInstanceReadonlyRecipe(c, m["readonlyRecipe"])
	res.ReconcileRecipe = flattenInstanceReconcileRecipe(c, m["reconcileRecipe"])
	res.PreprocessPassthroughRecipe = flattenInstancePreprocessPassthroughRecipe(c, m["preprocessPassthroughRecipe"])
	res.PreprocessReconcileRecipe = flattenInstancePreprocessReconcileRecipe(c, m["preprocessReconcileRecipe"])
	res.EnableCallHistory = dcl.FlattenBool(m["enableCallHistory"])
	res.History = flattenInstanceHistorySlice(c, m["history"])
	res.PublicResourceViewOverride = dcl.FlattenString(m["publicResourceViewOverride"])
	res.ExtraInfo = dcl.FlattenString(m["extraInfo"])
	res.Uid = dcl.FlattenString(m["uid"])
	res.Etag = dcl.FlattenString(m["etag"])
	res.Project = dcl.FlattenString(m["project"])
	res.Location = dcl.FlattenString(m["location"])

	return res
}

// expandInstanceSkuMap expands the contents of InstanceSku into a JSON
// request object.
func expandInstanceSkuMap(c *Client, f map[string]InstanceSku) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceSku(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceSkuSlice expands the contents of InstanceSku into a JSON
// request object.
func expandInstanceSkuSlice(c *Client, f []InstanceSku) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceSku(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceSkuMap flattens the contents of InstanceSku from a JSON
// response object.
func flattenInstanceSkuMap(c *Client, i interface{}) map[string]InstanceSku {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceSku{}
	}

	if len(a) == 0 {
		return map[string]InstanceSku{}
	}

	items := make(map[string]InstanceSku)
	for k, item := range a {
		items[k] = *flattenInstanceSku(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceSkuSlice flattens the contents of InstanceSku from a JSON
// response object.
func flattenInstanceSkuSlice(c *Client, i interface{}) []InstanceSku {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceSku{}
	}

	if len(a) == 0 {
		return []InstanceSku{}
	}

	items := make([]InstanceSku, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceSku(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceSku expands an instance of InstanceSku into a JSON
// request object.
func expandInstanceSku(c *Client, f *InstanceSku) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tier; !dcl.IsEmptyValueIndirect(v) {
		m["tier"] = v
	}
	if v := f.Size; !dcl.IsEmptyValueIndirect(v) {
		m["size"] = v
	}

	return m, nil
}

// flattenInstanceSku flattens an instance of InstanceSku from a JSON
// response object.
func flattenInstanceSku(c *Client, i interface{}) *InstanceSku {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceSku{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceSku
	}
	r.Tier = flattenInstanceSkuTierEnum(m["tier"])
	r.Size = flattenInstanceSkuSizeEnum(m["size"])

	return r
}

// expandInstanceReferencesMap expands the contents of InstanceReferences into a JSON
// request object.
func expandInstanceReferencesMap(c *Client, f map[string]InstanceReferences) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReferences(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReferencesSlice expands the contents of InstanceReferences into a JSON
// request object.
func expandInstanceReferencesSlice(c *Client, f []InstanceReferences) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReferences(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReferencesMap flattens the contents of InstanceReferences from a JSON
// response object.
func flattenInstanceReferencesMap(c *Client, i interface{}) map[string]InstanceReferences {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReferences{}
	}

	if len(a) == 0 {
		return map[string]InstanceReferences{}
	}

	items := make(map[string]InstanceReferences)
	for k, item := range a {
		items[k] = *flattenInstanceReferences(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReferencesSlice flattens the contents of InstanceReferences from a JSON
// response object.
func flattenInstanceReferencesSlice(c *Client, i interface{}) []InstanceReferences {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReferences{}
	}

	if len(a) == 0 {
		return []InstanceReferences{}
	}

	items := make([]InstanceReferences, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReferences(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReferences expands an instance of InstanceReferences into a JSON
// request object.
func expandInstanceReferences(c *Client, f *InstanceReferences) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Name; !dcl.IsEmptyValueIndirect(v) {
		m["name"] = v
	}
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.SourceResource; !dcl.IsEmptyValueIndirect(v) {
		m["sourceResource"] = v
	}
	if v, err := expandInstanceReferencesDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}
	if v := f.CreateTime; !dcl.IsEmptyValueIndirect(v) {
		m["createTime"] = v
	}

	return m, nil
}

// flattenInstanceReferences flattens an instance of InstanceReferences from a JSON
// response object.
func flattenInstanceReferences(c *Client, i interface{}) *InstanceReferences {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReferences{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReferences
	}
	r.Name = dcl.SelfLinkToName(dcl.FlattenString(m["name"]))
	r.Type = dcl.FlattenString(m["type"])
	r.SourceResource = dcl.FlattenString(m["sourceResource"])
	r.Details = flattenInstanceReferencesDetailsSlice(c, m["details"])
	r.CreateTime = dcl.FlattenString(m["createTime"])

	return r
}

// expandInstanceReferencesDetailsMap expands the contents of InstanceReferencesDetails into a JSON
// request object.
func expandInstanceReferencesDetailsMap(c *Client, f map[string]InstanceReferencesDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReferencesDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReferencesDetailsSlice expands the contents of InstanceReferencesDetails into a JSON
// request object.
func expandInstanceReferencesDetailsSlice(c *Client, f []InstanceReferencesDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReferencesDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReferencesDetailsMap flattens the contents of InstanceReferencesDetails from a JSON
// response object.
func flattenInstanceReferencesDetailsMap(c *Client, i interface{}) map[string]InstanceReferencesDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReferencesDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceReferencesDetails{}
	}

	items := make(map[string]InstanceReferencesDetails)
	for k, item := range a {
		items[k] = *flattenInstanceReferencesDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReferencesDetailsSlice flattens the contents of InstanceReferencesDetails from a JSON
// response object.
func flattenInstanceReferencesDetailsSlice(c *Client, i interface{}) []InstanceReferencesDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReferencesDetails{}
	}

	if len(a) == 0 {
		return []InstanceReferencesDetails{}
	}

	items := make([]InstanceReferencesDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReferencesDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReferencesDetails expands an instance of InstanceReferencesDetails into a JSON
// request object.
func expandInstanceReferencesDetails(c *Client, f *InstanceReferencesDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceReferencesDetails flattens an instance of InstanceReferencesDetails from a JSON
// response object.
func flattenInstanceReferencesDetails(c *Client, i interface{}) *InstanceReferencesDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReferencesDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReferencesDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessCreateRecipeMap expands the contents of InstancePreprocessCreateRecipe into a JSON
// request object.
func expandInstancePreprocessCreateRecipeMap(c *Client, f map[string]InstancePreprocessCreateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeSlice expands the contents of InstancePreprocessCreateRecipe into a JSON
// request object.
func expandInstancePreprocessCreateRecipeSlice(c *Client, f []InstancePreprocessCreateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeMap flattens the contents of InstancePreprocessCreateRecipe from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipe{}
	}

	items := make(map[string]InstancePreprocessCreateRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeSlice flattens the contents of InstancePreprocessCreateRecipe from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipe{}
	}

	items := make([]InstancePreprocessCreateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipe expands an instance of InstancePreprocessCreateRecipe into a JSON
// request object.
func expandInstancePreprocessCreateRecipe(c *Client, f *InstancePreprocessCreateRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessCreateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipe flattens an instance of InstancePreprocessCreateRecipe from a JSON
// response object.
func flattenInstancePreprocessCreateRecipe(c *Client, i interface{}) *InstancePreprocessCreateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipe
	}
	r.Steps = flattenInstancePreprocessCreateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsMap expands the contents of InstancePreprocessCreateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsMap(c *Client, f map[string]InstancePreprocessCreateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsSlice expands the contents of InstancePreprocessCreateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsSlice(c *Client, f []InstancePreprocessCreateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsMap flattens the contents of InstancePreprocessCreateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsSlice flattens the contents of InstancePreprocessCreateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeSteps{}
	}

	items := make([]InstancePreprocessCreateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeSteps expands an instance of InstancePreprocessCreateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessCreateRecipeSteps(c *Client, f *InstancePreprocessCreateRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeSteps flattens an instance of InstancePreprocessCreateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeSteps(c *Client, i interface{}) *InstancePreprocessCreateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessCreateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessCreateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsStatusMap expands the contents of InstancePreprocessCreateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsStatusSlice expands the contents of InstancePreprocessCreateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusSlice(c *Client, f []InstancePreprocessCreateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsStatusMap flattens the contents of InstancePreprocessCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsStatusSlice flattens the contents of InstancePreprocessCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsStatus expands an instance of InstancePreprocessCreateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatus(c *Client, f *InstancePreprocessCreateRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsStatus flattens an instance of InstancePreprocessCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessCreateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsStatusDetails expands an instance of InstancePreprocessCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsStatusDetails(c *Client, f *InstancePreprocessCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsStatusDetails flattens an instance of InstancePreprocessCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessCreateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfo expands an instance of InstancePreprocessCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceGoogleprotobufstructMap expands the contents of InstanceGoogleprotobufstruct into a JSON
// request object.
func expandInstanceGoogleprotobufstructMap(c *Client, f map[string]InstanceGoogleprotobufstruct) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceGoogleprotobufstruct(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceGoogleprotobufstructSlice expands the contents of InstanceGoogleprotobufstruct into a JSON
// request object.
func expandInstanceGoogleprotobufstructSlice(c *Client, f []InstanceGoogleprotobufstruct) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceGoogleprotobufstruct(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceGoogleprotobufstructMap flattens the contents of InstanceGoogleprotobufstruct from a JSON
// response object.
func flattenInstanceGoogleprotobufstructMap(c *Client, i interface{}) map[string]InstanceGoogleprotobufstruct {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceGoogleprotobufstruct{}
	}

	if len(a) == 0 {
		return map[string]InstanceGoogleprotobufstruct{}
	}

	items := make(map[string]InstanceGoogleprotobufstruct)
	for k, item := range a {
		items[k] = *flattenInstanceGoogleprotobufstruct(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceGoogleprotobufstructSlice flattens the contents of InstanceGoogleprotobufstruct from a JSON
// response object.
func flattenInstanceGoogleprotobufstructSlice(c *Client, i interface{}) []InstanceGoogleprotobufstruct {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceGoogleprotobufstruct{}
	}

	if len(a) == 0 {
		return []InstanceGoogleprotobufstruct{}
	}

	items := make([]InstanceGoogleprotobufstruct, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceGoogleprotobufstruct(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceGoogleprotobufstruct expands an instance of InstanceGoogleprotobufstruct into a JSON
// request object.
func expandInstanceGoogleprotobufstruct(c *Client, f *InstanceGoogleprotobufstruct) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})

	return m, nil
}

// flattenInstanceGoogleprotobufstruct flattens an instance of InstanceGoogleprotobufstruct from a JSON
// response object.
func flattenInstanceGoogleprotobufstruct(c *Client, i interface{}) *InstanceGoogleprotobufstruct {
	_, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceGoogleprotobufstruct{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceGoogleprotobufstruct
	}

	return r
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceCreateRecipeMap expands the contents of InstanceCreateRecipe into a JSON
// request object.
func expandInstanceCreateRecipeMap(c *Client, f map[string]InstanceCreateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeSlice expands the contents of InstanceCreateRecipe into a JSON
// request object.
func expandInstanceCreateRecipeSlice(c *Client, f []InstanceCreateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeMap flattens the contents of InstanceCreateRecipe from a JSON
// response object.
func flattenInstanceCreateRecipeMap(c *Client, i interface{}) map[string]InstanceCreateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipe{}
	}

	items := make(map[string]InstanceCreateRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeSlice flattens the contents of InstanceCreateRecipe from a JSON
// response object.
func flattenInstanceCreateRecipeSlice(c *Client, i interface{}) []InstanceCreateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipe{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipe{}
	}

	items := make([]InstanceCreateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipe expands an instance of InstanceCreateRecipe into a JSON
// request object.
func expandInstanceCreateRecipe(c *Client, f *InstanceCreateRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceCreateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipe flattens an instance of InstanceCreateRecipe from a JSON
// response object.
func flattenInstanceCreateRecipe(c *Client, i interface{}) *InstanceCreateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipe
	}
	r.Steps = flattenInstanceCreateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceCreateRecipeStepsMap expands the contents of InstanceCreateRecipeSteps into a JSON
// request object.
func expandInstanceCreateRecipeStepsMap(c *Client, f map[string]InstanceCreateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsSlice expands the contents of InstanceCreateRecipeSteps into a JSON
// request object.
func expandInstanceCreateRecipeStepsSlice(c *Client, f []InstanceCreateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsMap flattens the contents of InstanceCreateRecipeSteps from a JSON
// response object.
func flattenInstanceCreateRecipeStepsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeSteps{}
	}

	items := make(map[string]InstanceCreateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsSlice flattens the contents of InstanceCreateRecipeSteps from a JSON
// response object.
func flattenInstanceCreateRecipeStepsSlice(c *Client, i interface{}) []InstanceCreateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeSteps{}
	}

	items := make([]InstanceCreateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeSteps expands an instance of InstanceCreateRecipeSteps into a JSON
// request object.
func expandInstanceCreateRecipeSteps(c *Client, f *InstanceCreateRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeSteps flattens an instance of InstanceCreateRecipeSteps from a JSON
// response object.
func flattenInstanceCreateRecipeSteps(c *Client, i interface{}) *InstanceCreateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceCreateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceCreateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceCreateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceCreateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceCreateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceCreateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceCreateRecipeStepsStatusMap expands the contents of InstanceCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusMap(c *Client, f map[string]InstanceCreateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsStatusSlice expands the contents of InstanceCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusSlice(c *Client, f []InstanceCreateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsStatusMap flattens the contents of InstanceCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsStatus{}
	}

	items := make(map[string]InstanceCreateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsStatusSlice flattens the contents of InstanceCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsStatus{}
	}

	items := make([]InstanceCreateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsStatus expands an instance of InstanceCreateRecipeStepsStatus into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatus(c *Client, f *InstanceCreateRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsStatus flattens an instance of InstanceCreateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatus(c *Client, i interface{}) *InstanceCreateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceCreateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceCreateRecipeStepsStatusDetailsMap expands the contents of InstanceCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsStatusDetailsSlice expands the contents of InstanceCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusDetailsSlice(c *Client, f []InstanceCreateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsStatusDetailsMap flattens the contents of InstanceCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceCreateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsStatusDetailsSlice flattens the contents of InstanceCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsStatusDetails{}
	}

	items := make([]InstanceCreateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsStatusDetails expands an instance of InstanceCreateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceCreateRecipeStepsStatusDetails(c *Client, f *InstanceCreateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsStatusDetails flattens an instance of InstanceCreateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceCreateRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceCreateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceCreateRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceCreateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceCreateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceCreateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceCreateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceCreateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceCreateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsQuotaRequestDeltas expands an instance of InstanceCreateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceCreateRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceCreateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsQuotaRequestDeltas flattens an instance of InstanceCreateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceCreateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceCreateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceCreateRecipeStepsPreprocessUpdateMap expands the contents of InstanceCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPreprocessUpdateSlice expands the contents of InstanceCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceCreateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPreprocessUpdateMap flattens the contents of InstanceCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceCreateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPreprocessUpdate expands an instance of InstanceCreateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsPreprocessUpdate(c *Client, f *InstanceCreateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPreprocessUpdate flattens an instance of InstanceCreateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceCreateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceCreateRecipeStepsRequestedTenantProjectMap expands the contents of InstanceCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceCreateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceCreateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceCreateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceCreateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceCreateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceCreateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceCreateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsRequestedTenantProject expands an instance of InstanceCreateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceCreateRecipeStepsRequestedTenantProject(c *Client, f *InstanceCreateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsRequestedTenantProject flattens an instance of InstanceCreateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceCreateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceCreateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceCreateRecipeStepsPermissionsInfoMap expands the contents of InstanceCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPermissionsInfoSlice expands the contents of InstanceCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceCreateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoMap flattens the contents of InstanceCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPermissionsInfoSlice flattens the contents of InstanceCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceCreateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPermissionsInfo expands an instance of InstanceCreateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfo(c *Client, f *InstanceCreateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfo flattens an instance of InstanceCreateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceCreateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceCreateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceCreateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceCreateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceCreateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceCreateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceCreateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceCreateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceCreateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceCreateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceCreateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceCreateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceCreateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceCreateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceCreateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceCreateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceCreateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceCreateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdate expands an instance of InstanceCreateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceCreateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceCreateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceCreateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceCreateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceDeleteRecipeMap expands the contents of InstanceDeleteRecipe into a JSON
// request object.
func expandInstanceDeleteRecipeMap(c *Client, f map[string]InstanceDeleteRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeSlice expands the contents of InstanceDeleteRecipe into a JSON
// request object.
func expandInstanceDeleteRecipeSlice(c *Client, f []InstanceDeleteRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeMap flattens the contents of InstanceDeleteRecipe from a JSON
// response object.
func flattenInstanceDeleteRecipeMap(c *Client, i interface{}) map[string]InstanceDeleteRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipe{}
	}

	items := make(map[string]InstanceDeleteRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeSlice flattens the contents of InstanceDeleteRecipe from a JSON
// response object.
func flattenInstanceDeleteRecipeSlice(c *Client, i interface{}) []InstanceDeleteRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipe{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipe{}
	}

	items := make([]InstanceDeleteRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipe expands an instance of InstanceDeleteRecipe into a JSON
// request object.
func expandInstanceDeleteRecipe(c *Client, f *InstanceDeleteRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceDeleteRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipe flattens an instance of InstanceDeleteRecipe from a JSON
// response object.
func flattenInstanceDeleteRecipe(c *Client, i interface{}) *InstanceDeleteRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipe
	}
	r.Steps = flattenInstanceDeleteRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceDeleteRecipeStepsMap expands the contents of InstanceDeleteRecipeSteps into a JSON
// request object.
func expandInstanceDeleteRecipeStepsMap(c *Client, f map[string]InstanceDeleteRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsSlice expands the contents of InstanceDeleteRecipeSteps into a JSON
// request object.
func expandInstanceDeleteRecipeStepsSlice(c *Client, f []InstanceDeleteRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsMap flattens the contents of InstanceDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeSteps{}
	}

	items := make(map[string]InstanceDeleteRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsSlice flattens the contents of InstanceDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsSlice(c *Client, i interface{}) []InstanceDeleteRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeSteps{}
	}

	items := make([]InstanceDeleteRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeSteps expands an instance of InstanceDeleteRecipeSteps into a JSON
// request object.
func expandInstanceDeleteRecipeSteps(c *Client, f *InstanceDeleteRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeSteps flattens an instance of InstanceDeleteRecipeSteps from a JSON
// response object.
func flattenInstanceDeleteRecipeSteps(c *Client, i interface{}) *InstanceDeleteRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceDeleteRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceDeleteRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceDeleteRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceDeleteRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceDeleteRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceDeleteRecipeStepsStatusMap expands the contents of InstanceDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusMap(c *Client, f map[string]InstanceDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsStatusSlice expands the contents of InstanceDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusSlice(c *Client, f []InstanceDeleteRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsStatusMap flattens the contents of InstanceDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsStatus{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsStatusSlice flattens the contents of InstanceDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsStatus{}
	}

	items := make([]InstanceDeleteRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsStatus expands an instance of InstanceDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatus(c *Client, f *InstanceDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsStatus flattens an instance of InstanceDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatus(c *Client, i interface{}) *InstanceDeleteRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceDeleteRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceDeleteRecipeStepsStatusDetailsMap expands the contents of InstanceDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsStatusDetailsSlice expands the contents of InstanceDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusDetailsSlice(c *Client, f []InstanceDeleteRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsStatusDetailsMap flattens the contents of InstanceDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsStatusDetailsSlice flattens the contents of InstanceDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsStatusDetails{}
	}

	items := make([]InstanceDeleteRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsStatusDetails expands an instance of InstanceDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceDeleteRecipeStepsStatusDetails(c *Client, f *InstanceDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsStatusDetails flattens an instance of InstanceDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceDeleteRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceDeleteRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceDeleteRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceDeleteRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsQuotaRequestDeltas expands an instance of InstanceDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceDeleteRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsQuotaRequestDeltas flattens an instance of InstanceDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceDeleteRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceDeleteRecipeStepsPreprocessUpdateMap expands the contents of InstanceDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPreprocessUpdateSlice expands the contents of InstanceDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceDeleteRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPreprocessUpdateMap flattens the contents of InstanceDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceDeleteRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPreprocessUpdate expands an instance of InstanceDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPreprocessUpdate(c *Client, f *InstanceDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPreprocessUpdate flattens an instance of InstanceDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceDeleteRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceDeleteRecipeStepsRequestedTenantProjectMap expands the contents of InstanceDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceDeleteRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceDeleteRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceDeleteRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsRequestedTenantProject expands an instance of InstanceDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceDeleteRecipeStepsRequestedTenantProject(c *Client, f *InstanceDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProject flattens an instance of InstanceDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceDeleteRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceDeleteRecipeStepsPermissionsInfoMap expands the contents of InstanceDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPermissionsInfoSlice expands the contents of InstanceDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceDeleteRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoMap flattens the contents of InstanceDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoSlice flattens the contents of InstanceDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceDeleteRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPermissionsInfo expands an instance of InstanceDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfo(c *Client, f *InstanceDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfo flattens an instance of InstanceDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceDeleteRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceDeleteRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceDeleteRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceDeleteRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceDeleteRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceDeleteRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceDeleteRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceDeleteRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdate expands an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceDeleteRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceUpdateRecipeMap expands the contents of InstanceUpdateRecipe into a JSON
// request object.
func expandInstanceUpdateRecipeMap(c *Client, f map[string]InstanceUpdateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeSlice expands the contents of InstanceUpdateRecipe into a JSON
// request object.
func expandInstanceUpdateRecipeSlice(c *Client, f []InstanceUpdateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeMap flattens the contents of InstanceUpdateRecipe from a JSON
// response object.
func flattenInstanceUpdateRecipeMap(c *Client, i interface{}) map[string]InstanceUpdateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipe{}
	}

	items := make(map[string]InstanceUpdateRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeSlice flattens the contents of InstanceUpdateRecipe from a JSON
// response object.
func flattenInstanceUpdateRecipeSlice(c *Client, i interface{}) []InstanceUpdateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipe{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipe{}
	}

	items := make([]InstanceUpdateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipe expands an instance of InstanceUpdateRecipe into a JSON
// request object.
func expandInstanceUpdateRecipe(c *Client, f *InstanceUpdateRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceUpdateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipe flattens an instance of InstanceUpdateRecipe from a JSON
// response object.
func flattenInstanceUpdateRecipe(c *Client, i interface{}) *InstanceUpdateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipe
	}
	r.Steps = flattenInstanceUpdateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceUpdateRecipeStepsMap expands the contents of InstanceUpdateRecipeSteps into a JSON
// request object.
func expandInstanceUpdateRecipeStepsMap(c *Client, f map[string]InstanceUpdateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsSlice expands the contents of InstanceUpdateRecipeSteps into a JSON
// request object.
func expandInstanceUpdateRecipeStepsSlice(c *Client, f []InstanceUpdateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsMap flattens the contents of InstanceUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeSteps{}
	}

	items := make(map[string]InstanceUpdateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsSlice flattens the contents of InstanceUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsSlice(c *Client, i interface{}) []InstanceUpdateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeSteps{}
	}

	items := make([]InstanceUpdateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeSteps expands an instance of InstanceUpdateRecipeSteps into a JSON
// request object.
func expandInstanceUpdateRecipeSteps(c *Client, f *InstanceUpdateRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeSteps flattens an instance of InstanceUpdateRecipeSteps from a JSON
// response object.
func flattenInstanceUpdateRecipeSteps(c *Client, i interface{}) *InstanceUpdateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceUpdateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceUpdateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceUpdateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceUpdateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceUpdateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceUpdateRecipeStepsStatusMap expands the contents of InstanceUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusMap(c *Client, f map[string]InstanceUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsStatusSlice expands the contents of InstanceUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusSlice(c *Client, f []InstanceUpdateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsStatusMap flattens the contents of InstanceUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsStatus{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsStatusSlice flattens the contents of InstanceUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsStatus{}
	}

	items := make([]InstanceUpdateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsStatus expands an instance of InstanceUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatus(c *Client, f *InstanceUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsStatus flattens an instance of InstanceUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatus(c *Client, i interface{}) *InstanceUpdateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceUpdateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceUpdateRecipeStepsStatusDetailsMap expands the contents of InstanceUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsStatusDetailsSlice expands the contents of InstanceUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusDetailsSlice(c *Client, f []InstanceUpdateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsStatusDetailsMap flattens the contents of InstanceUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsStatusDetailsSlice flattens the contents of InstanceUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsStatusDetails{}
	}

	items := make([]InstanceUpdateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsStatusDetails expands an instance of InstanceUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUpdateRecipeStepsStatusDetails(c *Client, f *InstanceUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsStatusDetails flattens an instance of InstanceUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceUpdateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceUpdateRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceUpdateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceUpdateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsQuotaRequestDeltas expands an instance of InstanceUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUpdateRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsQuotaRequestDeltas flattens an instance of InstanceUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceUpdateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceUpdateRecipeStepsPreprocessUpdateMap expands the contents of InstanceUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPreprocessUpdateSlice expands the contents of InstanceUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceUpdateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPreprocessUpdateMap flattens the contents of InstanceUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceUpdateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPreprocessUpdate expands an instance of InstanceUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPreprocessUpdate(c *Client, f *InstanceUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPreprocessUpdate flattens an instance of InstanceUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceUpdateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceUpdateRecipeStepsRequestedTenantProjectMap expands the contents of InstanceUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUpdateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceUpdateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceUpdateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsRequestedTenantProject expands an instance of InstanceUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUpdateRecipeStepsRequestedTenantProject(c *Client, f *InstanceUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProject flattens an instance of InstanceUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceUpdateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceUpdateRecipeStepsPermissionsInfoMap expands the contents of InstanceUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPermissionsInfoSlice expands the contents of InstanceUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceUpdateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoMap flattens the contents of InstanceUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoSlice flattens the contents of InstanceUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceUpdateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPermissionsInfo expands an instance of InstanceUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfo(c *Client, f *InstanceUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfo flattens an instance of InstanceUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceUpdateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceUpdateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceUpdateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceUpdateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceUpdateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceUpdateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceUpdateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceUpdateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdate expands an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceUpdateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessResetRecipeMap expands the contents of InstancePreprocessResetRecipe into a JSON
// request object.
func expandInstancePreprocessResetRecipeMap(c *Client, f map[string]InstancePreprocessResetRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeSlice expands the contents of InstancePreprocessResetRecipe into a JSON
// request object.
func expandInstancePreprocessResetRecipeSlice(c *Client, f []InstancePreprocessResetRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeMap flattens the contents of InstancePreprocessResetRecipe from a JSON
// response object.
func flattenInstancePreprocessResetRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipe{}
	}

	items := make(map[string]InstancePreprocessResetRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeSlice flattens the contents of InstancePreprocessResetRecipe from a JSON
// response object.
func flattenInstancePreprocessResetRecipeSlice(c *Client, i interface{}) []InstancePreprocessResetRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipe{}
	}

	items := make([]InstancePreprocessResetRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipe expands an instance of InstancePreprocessResetRecipe into a JSON
// request object.
func expandInstancePreprocessResetRecipe(c *Client, f *InstancePreprocessResetRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessResetRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipe flattens an instance of InstancePreprocessResetRecipe from a JSON
// response object.
func flattenInstancePreprocessResetRecipe(c *Client, i interface{}) *InstancePreprocessResetRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipe
	}
	r.Steps = flattenInstancePreprocessResetRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessResetRecipeStepsMap expands the contents of InstancePreprocessResetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsMap(c *Client, f map[string]InstancePreprocessResetRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsSlice expands the contents of InstancePreprocessResetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsSlice(c *Client, f []InstancePreprocessResetRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsMap flattens the contents of InstancePreprocessResetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessResetRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsSlice flattens the contents of InstancePreprocessResetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeSteps{}
	}

	items := make([]InstancePreprocessResetRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeSteps expands an instance of InstancePreprocessResetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessResetRecipeSteps(c *Client, f *InstancePreprocessResetRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeSteps flattens an instance of InstancePreprocessResetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessResetRecipeSteps(c *Client, i interface{}) *InstancePreprocessResetRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessResetRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessResetRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessResetRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessResetRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessResetRecipeStepsStatusMap expands the contents of InstancePreprocessResetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsStatusSlice expands the contents of InstancePreprocessResetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusSlice(c *Client, f []InstancePreprocessResetRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsStatusMap flattens the contents of InstancePreprocessResetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsStatusSlice flattens the contents of InstancePreprocessResetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessResetRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsStatus expands an instance of InstancePreprocessResetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatus(c *Client, f *InstancePreprocessResetRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsStatus flattens an instance of InstancePreprocessResetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessResetRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessResetRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessResetRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessResetRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsStatusDetails expands an instance of InstancePreprocessResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsStatusDetails(c *Client, f *InstancePreprocessResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsStatusDetails flattens an instance of InstancePreprocessResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessResetRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessResetRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessResetRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessResetRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessResetRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessResetRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessResetRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfo expands an instance of InstancePreprocessResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessResetRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceResetRecipeMap expands the contents of InstanceResetRecipe into a JSON
// request object.
func expandInstanceResetRecipeMap(c *Client, f map[string]InstanceResetRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeSlice expands the contents of InstanceResetRecipe into a JSON
// request object.
func expandInstanceResetRecipeSlice(c *Client, f []InstanceResetRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeMap flattens the contents of InstanceResetRecipe from a JSON
// response object.
func flattenInstanceResetRecipeMap(c *Client, i interface{}) map[string]InstanceResetRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipe{}
	}

	items := make(map[string]InstanceResetRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeSlice flattens the contents of InstanceResetRecipe from a JSON
// response object.
func flattenInstanceResetRecipeSlice(c *Client, i interface{}) []InstanceResetRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipe{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipe{}
	}

	items := make([]InstanceResetRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipe expands an instance of InstanceResetRecipe into a JSON
// request object.
func expandInstanceResetRecipe(c *Client, f *InstanceResetRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceResetRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipe flattens an instance of InstanceResetRecipe from a JSON
// response object.
func flattenInstanceResetRecipe(c *Client, i interface{}) *InstanceResetRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipe
	}
	r.Steps = flattenInstanceResetRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceResetRecipeStepsMap expands the contents of InstanceResetRecipeSteps into a JSON
// request object.
func expandInstanceResetRecipeStepsMap(c *Client, f map[string]InstanceResetRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsSlice expands the contents of InstanceResetRecipeSteps into a JSON
// request object.
func expandInstanceResetRecipeStepsSlice(c *Client, f []InstanceResetRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsMap flattens the contents of InstanceResetRecipeSteps from a JSON
// response object.
func flattenInstanceResetRecipeStepsMap(c *Client, i interface{}) map[string]InstanceResetRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeSteps{}
	}

	items := make(map[string]InstanceResetRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsSlice flattens the contents of InstanceResetRecipeSteps from a JSON
// response object.
func flattenInstanceResetRecipeStepsSlice(c *Client, i interface{}) []InstanceResetRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeSteps{}
	}

	items := make([]InstanceResetRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeSteps expands an instance of InstanceResetRecipeSteps into a JSON
// request object.
func expandInstanceResetRecipeSteps(c *Client, f *InstanceResetRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceResetRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceResetRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceResetRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceResetRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceResetRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceResetRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeSteps flattens an instance of InstanceResetRecipeSteps from a JSON
// response object.
func flattenInstanceResetRecipeSteps(c *Client, i interface{}) *InstanceResetRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceResetRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceResetRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceResetRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceResetRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceResetRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceResetRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceResetRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceResetRecipeStepsStatusMap expands the contents of InstanceResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusMap(c *Client, f map[string]InstanceResetRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsStatusSlice expands the contents of InstanceResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusSlice(c *Client, f []InstanceResetRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsStatusMap flattens the contents of InstanceResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsStatus{}
	}

	items := make(map[string]InstanceResetRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsStatusSlice flattens the contents of InstanceResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceResetRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsStatus{}
	}

	items := make([]InstanceResetRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsStatus expands an instance of InstanceResetRecipeStepsStatus into a JSON
// request object.
func expandInstanceResetRecipeStepsStatus(c *Client, f *InstanceResetRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceResetRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsStatus flattens an instance of InstanceResetRecipeStepsStatus from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatus(c *Client, i interface{}) *InstanceResetRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceResetRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceResetRecipeStepsStatusDetailsMap expands the contents of InstanceResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsStatusDetailsSlice expands the contents of InstanceResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusDetailsSlice(c *Client, f []InstanceResetRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsStatusDetailsMap flattens the contents of InstanceResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceResetRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsStatusDetailsSlice flattens the contents of InstanceResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceResetRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsStatusDetails{}
	}

	items := make([]InstanceResetRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsStatusDetails expands an instance of InstanceResetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceResetRecipeStepsStatusDetails(c *Client, f *InstanceResetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsStatusDetails flattens an instance of InstanceResetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceResetRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceResetRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceResetRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceResetRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceResetRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceResetRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceResetRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceResetRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceResetRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceResetRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceResetRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsQuotaRequestDeltas expands an instance of InstanceResetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceResetRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceResetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsQuotaRequestDeltas flattens an instance of InstanceResetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceResetRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceResetRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceResetRecipeStepsPreprocessUpdateMap expands the contents of InstanceResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPreprocessUpdateSlice expands the contents of InstanceResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceResetRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPreprocessUpdateMap flattens the contents of InstanceResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceResetRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceResetRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPreprocessUpdate expands an instance of InstanceResetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsPreprocessUpdate(c *Client, f *InstanceResetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPreprocessUpdate flattens an instance of InstanceResetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceResetRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceResetRecipeStepsRequestedTenantProjectMap expands the contents of InstanceResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceResetRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceResetRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceResetRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceResetRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceResetRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceResetRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceResetRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceResetRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsRequestedTenantProject expands an instance of InstanceResetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceResetRecipeStepsRequestedTenantProject(c *Client, f *InstanceResetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsRequestedTenantProject flattens an instance of InstanceResetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceResetRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceResetRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceResetRecipeStepsPermissionsInfoMap expands the contents of InstanceResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPermissionsInfoSlice expands the contents of InstanceResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceResetRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoMap flattens the contents of InstanceResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceResetRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPermissionsInfoSlice flattens the contents of InstanceResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceResetRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPermissionsInfo expands an instance of InstanceResetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfo(c *Client, f *InstanceResetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceResetRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfo flattens an instance of InstanceResetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceResetRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceResetRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceResetRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceResetRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceResetRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceResetRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceResetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceResetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceResetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceResetRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceResetRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceResetRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceResetRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceResetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceResetRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceResetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceResetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceResetRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceResetRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceResetRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceResetRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceResetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceResetRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdate expands an instance of InstanceResetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceResetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceResetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceResetRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceResetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessRepairRecipeMap expands the contents of InstancePreprocessRepairRecipe into a JSON
// request object.
func expandInstancePreprocessRepairRecipeMap(c *Client, f map[string]InstancePreprocessRepairRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeSlice expands the contents of InstancePreprocessRepairRecipe into a JSON
// request object.
func expandInstancePreprocessRepairRecipeSlice(c *Client, f []InstancePreprocessRepairRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeMap flattens the contents of InstancePreprocessRepairRecipe from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipe{}
	}

	items := make(map[string]InstancePreprocessRepairRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeSlice flattens the contents of InstancePreprocessRepairRecipe from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipe{}
	}

	items := make([]InstancePreprocessRepairRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipe expands an instance of InstancePreprocessRepairRecipe into a JSON
// request object.
func expandInstancePreprocessRepairRecipe(c *Client, f *InstancePreprocessRepairRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessRepairRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipe flattens an instance of InstancePreprocessRepairRecipe from a JSON
// response object.
func flattenInstancePreprocessRepairRecipe(c *Client, i interface{}) *InstancePreprocessRepairRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipe
	}
	r.Steps = flattenInstancePreprocessRepairRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsMap expands the contents of InstancePreprocessRepairRecipeSteps into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsMap(c *Client, f map[string]InstancePreprocessRepairRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsSlice expands the contents of InstancePreprocessRepairRecipeSteps into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsSlice(c *Client, f []InstancePreprocessRepairRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsMap flattens the contents of InstancePreprocessRepairRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsSlice flattens the contents of InstancePreprocessRepairRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeSteps{}
	}

	items := make([]InstancePreprocessRepairRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeSteps expands an instance of InstancePreprocessRepairRecipeSteps into a JSON
// request object.
func expandInstancePreprocessRepairRecipeSteps(c *Client, f *InstancePreprocessRepairRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeSteps flattens an instance of InstancePreprocessRepairRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeSteps(c *Client, i interface{}) *InstancePreprocessRepairRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessRepairRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessRepairRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsStatusMap expands the contents of InstancePreprocessRepairRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsStatusSlice expands the contents of InstancePreprocessRepairRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusSlice(c *Client, f []InstancePreprocessRepairRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsStatusMap flattens the contents of InstancePreprocessRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsStatusSlice flattens the contents of InstancePreprocessRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsStatus expands an instance of InstancePreprocessRepairRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatus(c *Client, f *InstancePreprocessRepairRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsStatus flattens an instance of InstancePreprocessRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessRepairRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsStatusDetails expands an instance of InstancePreprocessRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsStatusDetails(c *Client, f *InstancePreprocessRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsStatusDetails flattens an instance of InstancePreprocessRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessRepairRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfo expands an instance of InstancePreprocessRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceRepairRecipeMap expands the contents of InstanceRepairRecipe into a JSON
// request object.
func expandInstanceRepairRecipeMap(c *Client, f map[string]InstanceRepairRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeSlice expands the contents of InstanceRepairRecipe into a JSON
// request object.
func expandInstanceRepairRecipeSlice(c *Client, f []InstanceRepairRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeMap flattens the contents of InstanceRepairRecipe from a JSON
// response object.
func flattenInstanceRepairRecipeMap(c *Client, i interface{}) map[string]InstanceRepairRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipe{}
	}

	items := make(map[string]InstanceRepairRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeSlice flattens the contents of InstanceRepairRecipe from a JSON
// response object.
func flattenInstanceRepairRecipeSlice(c *Client, i interface{}) []InstanceRepairRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipe{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipe{}
	}

	items := make([]InstanceRepairRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipe expands an instance of InstanceRepairRecipe into a JSON
// request object.
func expandInstanceRepairRecipe(c *Client, f *InstanceRepairRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceRepairRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipe flattens an instance of InstanceRepairRecipe from a JSON
// response object.
func flattenInstanceRepairRecipe(c *Client, i interface{}) *InstanceRepairRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipe
	}
	r.Steps = flattenInstanceRepairRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceRepairRecipeStepsMap expands the contents of InstanceRepairRecipeSteps into a JSON
// request object.
func expandInstanceRepairRecipeStepsMap(c *Client, f map[string]InstanceRepairRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsSlice expands the contents of InstanceRepairRecipeSteps into a JSON
// request object.
func expandInstanceRepairRecipeStepsSlice(c *Client, f []InstanceRepairRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsMap flattens the contents of InstanceRepairRecipeSteps from a JSON
// response object.
func flattenInstanceRepairRecipeStepsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeSteps{}
	}

	items := make(map[string]InstanceRepairRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsSlice flattens the contents of InstanceRepairRecipeSteps from a JSON
// response object.
func flattenInstanceRepairRecipeStepsSlice(c *Client, i interface{}) []InstanceRepairRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeSteps{}
	}

	items := make([]InstanceRepairRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeSteps expands an instance of InstanceRepairRecipeSteps into a JSON
// request object.
func expandInstanceRepairRecipeSteps(c *Client, f *InstanceRepairRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeSteps flattens an instance of InstanceRepairRecipeSteps from a JSON
// response object.
func flattenInstanceRepairRecipeSteps(c *Client, i interface{}) *InstanceRepairRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceRepairRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceRepairRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceRepairRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceRepairRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceRepairRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceRepairRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceRepairRecipeStepsStatusMap expands the contents of InstanceRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusMap(c *Client, f map[string]InstanceRepairRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsStatusSlice expands the contents of InstanceRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusSlice(c *Client, f []InstanceRepairRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsStatusMap flattens the contents of InstanceRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsStatus{}
	}

	items := make(map[string]InstanceRepairRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsStatusSlice flattens the contents of InstanceRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsStatus{}
	}

	items := make([]InstanceRepairRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsStatus expands an instance of InstanceRepairRecipeStepsStatus into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatus(c *Client, f *InstanceRepairRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsStatus flattens an instance of InstanceRepairRecipeStepsStatus from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatus(c *Client, i interface{}) *InstanceRepairRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceRepairRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceRepairRecipeStepsStatusDetailsMap expands the contents of InstanceRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsStatusDetailsSlice expands the contents of InstanceRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusDetailsSlice(c *Client, f []InstanceRepairRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsStatusDetailsMap flattens the contents of InstanceRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceRepairRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsStatusDetailsSlice flattens the contents of InstanceRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsStatusDetails{}
	}

	items := make([]InstanceRepairRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsStatusDetails expands an instance of InstanceRepairRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceRepairRecipeStepsStatusDetails(c *Client, f *InstanceRepairRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsStatusDetails flattens an instance of InstanceRepairRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceRepairRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceRepairRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceRepairRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceRepairRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceRepairRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceRepairRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceRepairRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceRepairRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceRepairRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsQuotaRequestDeltas expands an instance of InstanceRepairRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceRepairRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceRepairRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsQuotaRequestDeltas flattens an instance of InstanceRepairRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceRepairRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceRepairRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceRepairRecipeStepsPreprocessUpdateMap expands the contents of InstanceRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPreprocessUpdateSlice expands the contents of InstanceRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceRepairRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPreprocessUpdateMap flattens the contents of InstanceRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceRepairRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPreprocessUpdate expands an instance of InstanceRepairRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsPreprocessUpdate(c *Client, f *InstanceRepairRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPreprocessUpdate flattens an instance of InstanceRepairRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceRepairRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceRepairRecipeStepsRequestedTenantProjectMap expands the contents of InstanceRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceRepairRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceRepairRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceRepairRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceRepairRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceRepairRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceRepairRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceRepairRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsRequestedTenantProject expands an instance of InstanceRepairRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceRepairRecipeStepsRequestedTenantProject(c *Client, f *InstanceRepairRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsRequestedTenantProject flattens an instance of InstanceRepairRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceRepairRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceRepairRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceRepairRecipeStepsPermissionsInfoMap expands the contents of InstanceRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPermissionsInfoSlice expands the contents of InstanceRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceRepairRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoMap flattens the contents of InstanceRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPermissionsInfoSlice flattens the contents of InstanceRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceRepairRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPermissionsInfo expands an instance of InstanceRepairRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfo(c *Client, f *InstanceRepairRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfo flattens an instance of InstanceRepairRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceRepairRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceRepairRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceRepairRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceRepairRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceRepairRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceRepairRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceRepairRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceRepairRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceRepairRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceRepairRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceRepairRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceRepairRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceRepairRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceRepairRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceRepairRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceRepairRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceRepairRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceRepairRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdate expands an instance of InstanceRepairRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceRepairRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceRepairRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceRepairRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceRepairRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessDeleteRecipeMap expands the contents of InstancePreprocessDeleteRecipe into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeMap(c *Client, f map[string]InstancePreprocessDeleteRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeSlice expands the contents of InstancePreprocessDeleteRecipe into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeSlice(c *Client, f []InstancePreprocessDeleteRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeMap flattens the contents of InstancePreprocessDeleteRecipe from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipe{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeSlice flattens the contents of InstancePreprocessDeleteRecipe from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipe{}
	}

	items := make([]InstancePreprocessDeleteRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipe expands an instance of InstancePreprocessDeleteRecipe into a JSON
// request object.
func expandInstancePreprocessDeleteRecipe(c *Client, f *InstancePreprocessDeleteRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessDeleteRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipe flattens an instance of InstancePreprocessDeleteRecipe from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipe(c *Client, i interface{}) *InstancePreprocessDeleteRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipe
	}
	r.Steps = flattenInstancePreprocessDeleteRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsMap expands the contents of InstancePreprocessDeleteRecipeSteps into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsSlice expands the contents of InstancePreprocessDeleteRecipeSteps into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsSlice(c *Client, f []InstancePreprocessDeleteRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsMap flattens the contents of InstancePreprocessDeleteRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsSlice flattens the contents of InstancePreprocessDeleteRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeSteps{}
	}

	items := make([]InstancePreprocessDeleteRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeSteps expands an instance of InstancePreprocessDeleteRecipeSteps into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeSteps(c *Client, f *InstancePreprocessDeleteRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeSteps flattens an instance of InstancePreprocessDeleteRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeSteps(c *Client, i interface{}) *InstancePreprocessDeleteRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessDeleteRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessDeleteRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsStatusMap expands the contents of InstancePreprocessDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsStatusSlice expands the contents of InstancePreprocessDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsStatusMap flattens the contents of InstancePreprocessDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsStatusSlice flattens the contents of InstancePreprocessDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsStatus expands an instance of InstancePreprocessDeleteRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatus(c *Client, f *InstancePreprocessDeleteRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsStatus flattens an instance of InstancePreprocessDeleteRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsStatusDetails expands an instance of InstancePreprocessDeleteRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsStatusDetails(c *Client, f *InstancePreprocessDeleteRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsStatusDetails flattens an instance of InstancePreprocessDeleteRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessDeleteRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessDeleteRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessDeleteRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessDeleteRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessDeleteRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessDeleteRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfo expands an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessDeleteRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessDeleteRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessUpdateRecipeMap expands the contents of InstancePreprocessUpdateRecipe into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeMap(c *Client, f map[string]InstancePreprocessUpdateRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeSlice expands the contents of InstancePreprocessUpdateRecipe into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeSlice(c *Client, f []InstancePreprocessUpdateRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeMap flattens the contents of InstancePreprocessUpdateRecipe from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipe{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeSlice flattens the contents of InstancePreprocessUpdateRecipe from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipe{}
	}

	items := make([]InstancePreprocessUpdateRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipe expands an instance of InstancePreprocessUpdateRecipe into a JSON
// request object.
func expandInstancePreprocessUpdateRecipe(c *Client, f *InstancePreprocessUpdateRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessUpdateRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipe flattens an instance of InstancePreprocessUpdateRecipe from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipe(c *Client, i interface{}) *InstancePreprocessUpdateRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipe
	}
	r.Steps = flattenInstancePreprocessUpdateRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsMap expands the contents of InstancePreprocessUpdateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsSlice expands the contents of InstancePreprocessUpdateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsSlice(c *Client, f []InstancePreprocessUpdateRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsMap flattens the contents of InstancePreprocessUpdateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsSlice flattens the contents of InstancePreprocessUpdateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeSteps{}
	}

	items := make([]InstancePreprocessUpdateRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeSteps expands an instance of InstancePreprocessUpdateRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeSteps(c *Client, f *InstancePreprocessUpdateRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeSteps flattens an instance of InstancePreprocessUpdateRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeSteps(c *Client, i interface{}) *InstancePreprocessUpdateRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessUpdateRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessUpdateRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsStatusMap expands the contents of InstancePreprocessUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsStatusSlice expands the contents of InstancePreprocessUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsStatusMap flattens the contents of InstancePreprocessUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsStatusSlice flattens the contents of InstancePreprocessUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsStatus expands an instance of InstancePreprocessUpdateRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatus(c *Client, f *InstancePreprocessUpdateRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsStatus flattens an instance of InstancePreprocessUpdateRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsStatusDetails expands an instance of InstancePreprocessUpdateRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsStatusDetails(c *Client, f *InstancePreprocessUpdateRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsStatusDetails flattens an instance of InstancePreprocessUpdateRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessUpdateRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessUpdateRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessUpdateRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessUpdateRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessUpdateRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessUpdateRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfo expands an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessUpdateRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUpdateRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessFreezeRecipeMap expands the contents of InstancePreprocessFreezeRecipe into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeMap(c *Client, f map[string]InstancePreprocessFreezeRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeSlice expands the contents of InstancePreprocessFreezeRecipe into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeSlice(c *Client, f []InstancePreprocessFreezeRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeMap flattens the contents of InstancePreprocessFreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipe{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeSlice flattens the contents of InstancePreprocessFreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipe{}
	}

	items := make([]InstancePreprocessFreezeRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipe expands an instance of InstancePreprocessFreezeRecipe into a JSON
// request object.
func expandInstancePreprocessFreezeRecipe(c *Client, f *InstancePreprocessFreezeRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessFreezeRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipe flattens an instance of InstancePreprocessFreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipe(c *Client, i interface{}) *InstancePreprocessFreezeRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipe
	}
	r.Steps = flattenInstancePreprocessFreezeRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsMap expands the contents of InstancePreprocessFreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsSlice expands the contents of InstancePreprocessFreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsSlice(c *Client, f []InstancePreprocessFreezeRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsMap flattens the contents of InstancePreprocessFreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsSlice flattens the contents of InstancePreprocessFreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeSteps{}
	}

	items := make([]InstancePreprocessFreezeRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeSteps expands an instance of InstancePreprocessFreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeSteps(c *Client, f *InstancePreprocessFreezeRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeSteps flattens an instance of InstancePreprocessFreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeSteps(c *Client, i interface{}) *InstancePreprocessFreezeRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessFreezeRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessFreezeRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsStatusMap expands the contents of InstancePreprocessFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsStatusSlice expands the contents of InstancePreprocessFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsStatusMap flattens the contents of InstancePreprocessFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsStatusSlice flattens the contents of InstancePreprocessFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsStatus expands an instance of InstancePreprocessFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatus(c *Client, f *InstancePreprocessFreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsStatus flattens an instance of InstancePreprocessFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsStatusDetails expands an instance of InstancePreprocessFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsStatusDetails(c *Client, f *InstancePreprocessFreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsStatusDetails flattens an instance of InstancePreprocessFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessFreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessFreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfo expands an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessFreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceFreezeRecipeMap expands the contents of InstanceFreezeRecipe into a JSON
// request object.
func expandInstanceFreezeRecipeMap(c *Client, f map[string]InstanceFreezeRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeSlice expands the contents of InstanceFreezeRecipe into a JSON
// request object.
func expandInstanceFreezeRecipeSlice(c *Client, f []InstanceFreezeRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeMap flattens the contents of InstanceFreezeRecipe from a JSON
// response object.
func flattenInstanceFreezeRecipeMap(c *Client, i interface{}) map[string]InstanceFreezeRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipe{}
	}

	items := make(map[string]InstanceFreezeRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeSlice flattens the contents of InstanceFreezeRecipe from a JSON
// response object.
func flattenInstanceFreezeRecipeSlice(c *Client, i interface{}) []InstanceFreezeRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipe{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipe{}
	}

	items := make([]InstanceFreezeRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipe expands an instance of InstanceFreezeRecipe into a JSON
// request object.
func expandInstanceFreezeRecipe(c *Client, f *InstanceFreezeRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceFreezeRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipe flattens an instance of InstanceFreezeRecipe from a JSON
// response object.
func flattenInstanceFreezeRecipe(c *Client, i interface{}) *InstanceFreezeRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipe
	}
	r.Steps = flattenInstanceFreezeRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceFreezeRecipeStepsMap expands the contents of InstanceFreezeRecipeSteps into a JSON
// request object.
func expandInstanceFreezeRecipeStepsMap(c *Client, f map[string]InstanceFreezeRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsSlice expands the contents of InstanceFreezeRecipeSteps into a JSON
// request object.
func expandInstanceFreezeRecipeStepsSlice(c *Client, f []InstanceFreezeRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsMap flattens the contents of InstanceFreezeRecipeSteps from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeSteps{}
	}

	items := make(map[string]InstanceFreezeRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsSlice flattens the contents of InstanceFreezeRecipeSteps from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsSlice(c *Client, i interface{}) []InstanceFreezeRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeSteps{}
	}

	items := make([]InstanceFreezeRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeSteps expands an instance of InstanceFreezeRecipeSteps into a JSON
// request object.
func expandInstanceFreezeRecipeSteps(c *Client, f *InstanceFreezeRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeSteps flattens an instance of InstanceFreezeRecipeSteps from a JSON
// response object.
func flattenInstanceFreezeRecipeSteps(c *Client, i interface{}) *InstanceFreezeRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceFreezeRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceFreezeRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceFreezeRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceFreezeRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceFreezeRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceFreezeRecipeStepsStatusMap expands the contents of InstanceFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusMap(c *Client, f map[string]InstanceFreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsStatusSlice expands the contents of InstanceFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusSlice(c *Client, f []InstanceFreezeRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsStatusMap flattens the contents of InstanceFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsStatus{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsStatusSlice flattens the contents of InstanceFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsStatus{}
	}

	items := make([]InstanceFreezeRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsStatus expands an instance of InstanceFreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatus(c *Client, f *InstanceFreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsStatus flattens an instance of InstanceFreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatus(c *Client, i interface{}) *InstanceFreezeRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceFreezeRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceFreezeRecipeStepsStatusDetailsMap expands the contents of InstanceFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceFreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsStatusDetailsSlice expands the contents of InstanceFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusDetailsSlice(c *Client, f []InstanceFreezeRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsStatusDetailsMap flattens the contents of InstanceFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsStatusDetailsSlice flattens the contents of InstanceFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsStatusDetails{}
	}

	items := make([]InstanceFreezeRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsStatusDetails expands an instance of InstanceFreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceFreezeRecipeStepsStatusDetails(c *Client, f *InstanceFreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsStatusDetails flattens an instance of InstanceFreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceFreezeRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceFreezeRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceFreezeRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceFreezeRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsQuotaRequestDeltas expands an instance of InstanceFreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceFreezeRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceFreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsQuotaRequestDeltas flattens an instance of InstanceFreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceFreezeRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceFreezeRecipeStepsPreprocessUpdateMap expands the contents of InstanceFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceFreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPreprocessUpdateSlice expands the contents of InstanceFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceFreezeRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPreprocessUpdateMap flattens the contents of InstanceFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceFreezeRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPreprocessUpdate expands an instance of InstanceFreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPreprocessUpdate(c *Client, f *InstanceFreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPreprocessUpdate flattens an instance of InstanceFreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceFreezeRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceFreezeRecipeStepsRequestedTenantProjectMap expands the contents of InstanceFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceFreezeRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceFreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceFreezeRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceFreezeRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsRequestedTenantProject expands an instance of InstanceFreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceFreezeRecipeStepsRequestedTenantProject(c *Client, f *InstanceFreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProject flattens an instance of InstanceFreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceFreezeRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceFreezeRecipeStepsPermissionsInfoMap expands the contents of InstanceFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceFreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPermissionsInfoSlice expands the contents of InstanceFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceFreezeRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoMap flattens the contents of InstanceFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoSlice flattens the contents of InstanceFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceFreezeRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPermissionsInfo expands an instance of InstanceFreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfo(c *Client, f *InstanceFreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfo flattens an instance of InstanceFreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceFreezeRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceFreezeRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceFreezeRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceFreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceFreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceFreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceFreezeRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceFreezeRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceFreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceFreezeRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceFreezeRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceFreezeRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdate expands an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceFreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceFreezeRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceFreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeMap expands the contents of InstancePreprocessUnfreezeRecipe into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeSlice expands the contents of InstancePreprocessUnfreezeRecipe into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeSlice(c *Client, f []InstancePreprocessUnfreezeRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeMap flattens the contents of InstancePreprocessUnfreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipe{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeSlice flattens the contents of InstancePreprocessUnfreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipe{}
	}

	items := make([]InstancePreprocessUnfreezeRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipe expands an instance of InstancePreprocessUnfreezeRecipe into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipe(c *Client, f *InstancePreprocessUnfreezeRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipe flattens an instance of InstancePreprocessUnfreezeRecipe from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipe(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipe
	}
	r.Steps = flattenInstancePreprocessUnfreezeRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsMap expands the contents of InstancePreprocessUnfreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsSlice expands the contents of InstancePreprocessUnfreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsMap flattens the contents of InstancePreprocessUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsSlice flattens the contents of InstancePreprocessUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeSteps{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeSteps expands an instance of InstancePreprocessUnfreezeRecipeSteps into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeSteps(c *Client, f *InstancePreprocessUnfreezeRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeSteps flattens an instance of InstancePreprocessUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeSteps(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessUnfreezeRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessUnfreezeRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusMap expands the contents of InstancePreprocessUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsStatus expands an instance of InstancePreprocessUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatus(c *Client, f *InstancePreprocessUnfreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatus flattens an instance of InstancePreprocessUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsStatusDetails expands an instance of InstancePreprocessUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsStatusDetails(c *Client, f *InstancePreprocessUnfreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsStatusDetails flattens an instance of InstancePreprocessUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfo expands an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceUnfreezeRecipeMap expands the contents of InstanceUnfreezeRecipe into a JSON
// request object.
func expandInstanceUnfreezeRecipeMap(c *Client, f map[string]InstanceUnfreezeRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeSlice expands the contents of InstanceUnfreezeRecipe into a JSON
// request object.
func expandInstanceUnfreezeRecipeSlice(c *Client, f []InstanceUnfreezeRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeMap flattens the contents of InstanceUnfreezeRecipe from a JSON
// response object.
func flattenInstanceUnfreezeRecipeMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipe{}
	}

	items := make(map[string]InstanceUnfreezeRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeSlice flattens the contents of InstanceUnfreezeRecipe from a JSON
// response object.
func flattenInstanceUnfreezeRecipeSlice(c *Client, i interface{}) []InstanceUnfreezeRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipe{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipe{}
	}

	items := make([]InstanceUnfreezeRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipe expands an instance of InstanceUnfreezeRecipe into a JSON
// request object.
func expandInstanceUnfreezeRecipe(c *Client, f *InstanceUnfreezeRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceUnfreezeRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipe flattens an instance of InstanceUnfreezeRecipe from a JSON
// response object.
func flattenInstanceUnfreezeRecipe(c *Client, i interface{}) *InstanceUnfreezeRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipe
	}
	r.Steps = flattenInstanceUnfreezeRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceUnfreezeRecipeStepsMap expands the contents of InstanceUnfreezeRecipeSteps into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsMap(c *Client, f map[string]InstanceUnfreezeRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsSlice expands the contents of InstanceUnfreezeRecipeSteps into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsSlice(c *Client, f []InstanceUnfreezeRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsMap flattens the contents of InstanceUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeSteps{}
	}

	items := make(map[string]InstanceUnfreezeRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsSlice flattens the contents of InstanceUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeSteps{}
	}

	items := make([]InstanceUnfreezeRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeSteps expands an instance of InstanceUnfreezeRecipeSteps into a JSON
// request object.
func expandInstanceUnfreezeRecipeSteps(c *Client, f *InstanceUnfreezeRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeSteps flattens an instance of InstanceUnfreezeRecipeSteps from a JSON
// response object.
func flattenInstanceUnfreezeRecipeSteps(c *Client, i interface{}) *InstanceUnfreezeRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceUnfreezeRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceUnfreezeRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceUnfreezeRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceUnfreezeRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceUnfreezeRecipeStepsStatusMap expands the contents of InstanceUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsStatusSlice expands the contents of InstanceUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusSlice(c *Client, f []InstanceUnfreezeRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsStatusMap flattens the contents of InstanceUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsStatus{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsStatusSlice flattens the contents of InstanceUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsStatus{}
	}

	items := make([]InstanceUnfreezeRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsStatus expands an instance of InstanceUnfreezeRecipeStepsStatus into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatus(c *Client, f *InstanceUnfreezeRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsStatus flattens an instance of InstanceUnfreezeRecipeStepsStatus from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatus(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceUnfreezeRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceUnfreezeRecipeStepsStatusDetailsMap expands the contents of InstanceUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsStatusDetailsSlice expands the contents of InstanceUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusDetailsSlice(c *Client, f []InstanceUnfreezeRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsStatusDetailsMap flattens the contents of InstanceUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsStatusDetailsSlice flattens the contents of InstanceUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsStatusDetails{}
	}

	items := make([]InstanceUnfreezeRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsStatusDetails expands an instance of InstanceUnfreezeRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsStatusDetails(c *Client, f *InstanceUnfreezeRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsStatusDetails flattens an instance of InstanceUnfreezeRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceUnfreezeRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceUnfreezeRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsQuotaRequestDeltas expands an instance of InstanceUnfreezeRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceUnfreezeRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltas flattens an instance of InstanceUnfreezeRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPreprocessUpdateMap expands the contents of InstanceUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPreprocessUpdateSlice expands the contents of InstanceUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceUnfreezeRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPreprocessUpdateMap flattens the contents of InstanceUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPreprocessUpdate expands an instance of InstanceUnfreezeRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPreprocessUpdate(c *Client, f *InstanceUnfreezeRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPreprocessUpdate flattens an instance of InstanceUnfreezeRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceUnfreezeRecipeStepsRequestedTenantProjectMap expands the contents of InstanceUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceUnfreezeRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceUnfreezeRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsRequestedTenantProject expands an instance of InstanceUnfreezeRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsRequestedTenantProject(c *Client, f *InstanceUnfreezeRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProject flattens an instance of InstanceUnfreezeRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoMap expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoSlice expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceUnfreezeRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoMap flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoSlice flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfo expands an instance of InstanceUnfreezeRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfo(c *Client, f *InstanceUnfreezeRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfo flattens an instance of InstanceUnfreezeRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceUnfreezeRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate expands an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceUnfreezeRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeMap expands the contents of InstancePreprocessReportInstanceHealthRecipe into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeSlice expands the contents of InstancePreprocessReportInstanceHealthRecipe into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeMap flattens the contents of InstancePreprocessReportInstanceHealthRecipe from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipe{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipe from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipe{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipe expands an instance of InstancePreprocessReportInstanceHealthRecipe into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipe(c *Client, f *InstancePreprocessReportInstanceHealthRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipe flattens an instance of InstancePreprocessReportInstanceHealthRecipe from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipe(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipe
	}
	r.Steps = flattenInstancePreprocessReportInstanceHealthRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsMap expands the contents of InstancePreprocessReportInstanceHealthRecipeSteps into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeSteps into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeSteps{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeSteps expands an instance of InstancePreprocessReportInstanceHealthRecipeSteps into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeSteps(c *Client, f *InstancePreprocessReportInstanceHealthRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeSteps flattens an instance of InstancePreprocessReportInstanceHealthRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeSteps(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessReportInstanceHealthRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessReportInstanceHealthRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsStatusMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsStatusSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsStatusSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsStatus expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsStatus(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsStatus flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceReportInstanceHealthRecipeMap expands the contents of InstanceReportInstanceHealthRecipe into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeMap(c *Client, f map[string]InstanceReportInstanceHealthRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeSlice expands the contents of InstanceReportInstanceHealthRecipe into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeSlice(c *Client, f []InstanceReportInstanceHealthRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeMap flattens the contents of InstanceReportInstanceHealthRecipe from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipe{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeSlice flattens the contents of InstanceReportInstanceHealthRecipe from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipe{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipe{}
	}

	items := make([]InstanceReportInstanceHealthRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipe expands an instance of InstanceReportInstanceHealthRecipe into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipe(c *Client, f *InstanceReportInstanceHealthRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReportInstanceHealthRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipe flattens an instance of InstanceReportInstanceHealthRecipe from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipe(c *Client, i interface{}) *InstanceReportInstanceHealthRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipe
	}
	r.Steps = flattenInstanceReportInstanceHealthRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsMap expands the contents of InstanceReportInstanceHealthRecipeSteps into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsSlice expands the contents of InstanceReportInstanceHealthRecipeSteps into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsSlice(c *Client, f []InstanceReportInstanceHealthRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsMap flattens the contents of InstanceReportInstanceHealthRecipeSteps from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeSteps{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsSlice flattens the contents of InstanceReportInstanceHealthRecipeSteps from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeSteps{}
	}

	items := make([]InstanceReportInstanceHealthRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeSteps expands an instance of InstanceReportInstanceHealthRecipeSteps into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeSteps(c *Client, f *InstanceReportInstanceHealthRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeSteps flattens an instance of InstanceReportInstanceHealthRecipeSteps from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeSteps(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceReportInstanceHealthRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceReportInstanceHealthRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsStatusMap expands the contents of InstanceReportInstanceHealthRecipeStepsStatus into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsStatusMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsStatusSlice expands the contents of InstanceReportInstanceHealthRecipeStepsStatus into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsStatusSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsStatusMap flattens the contents of InstanceReportInstanceHealthRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsStatus{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsStatusSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsStatus{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsStatus expands an instance of InstanceReportInstanceHealthRecipeStepsStatus into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsStatus(c *Client, f *InstanceReportInstanceHealthRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsStatus flattens an instance of InstanceReportInstanceHealthRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsStatus(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceReportInstanceHealthRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsStatusDetailsMap expands the contents of InstanceReportInstanceHealthRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsStatusDetailsSlice expands the contents of InstanceReportInstanceHealthRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsStatusDetailsSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsStatusDetailsMap flattens the contents of InstanceReportInstanceHealthRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsStatusDetailsSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsStatusDetails{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsStatusDetails expands an instance of InstanceReportInstanceHealthRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsStatusDetails(c *Client, f *InstanceReportInstanceHealthRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsStatusDetails flattens an instance of InstanceReportInstanceHealthRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas expands an instance of InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas flattens an instance of InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdateMap expands the contents of InstanceReportInstanceHealthRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdateSlice expands the contents of InstanceReportInstanceHealthRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdateMap flattens the contents of InstanceReportInstanceHealthRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdate expands an instance of InstanceReportInstanceHealthRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c *Client, f *InstanceReportInstanceHealthRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdate flattens an instance of InstanceReportInstanceHealthRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectMap expands the contents of InstanceReportInstanceHealthRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceReportInstanceHealthRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceReportInstanceHealthRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProject expands an instance of InstanceReportInstanceHealthRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c *Client, f *InstanceReportInstanceHealthRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProject flattens an instance of InstanceReportInstanceHealthRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoMap expands the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoSlice expands the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoMap flattens the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfo expands an instance of InstanceReportInstanceHealthRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfo(c *Client, f *InstanceReportInstanceHealthRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfo flattens an instance of InstanceReportInstanceHealthRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate expands an instance of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReportInstanceHealthRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessGetRecipeMap expands the contents of InstancePreprocessGetRecipe into a JSON
// request object.
func expandInstancePreprocessGetRecipeMap(c *Client, f map[string]InstancePreprocessGetRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeSlice expands the contents of InstancePreprocessGetRecipe into a JSON
// request object.
func expandInstancePreprocessGetRecipeSlice(c *Client, f []InstancePreprocessGetRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeMap flattens the contents of InstancePreprocessGetRecipe from a JSON
// response object.
func flattenInstancePreprocessGetRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipe{}
	}

	items := make(map[string]InstancePreprocessGetRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeSlice flattens the contents of InstancePreprocessGetRecipe from a JSON
// response object.
func flattenInstancePreprocessGetRecipeSlice(c *Client, i interface{}) []InstancePreprocessGetRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipe{}
	}

	items := make([]InstancePreprocessGetRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipe expands an instance of InstancePreprocessGetRecipe into a JSON
// request object.
func expandInstancePreprocessGetRecipe(c *Client, f *InstancePreprocessGetRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessGetRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipe flattens an instance of InstancePreprocessGetRecipe from a JSON
// response object.
func flattenInstancePreprocessGetRecipe(c *Client, i interface{}) *InstancePreprocessGetRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipe
	}
	r.Steps = flattenInstancePreprocessGetRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessGetRecipeStepsMap expands the contents of InstancePreprocessGetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsMap(c *Client, f map[string]InstancePreprocessGetRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsSlice expands the contents of InstancePreprocessGetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsSlice(c *Client, f []InstancePreprocessGetRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsMap flattens the contents of InstancePreprocessGetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessGetRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsSlice flattens the contents of InstancePreprocessGetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeSteps{}
	}

	items := make([]InstancePreprocessGetRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeSteps expands an instance of InstancePreprocessGetRecipeSteps into a JSON
// request object.
func expandInstancePreprocessGetRecipeSteps(c *Client, f *InstancePreprocessGetRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeSteps flattens an instance of InstancePreprocessGetRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessGetRecipeSteps(c *Client, i interface{}) *InstancePreprocessGetRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessGetRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessGetRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessGetRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessGetRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessGetRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessGetRecipeStepsStatusMap expands the contents of InstancePreprocessGetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsStatusSlice expands the contents of InstancePreprocessGetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsStatusSlice(c *Client, f []InstancePreprocessGetRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsStatusMap flattens the contents of InstancePreprocessGetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsStatusSlice flattens the contents of InstancePreprocessGetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessGetRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsStatus expands an instance of InstancePreprocessGetRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsStatus(c *Client, f *InstancePreprocessGetRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsStatus flattens an instance of InstancePreprocessGetRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessGetRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessGetRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessGetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessGetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessGetRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessGetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessGetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessGetRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsStatusDetails expands an instance of InstancePreprocessGetRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsStatusDetails(c *Client, f *InstancePreprocessGetRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsStatusDetails flattens an instance of InstancePreprocessGetRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessGetRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessGetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessGetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessGetRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessGetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessGetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessGetRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessGetRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessGetRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessGetRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessGetRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessGetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessGetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessGetRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessGetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessGetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessGetRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessGetRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessGetRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessGetRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessGetRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessGetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessGetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessGetRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessGetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessGetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessGetRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessGetRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessGetRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessGetRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessGetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessGetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessGetRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessGetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessGetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessGetRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfo expands an instance of InstancePreprocessGetRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessGetRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessGetRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessGetRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessGetRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessGetRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessGetRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessGetRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeMap expands the contents of InstanceNotifyKeyAvailableRecipe into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeSlice expands the contents of InstanceNotifyKeyAvailableRecipe into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeSlice(c *Client, f []InstanceNotifyKeyAvailableRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeMap flattens the contents of InstanceNotifyKeyAvailableRecipe from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipe{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeSlice flattens the contents of InstanceNotifyKeyAvailableRecipe from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipe{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipe{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipe expands an instance of InstanceNotifyKeyAvailableRecipe into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipe(c *Client, f *InstanceNotifyKeyAvailableRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipe flattens an instance of InstanceNotifyKeyAvailableRecipe from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipe(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipe
	}
	r.Steps = flattenInstanceNotifyKeyAvailableRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsMap expands the contents of InstanceNotifyKeyAvailableRecipeSteps into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsSlice expands the contents of InstanceNotifyKeyAvailableRecipeSteps into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsMap flattens the contents of InstanceNotifyKeyAvailableRecipeSteps from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeSteps{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsSlice flattens the contents of InstanceNotifyKeyAvailableRecipeSteps from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeSteps{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeSteps expands an instance of InstanceNotifyKeyAvailableRecipeSteps into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeSteps(c *Client, f *InstanceNotifyKeyAvailableRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeSteps flattens an instance of InstanceNotifyKeyAvailableRecipeSteps from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeSteps(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceNotifyKeyAvailableRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceNotifyKeyAvailableRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsStatusMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsStatus into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsStatusMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsStatusSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsStatus into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsStatusSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsStatusMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsStatus from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsStatus{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsStatusSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsStatus from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsStatus{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsStatus expands an instance of InstanceNotifyKeyAvailableRecipeStepsStatus into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsStatus(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsStatus flattens an instance of InstanceNotifyKeyAvailableRecipeStepsStatus from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsStatus(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsStatusDetailsMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetailsMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsStatusDetails{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsStatusDetails expands an instance of InstanceNotifyKeyAvailableRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsStatusDetails(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetails flattens an instance of InstanceNotifyKeyAvailableRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas expands an instance of InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas flattens an instance of InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate expands an instance of InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate flattens an instance of InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject expands an instance of InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject flattens an instance of InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo expands an instance of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo flattens an instance of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate expands an instance of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyAvailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeMap expands the contents of InstanceNotifyKeyUnavailableRecipe into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeSlice expands the contents of InstanceNotifyKeyUnavailableRecipe into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeMap flattens the contents of InstanceNotifyKeyUnavailableRecipe from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipe{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeSlice flattens the contents of InstanceNotifyKeyUnavailableRecipe from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipe{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipe{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipe expands an instance of InstanceNotifyKeyUnavailableRecipe into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipe(c *Client, f *InstanceNotifyKeyUnavailableRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipe flattens an instance of InstanceNotifyKeyUnavailableRecipe from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipe(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipe
	}
	r.Steps = flattenInstanceNotifyKeyUnavailableRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsMap expands the contents of InstanceNotifyKeyUnavailableRecipeSteps into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsSlice expands the contents of InstanceNotifyKeyUnavailableRecipeSteps into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsMap flattens the contents of InstanceNotifyKeyUnavailableRecipeSteps from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeSteps{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeSteps from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeSteps{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeSteps expands an instance of InstanceNotifyKeyUnavailableRecipeSteps into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeSteps(c *Client, f *InstanceNotifyKeyUnavailableRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeSteps flattens an instance of InstanceNotifyKeyUnavailableRecipeSteps from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeSteps(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceNotifyKeyUnavailableRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceNotifyKeyUnavailableRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsStatusMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsStatus into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsStatusMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsStatusSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsStatus into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsStatusSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsStatusMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsStatus from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsStatus{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsStatusSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsStatus from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsStatus{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsStatus expands an instance of InstanceNotifyKeyUnavailableRecipeStepsStatus into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsStatus(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsStatus flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsStatus from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsStatus(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsStatusDetails{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetails expands an instance of InstanceNotifyKeyUnavailableRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetails flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas expands an instance of InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate expands an instance of InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject expands an instance of InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo expands an instance of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate expands an instance of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceNotifyKeyUnavailableRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceReadonlyRecipeMap expands the contents of InstanceReadonlyRecipe into a JSON
// request object.
func expandInstanceReadonlyRecipeMap(c *Client, f map[string]InstanceReadonlyRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeSlice expands the contents of InstanceReadonlyRecipe into a JSON
// request object.
func expandInstanceReadonlyRecipeSlice(c *Client, f []InstanceReadonlyRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeMap flattens the contents of InstanceReadonlyRecipe from a JSON
// response object.
func flattenInstanceReadonlyRecipeMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipe{}
	}

	items := make(map[string]InstanceReadonlyRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeSlice flattens the contents of InstanceReadonlyRecipe from a JSON
// response object.
func flattenInstanceReadonlyRecipeSlice(c *Client, i interface{}) []InstanceReadonlyRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipe{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipe{}
	}

	items := make([]InstanceReadonlyRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipe expands an instance of InstanceReadonlyRecipe into a JSON
// request object.
func expandInstanceReadonlyRecipe(c *Client, f *InstanceReadonlyRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReadonlyRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipe flattens an instance of InstanceReadonlyRecipe from a JSON
// response object.
func flattenInstanceReadonlyRecipe(c *Client, i interface{}) *InstanceReadonlyRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipe
	}
	r.Steps = flattenInstanceReadonlyRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceReadonlyRecipeStepsMap expands the contents of InstanceReadonlyRecipeSteps into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsMap(c *Client, f map[string]InstanceReadonlyRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsSlice expands the contents of InstanceReadonlyRecipeSteps into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsSlice(c *Client, f []InstanceReadonlyRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsMap flattens the contents of InstanceReadonlyRecipeSteps from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeSteps{}
	}

	items := make(map[string]InstanceReadonlyRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsSlice flattens the contents of InstanceReadonlyRecipeSteps from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeSteps{}
	}

	items := make([]InstanceReadonlyRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeSteps expands an instance of InstanceReadonlyRecipeSteps into a JSON
// request object.
func expandInstanceReadonlyRecipeSteps(c *Client, f *InstanceReadonlyRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeSteps flattens an instance of InstanceReadonlyRecipeSteps from a JSON
// response object.
func flattenInstanceReadonlyRecipeSteps(c *Client, i interface{}) *InstanceReadonlyRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceReadonlyRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceReadonlyRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceReadonlyRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceReadonlyRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceReadonlyRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceReadonlyRecipeStepsStatusMap expands the contents of InstanceReadonlyRecipeStepsStatus into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusMap(c *Client, f map[string]InstanceReadonlyRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsStatusSlice expands the contents of InstanceReadonlyRecipeStepsStatus into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusSlice(c *Client, f []InstanceReadonlyRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsStatusMap flattens the contents of InstanceReadonlyRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsStatus{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsStatusSlice flattens the contents of InstanceReadonlyRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsStatus{}
	}

	items := make([]InstanceReadonlyRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsStatus expands an instance of InstanceReadonlyRecipeStepsStatus into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatus(c *Client, f *InstanceReadonlyRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsStatus flattens an instance of InstanceReadonlyRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatus(c *Client, i interface{}) *InstanceReadonlyRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceReadonlyRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceReadonlyRecipeStepsStatusDetailsMap expands the contents of InstanceReadonlyRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceReadonlyRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsStatusDetailsSlice expands the contents of InstanceReadonlyRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusDetailsSlice(c *Client, f []InstanceReadonlyRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsStatusDetailsMap flattens the contents of InstanceReadonlyRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsStatusDetailsSlice flattens the contents of InstanceReadonlyRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsStatusDetails{}
	}

	items := make([]InstanceReadonlyRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsStatusDetails expands an instance of InstanceReadonlyRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsStatusDetails(c *Client, f *InstanceReadonlyRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsStatusDetails flattens an instance of InstanceReadonlyRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceReadonlyRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceReadonlyRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceReadonlyRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceReadonlyRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceReadonlyRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceReadonlyRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceReadonlyRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceReadonlyRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsQuotaRequestDeltas expands an instance of InstanceReadonlyRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceReadonlyRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsQuotaRequestDeltas flattens an instance of InstanceReadonlyRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceReadonlyRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceReadonlyRecipeStepsPreprocessUpdateMap expands the contents of InstanceReadonlyRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPreprocessUpdateSlice expands the contents of InstanceReadonlyRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceReadonlyRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPreprocessUpdateMap flattens the contents of InstanceReadonlyRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceReadonlyRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceReadonlyRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPreprocessUpdate expands an instance of InstanceReadonlyRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPreprocessUpdate(c *Client, f *InstanceReadonlyRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPreprocessUpdate flattens an instance of InstanceReadonlyRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceReadonlyRecipeStepsRequestedTenantProjectMap expands the contents of InstanceReadonlyRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceReadonlyRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceReadonlyRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceReadonlyRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceReadonlyRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceReadonlyRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceReadonlyRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsRequestedTenantProject expands an instance of InstanceReadonlyRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsRequestedTenantProject(c *Client, f *InstanceReadonlyRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProject flattens an instance of InstanceReadonlyRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceReadonlyRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoMap expands the contents of InstanceReadonlyRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoSlice expands the contents of InstanceReadonlyRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceReadonlyRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoMap flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoSlice flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceReadonlyRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPermissionsInfo expands an instance of InstanceReadonlyRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfo(c *Client, f *InstanceReadonlyRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfo flattens an instance of InstanceReadonlyRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceReadonlyRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceReadonlyRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceReadonlyRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceReadonlyRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate expands an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceReadonlyRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceReadonlyRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReadonlyRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceReconcileRecipeMap expands the contents of InstanceReconcileRecipe into a JSON
// request object.
func expandInstanceReconcileRecipeMap(c *Client, f map[string]InstanceReconcileRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeSlice expands the contents of InstanceReconcileRecipe into a JSON
// request object.
func expandInstanceReconcileRecipeSlice(c *Client, f []InstanceReconcileRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeMap flattens the contents of InstanceReconcileRecipe from a JSON
// response object.
func flattenInstanceReconcileRecipeMap(c *Client, i interface{}) map[string]InstanceReconcileRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipe{}
	}

	items := make(map[string]InstanceReconcileRecipe)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeSlice flattens the contents of InstanceReconcileRecipe from a JSON
// response object.
func flattenInstanceReconcileRecipeSlice(c *Client, i interface{}) []InstanceReconcileRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipe{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipe{}
	}

	items := make([]InstanceReconcileRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipe expands an instance of InstanceReconcileRecipe into a JSON
// request object.
func expandInstanceReconcileRecipe(c *Client, f *InstanceReconcileRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReconcileRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipe flattens an instance of InstanceReconcileRecipe from a JSON
// response object.
func flattenInstanceReconcileRecipe(c *Client, i interface{}) *InstanceReconcileRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipe
	}
	r.Steps = flattenInstanceReconcileRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstanceReconcileRecipeStepsMap expands the contents of InstanceReconcileRecipeSteps into a JSON
// request object.
func expandInstanceReconcileRecipeStepsMap(c *Client, f map[string]InstanceReconcileRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsSlice expands the contents of InstanceReconcileRecipeSteps into a JSON
// request object.
func expandInstanceReconcileRecipeStepsSlice(c *Client, f []InstanceReconcileRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsMap flattens the contents of InstanceReconcileRecipeSteps from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeSteps{}
	}

	items := make(map[string]InstanceReconcileRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsSlice flattens the contents of InstanceReconcileRecipeSteps from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsSlice(c *Client, i interface{}) []InstanceReconcileRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeSteps{}
	}

	items := make([]InstanceReconcileRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeSteps expands an instance of InstanceReconcileRecipeSteps into a JSON
// request object.
func expandInstanceReconcileRecipeSteps(c *Client, f *InstanceReconcileRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeSteps flattens an instance of InstanceReconcileRecipeSteps from a JSON
// response object.
func flattenInstanceReconcileRecipeSteps(c *Client, i interface{}) *InstanceReconcileRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstanceReconcileRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstanceReconcileRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstanceReconcileRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstanceReconcileRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstanceReconcileRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstanceReconcileRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstanceReconcileRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstanceReconcileRecipeStepsStatusMap expands the contents of InstanceReconcileRecipeStepsStatus into a JSON
// request object.
func expandInstanceReconcileRecipeStepsStatusMap(c *Client, f map[string]InstanceReconcileRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsStatusSlice expands the contents of InstanceReconcileRecipeStepsStatus into a JSON
// request object.
func expandInstanceReconcileRecipeStepsStatusSlice(c *Client, f []InstanceReconcileRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsStatusMap flattens the contents of InstanceReconcileRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsStatus{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsStatusSlice flattens the contents of InstanceReconcileRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsStatusSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsStatus{}
	}

	items := make([]InstanceReconcileRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsStatus expands an instance of InstanceReconcileRecipeStepsStatus into a JSON
// request object.
func expandInstanceReconcileRecipeStepsStatus(c *Client, f *InstanceReconcileRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsStatus flattens an instance of InstanceReconcileRecipeStepsStatus from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsStatus(c *Client, i interface{}) *InstanceReconcileRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstanceReconcileRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstanceReconcileRecipeStepsStatusDetailsMap expands the contents of InstanceReconcileRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReconcileRecipeStepsStatusDetailsMap(c *Client, f map[string]InstanceReconcileRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsStatusDetailsSlice expands the contents of InstanceReconcileRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReconcileRecipeStepsStatusDetailsSlice(c *Client, f []InstanceReconcileRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsStatusDetailsMap flattens the contents of InstanceReconcileRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsStatusDetailsSlice flattens the contents of InstanceReconcileRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsStatusDetails{}
	}

	items := make([]InstanceReconcileRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsStatusDetails expands an instance of InstanceReconcileRecipeStepsStatusDetails into a JSON
// request object.
func expandInstanceReconcileRecipeStepsStatusDetails(c *Client, f *InstanceReconcileRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsStatusDetails flattens an instance of InstanceReconcileRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsStatusDetails(c *Client, i interface{}) *InstanceReconcileRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstanceReconcileRecipeStepsQuotaRequestDeltasMap expands the contents of InstanceReconcileRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReconcileRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstanceReconcileRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsQuotaRequestDeltasSlice expands the contents of InstanceReconcileRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReconcileRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstanceReconcileRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsQuotaRequestDeltasMap flattens the contents of InstanceReconcileRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstanceReconcileRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstanceReconcileRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsQuotaRequestDeltas expands an instance of InstanceReconcileRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstanceReconcileRecipeStepsQuotaRequestDeltas(c *Client, f *InstanceReconcileRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsQuotaRequestDeltas flattens an instance of InstanceReconcileRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstanceReconcileRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstanceReconcileRecipeStepsPreprocessUpdateMap expands the contents of InstanceReconcileRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstanceReconcileRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsPreprocessUpdateSlice expands the contents of InstanceReconcileRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPreprocessUpdateSlice(c *Client, f []InstanceReconcileRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsPreprocessUpdateMap flattens the contents of InstanceReconcileRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsPreprocessUpdateSlice flattens the contents of InstanceReconcileRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstanceReconcileRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsPreprocessUpdate expands an instance of InstanceReconcileRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPreprocessUpdate(c *Client, f *InstanceReconcileRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsPreprocessUpdate flattens an instance of InstanceReconcileRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstanceReconcileRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstanceReconcileRecipeStepsRequestedTenantProjectMap expands the contents of InstanceReconcileRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReconcileRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstanceReconcileRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsRequestedTenantProjectSlice expands the contents of InstanceReconcileRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReconcileRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstanceReconcileRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsRequestedTenantProjectMap flattens the contents of InstanceReconcileRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsRequestedTenantProjectSlice flattens the contents of InstanceReconcileRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstanceReconcileRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsRequestedTenantProject expands an instance of InstanceReconcileRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstanceReconcileRecipeStepsRequestedTenantProject(c *Client, f *InstanceReconcileRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsRequestedTenantProject flattens an instance of InstanceReconcileRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstanceReconcileRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstanceReconcileRecipeStepsPermissionsInfoMap expands the contents of InstanceReconcileRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstanceReconcileRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsPermissionsInfoSlice expands the contents of InstanceReconcileRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfoSlice(c *Client, f []InstanceReconcileRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsPermissionsInfoMap flattens the contents of InstanceReconcileRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsPermissionsInfoSlice flattens the contents of InstanceReconcileRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsPermissionsInfo{}
	}

	items := make([]InstanceReconcileRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsPermissionsInfo expands an instance of InstanceReconcileRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfo(c *Client, f *InstanceReconcileRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsPermissionsInfo flattens an instance of InstanceReconcileRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstanceReconcileRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstanceReconcileRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstanceReconcileRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstanceReconcileRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstanceReconcileRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstanceReconcileRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstanceReconcileRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstanceReconcileRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstanceReconcileRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsPermissionsInfoPolicyName expands an instance of InstanceReconcileRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstanceReconcileRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyName flattens an instance of InstanceReconcileRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstanceReconcileRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstanceReconcileRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstanceReconcileRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstanceReconcileRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstanceReconcileRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstanceReconcileRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstanceReconcileRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissions expands an instance of InstanceReconcileRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstanceReconcileRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstanceReconcileRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstanceReconcileRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdateMap expands the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstanceReconcileRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstanceReconcileRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdate expands an instance of InstanceReconcileRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdate(c *Client, f *InstanceReconcileRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdate flattens an instance of InstanceReconcileRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstanceReconcileRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessPassthroughRecipeMap expands the contents of InstancePreprocessPassthroughRecipe into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeMap(c *Client, f map[string]InstancePreprocessPassthroughRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeSlice expands the contents of InstancePreprocessPassthroughRecipe into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeSlice(c *Client, f []InstancePreprocessPassthroughRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeMap flattens the contents of InstancePreprocessPassthroughRecipe from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipe{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeSlice flattens the contents of InstancePreprocessPassthroughRecipe from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipe{}
	}

	items := make([]InstancePreprocessPassthroughRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipe expands an instance of InstancePreprocessPassthroughRecipe into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipe(c *Client, f *InstancePreprocessPassthroughRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessPassthroughRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipe flattens an instance of InstancePreprocessPassthroughRecipe from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipe(c *Client, i interface{}) *InstancePreprocessPassthroughRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipe
	}
	r.Steps = flattenInstancePreprocessPassthroughRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsMap expands the contents of InstancePreprocessPassthroughRecipeSteps into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsSlice expands the contents of InstancePreprocessPassthroughRecipeSteps into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsSlice(c *Client, f []InstancePreprocessPassthroughRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsMap flattens the contents of InstancePreprocessPassthroughRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsSlice flattens the contents of InstancePreprocessPassthroughRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeSteps{}
	}

	items := make([]InstancePreprocessPassthroughRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeSteps expands an instance of InstancePreprocessPassthroughRecipeSteps into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeSteps(c *Client, f *InstancePreprocessPassthroughRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeSteps flattens an instance of InstancePreprocessPassthroughRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeSteps(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessPassthroughRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessPassthroughRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsStatusMap expands the contents of InstancePreprocessPassthroughRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsStatusSlice expands the contents of InstancePreprocessPassthroughRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsStatusSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsStatusMap flattens the contents of InstancePreprocessPassthroughRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsStatusSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsStatus expands an instance of InstancePreprocessPassthroughRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsStatus(c *Client, f *InstancePreprocessPassthroughRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsStatus flattens an instance of InstancePreprocessPassthroughRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessPassthroughRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessPassthroughRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessPassthroughRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessPassthroughRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsStatusDetails expands an instance of InstancePreprocessPassthroughRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsStatusDetails(c *Client, f *InstancePreprocessPassthroughRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsStatusDetails flattens an instance of InstancePreprocessPassthroughRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessPassthroughRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessPassthroughRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessPassthroughRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessPassthroughRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessPassthroughRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessPassthroughRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessPassthroughRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessPassthroughRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessPassthroughRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessPassthroughRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessPassthroughRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessPassthroughRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfo expands an instance of InstancePreprocessPassthroughRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessPassthroughRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessPassthroughRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessPassthroughRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstancePreprocessReconcileRecipeMap expands the contents of InstancePreprocessReconcileRecipe into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeMap(c *Client, f map[string]InstancePreprocessReconcileRecipe) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipe(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeSlice expands the contents of InstancePreprocessReconcileRecipe into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeSlice(c *Client, f []InstancePreprocessReconcileRecipe) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipe(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeMap flattens the contents of InstancePreprocessReconcileRecipe from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipe {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipe{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipe{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipe)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipe(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeSlice flattens the contents of InstancePreprocessReconcileRecipe from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipe {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipe{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipe{}
	}

	items := make([]InstancePreprocessReconcileRecipe, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipe(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipe expands an instance of InstancePreprocessReconcileRecipe into a JSON
// request object.
func expandInstancePreprocessReconcileRecipe(c *Client, f *InstancePreprocessReconcileRecipe) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessReconcileRecipeStepsSlice(c, f.Steps); err != nil {
		return nil, fmt.Errorf("error expanding Steps into steps: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["steps"] = v
	}
	if v := f.HonorCancelRequest; !dcl.IsEmptyValueIndirect(v) {
		m["honorCancelRequest"] = v
	}
	if v := f.IgnoreRecipeAfter; !dcl.IsEmptyValueIndirect(v) {
		m["ignoreRecipeAfter"] = v
	}
	if v := f.VerifyDeadlineSecondsBelow; !dcl.IsEmptyValueIndirect(v) {
		m["verifyDeadlineSecondsBelow"] = v
	}
	if v := f.PopulateOperationResult; !dcl.IsEmptyValueIndirect(v) {
		m["populateOperationResult"] = v
	}
	if v := f.ReadonlyRecipeStartTime; !dcl.IsEmptyValueIndirect(v) {
		m["readonlyRecipeStartTime"] = v
	}
	if v := f.ResourceNamesStoredInClhWithDelay; !dcl.IsEmptyValueIndirect(v) {
		m["resourceNamesStoredInClhWithDelay"] = v
	}
	if v := f.DelayToStoreResourcesInClhDbNanos; !dcl.IsEmptyValueIndirect(v) {
		m["delayToStoreResourcesInClhDbNanos"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipe flattens an instance of InstancePreprocessReconcileRecipe from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipe(c *Client, i interface{}) *InstancePreprocessReconcileRecipe {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipe{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipe
	}
	r.Steps = flattenInstancePreprocessReconcileRecipeStepsSlice(c, m["steps"])
	r.HonorCancelRequest = dcl.FlattenBool(m["honorCancelRequest"])
	r.IgnoreRecipeAfter = dcl.FlattenInteger(m["ignoreRecipeAfter"])
	r.VerifyDeadlineSecondsBelow = dcl.FlattenDouble(m["verifyDeadlineSecondsBelow"])
	r.PopulateOperationResult = dcl.FlattenBool(m["populateOperationResult"])
	r.ReadonlyRecipeStartTime = dcl.FlattenString(m["readonlyRecipeStartTime"])
	r.ResourceNamesStoredInClhWithDelay = dcl.FlattenStringSlice(m["resourceNamesStoredInClhWithDelay"])
	r.DelayToStoreResourcesInClhDbNanos = dcl.FlattenInteger(m["delayToStoreResourcesInClhDbNanos"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsMap expands the contents of InstancePreprocessReconcileRecipeSteps into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsMap(c *Client, f map[string]InstancePreprocessReconcileRecipeSteps) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsSlice expands the contents of InstancePreprocessReconcileRecipeSteps into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsSlice(c *Client, f []InstancePreprocessReconcileRecipeSteps) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeSteps(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsMap flattens the contents of InstancePreprocessReconcileRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeSteps {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeSteps{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeSteps{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeSteps)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeSteps(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsSlice flattens the contents of InstancePreprocessReconcileRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeSteps {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeSteps{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeSteps{}
	}

	items := make([]InstancePreprocessReconcileRecipeSteps, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeSteps(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeSteps expands an instance of InstancePreprocessReconcileRecipeSteps into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeSteps(c *Client, f *InstancePreprocessReconcileRecipeSteps) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.RelativeTime; !dcl.IsEmptyValueIndirect(v) {
		m["relativeTime"] = v
	}
	if v := f.SleepDuration; !dcl.IsEmptyValueIndirect(v) {
		m["sleepDuration"] = v
	}
	if v := f.Action; !dcl.IsEmptyValueIndirect(v) {
		m["action"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsStatus(c, f.Status); err != nil {
		return nil, fmt.Errorf("error expanding Status into status: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["status"] = v
	}
	if v := f.ErrorSpace; !dcl.IsEmptyValueIndirect(v) {
		m["errorSpace"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}
	if v := f.ResourceMetadataSize; !dcl.IsEmptyValueIndirect(v) {
		m["resourceMetadataSize"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.UpdatedRepeatOperationDelaySec; !dcl.IsEmptyValueIndirect(v) {
		m["updatedRepeatOperationDelaySec"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSlice(c, f.QuotaRequestDeltas); err != nil {
		return nil, fmt.Errorf("error expanding QuotaRequestDeltas into quotaRequestDeltas: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["quotaRequestDeltas"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c, f.PreprocessUpdate); err != nil {
		return nil, fmt.Errorf("error expanding PreprocessUpdate into preprocessUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["preprocessUpdate"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c, f.RequestedTenantProject); err != nil {
		return nil, fmt.Errorf("error expanding RequestedTenantProject into requestedTenantProject: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["requestedTenantProject"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfoSlice(c, f.PermissionsInfo); err != nil {
		return nil, fmt.Errorf("error expanding PermissionsInfo into permissionsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["permissionsInfo"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c, f.KeyNotificationsUpdate); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsUpdate into keyNotificationsUpdate: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsUpdate"] = v
	}
	if v := f.ClhDataUpdateTime; !dcl.IsEmptyValueIndirect(v) {
		m["clhDataUpdateTime"] = v
	}
	if v := f.PublicErrorMessage; !dcl.IsEmptyValueIndirect(v) {
		m["publicErrorMessage"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeSteps flattens an instance of InstancePreprocessReconcileRecipeSteps from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeSteps(c *Client, i interface{}) *InstancePreprocessReconcileRecipeSteps {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeSteps{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeSteps
	}
	r.RelativeTime = dcl.FlattenInteger(m["relativeTime"])
	r.SleepDuration = dcl.FlattenInteger(m["sleepDuration"])
	r.Action = flattenInstancePreprocessReconcileRecipeStepsActionEnum(m["action"])
	r.Status = flattenInstancePreprocessReconcileRecipeStepsStatus(c, m["status"])
	r.ErrorSpace = dcl.FlattenString(m["errorSpace"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])
	r.ResourceMetadataSize = dcl.FlattenInteger(m["resourceMetadataSize"])
	r.Description = dcl.FlattenString(m["description"])
	r.UpdatedRepeatOperationDelaySec = dcl.FlattenDouble(m["updatedRepeatOperationDelaySec"])
	r.QuotaRequestDeltas = flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSlice(c, m["quotaRequestDeltas"])
	r.PreprocessUpdate = flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c, m["preprocessUpdate"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])
	r.RequestedTenantProject = flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c, m["requestedTenantProject"])
	r.PermissionsInfo = flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoSlice(c, m["permissionsInfo"])
	r.KeyNotificationsUpdate = flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c, m["keyNotificationsUpdate"])
	r.ClhDataUpdateTime = dcl.FlattenString(m["clhDataUpdateTime"])
	r.PublicErrorMessage = dcl.FlattenString(m["publicErrorMessage"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsStatusMap expands the contents of InstancePreprocessReconcileRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsStatusMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsStatus) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsStatusSlice expands the contents of InstancePreprocessReconcileRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsStatusSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsStatus) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsStatus(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsStatusMap flattens the contents of InstancePreprocessReconcileRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsStatusMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsStatus {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsStatus{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsStatus)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsStatus(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsStatusSlice flattens the contents of InstancePreprocessReconcileRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsStatusSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsStatus {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsStatus{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsStatus{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsStatus, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsStatus(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsStatus expands an instance of InstancePreprocessReconcileRecipeStepsStatus into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsStatus(c *Client, f *InstancePreprocessReconcileRecipeStepsStatus) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Code; !dcl.IsEmptyValueIndirect(v) {
		m["code"] = v
	}
	if v := f.Message; !dcl.IsEmptyValueIndirect(v) {
		m["message"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsStatusDetailsSlice(c, f.Details); err != nil {
		return nil, fmt.Errorf("error expanding Details into details: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["details"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsStatus flattens an instance of InstancePreprocessReconcileRecipeStepsStatus from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsStatus(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsStatus {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsStatus{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsStatus
	}
	r.Code = dcl.FlattenInteger(m["code"])
	r.Message = dcl.FlattenString(m["message"])
	r.Details = flattenInstancePreprocessReconcileRecipeStepsStatusDetailsSlice(c, m["details"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsStatusDetailsMap expands the contents of InstancePreprocessReconcileRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsStatusDetailsMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsStatusDetailsSlice expands the contents of InstancePreprocessReconcileRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsStatusDetailsSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsStatusDetails) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsStatusDetails(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsStatusDetailsMap flattens the contents of InstancePreprocessReconcileRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsStatusDetailsMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsStatusDetails {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsStatusDetails{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsStatusDetails)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsStatusDetails(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsStatusDetailsSlice flattens the contents of InstancePreprocessReconcileRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsStatusDetailsSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsStatusDetails {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsStatusDetails{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsStatusDetails{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsStatusDetails, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsStatusDetails(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsStatusDetails expands an instance of InstancePreprocessReconcileRecipeStepsStatusDetails into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsStatusDetails(c *Client, f *InstancePreprocessReconcileRecipeStepsStatusDetails) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.TypeUrl; !dcl.IsEmptyValueIndirect(v) {
		m["typeUrl"] = v
	}
	if v := f.Value; !dcl.IsEmptyValueIndirect(v) {
		m["value"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsStatusDetails flattens an instance of InstancePreprocessReconcileRecipeStepsStatusDetails from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsStatusDetails(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsStatusDetails {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsStatusDetails{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsStatusDetails
	}
	r.TypeUrl = dcl.FlattenString(m["typeUrl"])
	r.Value = dcl.FlattenString(m["value"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasMap expands the contents of InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSlice expands the contents of InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasMap flattens the contents of InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSlice flattens the contents of InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltasSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas expands an instance of InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(c *Client, f *InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.MetricName; !dcl.IsEmptyValueIndirect(v) {
		m["metricName"] = v
	}
	if v := f.Amount; !dcl.IsEmptyValueIndirect(v) {
		m["amount"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas flattens an instance of InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsQuotaRequestDeltas{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsQuotaRequestDeltas
	}
	r.MetricName = dcl.FlattenString(m["metricName"])
	r.Amount = dcl.FlattenInteger(m["amount"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsPreprocessUpdateMap expands the contents of InstancePreprocessReconcileRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPreprocessUpdateMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsPreprocessUpdateSlice expands the contents of InstancePreprocessReconcileRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPreprocessUpdateSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsPreprocessUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdateMap flattens the contents of InstancePreprocessReconcileRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsPreprocessUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsPreprocessUpdate{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsPreprocessUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdateSlice flattens the contents of InstancePreprocessReconcileRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdateSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsPreprocessUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsPreprocessUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsPreprocessUpdate{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsPreprocessUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsPreprocessUpdate expands an instance of InstancePreprocessReconcileRecipeStepsPreprocessUpdate into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c *Client, f *InstancePreprocessReconcileRecipeStepsPreprocessUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.LatencySloBucketName; !dcl.IsEmptyValueIndirect(v) {
		m["latencySloBucketName"] = v
	}
	if v := f.PublicOperationMetadata; !dcl.IsEmptyValueIndirect(v) {
		m["publicOperationMetadata"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdate flattens an instance of InstancePreprocessReconcileRecipeStepsPreprocessUpdate from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPreprocessUpdate(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsPreprocessUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsPreprocessUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsPreprocessUpdate
	}
	r.LatencySloBucketName = dcl.FlattenString(m["latencySloBucketName"])
	r.PublicOperationMetadata = dcl.FlattenString(m["publicOperationMetadata"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsRequestedTenantProjectMap expands the contents of InstancePreprocessReconcileRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsRequestedTenantProjectMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsRequestedTenantProjectSlice expands the contents of InstancePreprocessReconcileRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsRequestedTenantProjectSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsRequestedTenantProject) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectMap flattens the contents of InstancePreprocessReconcileRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsRequestedTenantProject {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsRequestedTenantProject{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsRequestedTenantProject)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectSlice flattens the contents of InstancePreprocessReconcileRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsRequestedTenantProject {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsRequestedTenantProject{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsRequestedTenantProject{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsRequestedTenantProject, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsRequestedTenantProject expands an instance of InstancePreprocessReconcileRecipeStepsRequestedTenantProject into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c *Client, f *InstancePreprocessReconcileRecipeStepsRequestedTenantProject) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Tag; !dcl.IsEmptyValueIndirect(v) {
		m["tag"] = v
	}
	if v := f.Folder; !dcl.IsEmptyValueIndirect(v) {
		m["folder"] = v
	}
	if v := f.Scope; !dcl.IsEmptyValueIndirect(v) {
		m["scope"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProject flattens an instance of InstancePreprocessReconcileRecipeStepsRequestedTenantProject from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProject(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsRequestedTenantProject {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsRequestedTenantProject{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsRequestedTenantProject
	}
	r.Tag = dcl.FlattenString(m["tag"])
	r.Folder = dcl.FlattenString(m["folder"])
	r.Scope = flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum(m["scope"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfoMap expands the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfoMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfoSlice expands the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfoSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsPermissionsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoMap flattens the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfo{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsPermissionsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoSlice flattens the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsPermissionsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsPermissionsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsPermissionsInfo{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsPermissionsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsPermissionsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfo expands an instance of InstancePreprocessReconcileRecipeStepsPermissionsInfo into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfo(c *Client, f *InstancePreprocessReconcileRecipeStepsPermissionsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c, f.PolicyName); err != nil {
		return nil, fmt.Errorf("error expanding PolicyName into policyName: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["policyName"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c, f.IamPermissions); err != nil {
		return nil, fmt.Errorf("error expanding IamPermissions into iamPermissions: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["iamPermissions"] = v
	}
	if v := f.ResourcePath; !dcl.IsEmptyValueIndirect(v) {
		m["resourcePath"] = v
	}
	if v, err := expandInstanceGoogleprotobufstruct(c, f.ApiAttrs); err != nil {
		return nil, fmt.Errorf("error expanding ApiAttrs into apiAttrs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["apiAttrs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfo flattens an instance of InstancePreprocessReconcileRecipeStepsPermissionsInfo from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfo(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsPermissionsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsPermissionsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsPermissionsInfo
	}
	r.PolicyName = flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c, m["policyName"])
	r.IamPermissions = flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c, m["iamPermissions"])
	r.ResourcePath = dcl.FlattenString(m["resourcePath"])
	r.ApiAttrs = flattenInstanceGoogleprotobufstruct(c, m["apiAttrs"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameMap expands the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameSlice expands the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameMap flattens the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameSlice flattens the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyNameSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName expands an instance of InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c *Client, f *InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Type; !dcl.IsEmptyValueIndirect(v) {
		m["type"] = v
	}
	if v := f.Id; !dcl.IsEmptyValueIndirect(v) {
		m["id"] = v
	}
	if v := f.Region; !dcl.IsEmptyValueIndirect(v) {
		m["region"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName flattens an instance of InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsPermissionsInfoPolicyName
	}
	r.Type = dcl.FlattenString(m["type"])
	r.Id = dcl.FlattenString(m["id"])
	r.Region = dcl.FlattenString(m["region"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsMap expands the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSlice expands the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsMap flattens the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSlice flattens the contents of InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissionsSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions expands an instance of InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(c *Client, f *InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Permission; !dcl.IsEmptyValueIndirect(v) {
		m["permission"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions flattens an instance of InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsPermissionsInfoIamPermissions
	}
	r.Permission = dcl.FlattenString(m["permission"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateMap expands the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateSlice expands the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateMap flattens the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateSlice flattens the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate expands an instance of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c *Client, f *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, f.KeyNotificationsInfo); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationsInfo into keyNotificationsInfo: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationsInfo"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate flattens an instance of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdate
	}
	r.KeyNotificationsInfo = flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, m["keyNotificationsInfo"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap expands the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice expands the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap flattens the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice flattens the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo expands an instance of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, f *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.DataVersion; !dcl.IsEmptyValueIndirect(v) {
		m["dataVersion"] = v
	}
	if v := f.Delegate; !dcl.IsEmptyValueIndirect(v) {
		m["delegate"] = v
	}
	if v, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, f.KeyNotificationConfigs); err != nil {
		return nil, fmt.Errorf("error expanding KeyNotificationConfigs into keyNotificationConfigs: %w", err)
	} else if !dcl.IsEmptyValueIndirect(v) {
		m["keyNotificationConfigs"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo flattens an instance of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfo
	}
	r.DataVersion = dcl.FlattenInteger(m["dataVersion"])
	r.Delegate = dcl.FlattenString(m["delegate"])
	r.KeyNotificationConfigs = flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c, m["keyNotificationConfigs"])

	return r
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap expands the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, f map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice expands the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, f []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap flattens the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsMap(c *Client, i interface{}) map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make(map[string]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs)
	for k, item := range a {
		items[k] = *flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice flattens the contents of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigsSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs expands an instance of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs into a JSON
// request object.
func expandInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, f *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.KeyOrVersionName; !dcl.IsEmptyValueIndirect(v) {
		m["keyOrVersionName"] = v
	}
	if v := f.Grant; !dcl.IsEmptyValueIndirect(v) {
		m["grant"] = v
	}
	if v := f.DelegatorGaiaId; !dcl.IsEmptyValueIndirect(v) {
		m["delegatorGaiaId"] = v
	}

	return m, nil
}

// flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs flattens an instance of InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs(c *Client, i interface{}) *InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstancePreprocessReconcileRecipeStepsKeyNotificationsUpdateKeyNotificationsInfoKeyNotificationConfigs
	}
	r.KeyOrVersionName = dcl.FlattenString(m["keyOrVersionName"])
	r.Grant = dcl.FlattenString(m["grant"])
	r.DelegatorGaiaId = dcl.FlattenInteger(m["delegatorGaiaId"])

	return r
}

// expandInstanceHistoryMap expands the contents of InstanceHistory into a JSON
// request object.
func expandInstanceHistoryMap(c *Client, f map[string]InstanceHistory) (map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := make(map[string]interface{})
	for k, item := range f {
		i, err := expandInstanceHistory(c, &item)
		if err != nil {
			return nil, err
		}
		if i != nil {
			items[k] = i
		}
	}

	return items, nil
}

// expandInstanceHistorySlice expands the contents of InstanceHistory into a JSON
// request object.
func expandInstanceHistorySlice(c *Client, f []InstanceHistory) ([]map[string]interface{}, error) {
	if f == nil {
		return nil, nil
	}

	items := []map[string]interface{}{}
	for _, item := range f {
		i, err := expandInstanceHistory(c, &item)
		if err != nil {
			return nil, err
		}

		items = append(items, i)
	}

	return items, nil
}

// flattenInstanceHistoryMap flattens the contents of InstanceHistory from a JSON
// response object.
func flattenInstanceHistoryMap(c *Client, i interface{}) map[string]InstanceHistory {
	a, ok := i.(map[string]interface{})
	if !ok {
		return map[string]InstanceHistory{}
	}

	if len(a) == 0 {
		return map[string]InstanceHistory{}
	}

	items := make(map[string]InstanceHistory)
	for k, item := range a {
		items[k] = *flattenInstanceHistory(c, item.(map[string]interface{}))
	}

	return items
}

// flattenInstanceHistorySlice flattens the contents of InstanceHistory from a JSON
// response object.
func flattenInstanceHistorySlice(c *Client, i interface{}) []InstanceHistory {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceHistory{}
	}

	if len(a) == 0 {
		return []InstanceHistory{}
	}

	items := make([]InstanceHistory, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceHistory(c, item.(map[string]interface{})))
	}

	return items
}

// expandInstanceHistory expands an instance of InstanceHistory into a JSON
// request object.
func expandInstanceHistory(c *Client, f *InstanceHistory) (map[string]interface{}, error) {
	if dcl.IsEmptyValueIndirect(f) {
		return nil, nil
	}

	m := make(map[string]interface{})
	if v := f.Timestamp; !dcl.IsEmptyValueIndirect(v) {
		m["timestamp"] = v
	}
	if v := f.OperationHandle; !dcl.IsEmptyValueIndirect(v) {
		m["operationHandle"] = v
	}
	if v := f.Description; !dcl.IsEmptyValueIndirect(v) {
		m["description"] = v
	}
	if v := f.StepIndex; !dcl.IsEmptyValueIndirect(v) {
		m["stepIndex"] = v
	}
	if v := f.TenantProjectNumber; !dcl.IsEmptyValueIndirect(v) {
		m["tenantProjectNumber"] = v
	}
	if v := f.TenantProjectId; !dcl.IsEmptyValueIndirect(v) {
		m["tenantProjectId"] = v
	}
	if v := f.P4ServiceAccount; !dcl.IsEmptyValueIndirect(v) {
		m["p4ServiceAccount"] = v
	}

	return m, nil
}

// flattenInstanceHistory flattens an instance of InstanceHistory from a JSON
// response object.
func flattenInstanceHistory(c *Client, i interface{}) *InstanceHistory {
	m, ok := i.(map[string]interface{})
	if !ok {
		return nil
	}

	r := &InstanceHistory{}

	if dcl.IsEmptyValueIndirect(i) {
		return EmptyInstanceHistory
	}
	r.Timestamp = dcl.FlattenString(m["timestamp"])
	r.OperationHandle = dcl.FlattenString(m["operationHandle"])
	r.Description = dcl.FlattenString(m["description"])
	r.StepIndex = dcl.FlattenInteger(m["stepIndex"])
	r.TenantProjectNumber = dcl.FlattenInteger(m["tenantProjectNumber"])
	r.TenantProjectId = dcl.FlattenString(m["tenantProjectId"])
	r.P4ServiceAccount = dcl.FlattenString(m["p4ServiceAccount"])

	return r
}

// flattenInstanceSkuTierEnumSlice flattens the contents of InstanceSkuTierEnum from a JSON
// response object.
func flattenInstanceSkuTierEnumSlice(c *Client, i interface{}) []InstanceSkuTierEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceSkuTierEnum{}
	}

	if len(a) == 0 {
		return []InstanceSkuTierEnum{}
	}

	items := make([]InstanceSkuTierEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceSkuTierEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceSkuTierEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceSkuTierEnum with the same value as that string.
func flattenInstanceSkuTierEnum(i interface{}) *InstanceSkuTierEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceSkuTierEnumRef("")
	}

	return InstanceSkuTierEnumRef(s)
}

// flattenInstanceSkuSizeEnumSlice flattens the contents of InstanceSkuSizeEnum from a JSON
// response object.
func flattenInstanceSkuSizeEnumSlice(c *Client, i interface{}) []InstanceSkuSizeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceSkuSizeEnum{}
	}

	if len(a) == 0 {
		return []InstanceSkuSizeEnum{}
	}

	items := make([]InstanceSkuSizeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceSkuSizeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceSkuSizeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceSkuSizeEnum with the same value as that string.
func flattenInstanceSkuSizeEnum(i interface{}) *InstanceSkuSizeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceSkuSizeEnumRef("")
	}

	return InstanceSkuSizeEnumRef(s)
}

// flattenInstanceStateEnumSlice flattens the contents of InstanceStateEnum from a JSON
// response object.
func flattenInstanceStateEnumSlice(c *Client, i interface{}) []InstanceStateEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceStateEnum{}
	}

	if len(a) == 0 {
		return []InstanceStateEnum{}
	}

	items := make([]InstanceStateEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceStateEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceStateEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceStateEnum with the same value as that string.
func flattenInstanceStateEnum(i interface{}) *InstanceStateEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceStateEnumRef("")
	}

	return InstanceStateEnumRef(s)
}

// flattenInstancePreprocessCreateRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessCreateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessCreateRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessCreateRecipeStepsActionEnum(i interface{}) *InstancePreprocessCreateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessCreateRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessCreateRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessCreateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceCreateRecipeStepsActionEnumSlice flattens the contents of InstanceCreateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceCreateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsActionEnum{}
	}

	items := make([]InstanceCreateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceCreateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceCreateRecipeStepsActionEnum with the same value as that string.
func flattenInstanceCreateRecipeStepsActionEnum(i interface{}) *InstanceCreateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceCreateRecipeStepsActionEnumRef("")
	}

	return InstanceCreateRecipeStepsActionEnumRef(s)
}

// flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceCreateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceCreateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceCreateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceCreateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceDeleteRecipeStepsActionEnumSlice flattens the contents of InstanceDeleteRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsActionEnum{}
	}

	items := make([]InstanceDeleteRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceDeleteRecipeStepsActionEnum with the same value as that string.
func flattenInstanceDeleteRecipeStepsActionEnum(i interface{}) *InstanceDeleteRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceDeleteRecipeStepsActionEnumRef("")
	}

	return InstanceDeleteRecipeStepsActionEnumRef(s)
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceDeleteRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceUpdateRecipeStepsActionEnumSlice flattens the contents of InstanceUpdateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsActionEnum{}
	}

	items := make([]InstanceUpdateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceUpdateRecipeStepsActionEnum with the same value as that string.
func flattenInstanceUpdateRecipeStepsActionEnum(i interface{}) *InstanceUpdateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceUpdateRecipeStepsActionEnumRef("")
	}

	return InstanceUpdateRecipeStepsActionEnumRef(s)
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceUpdateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessResetRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessResetRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessResetRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessResetRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessResetRecipeStepsActionEnum(i interface{}) *InstancePreprocessResetRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessResetRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessResetRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessResetRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceResetRecipeStepsActionEnumSlice flattens the contents of InstanceResetRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceResetRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceResetRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsActionEnum{}
	}

	items := make([]InstanceResetRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceResetRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceResetRecipeStepsActionEnum with the same value as that string.
func flattenInstanceResetRecipeStepsActionEnum(i interface{}) *InstanceResetRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceResetRecipeStepsActionEnumRef("")
	}

	return InstanceResetRecipeStepsActionEnumRef(s)
}

// flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceResetRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceResetRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceResetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceResetRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceResetRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceResetRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceResetRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceResetRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceResetRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessRepairRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessRepairRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessRepairRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessRepairRecipeStepsActionEnum(i interface{}) *InstancePreprocessRepairRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessRepairRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessRepairRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessRepairRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceRepairRecipeStepsActionEnumSlice flattens the contents of InstanceRepairRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceRepairRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsActionEnum{}
	}

	items := make([]InstanceRepairRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceRepairRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceRepairRecipeStepsActionEnum with the same value as that string.
func flattenInstanceRepairRecipeStepsActionEnum(i interface{}) *InstanceRepairRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceRepairRecipeStepsActionEnumRef("")
	}

	return InstanceRepairRecipeStepsActionEnumRef(s)
}

// flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceRepairRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceRepairRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceRepairRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceRepairRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessDeleteRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessDeleteRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessDeleteRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessDeleteRecipeStepsActionEnum(i interface{}) *InstancePreprocessDeleteRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessDeleteRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessDeleteRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessDeleteRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessUpdateRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessUpdateRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessUpdateRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessUpdateRecipeStepsActionEnum(i interface{}) *InstancePreprocessUpdateRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessUpdateRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessUpdateRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessUpdateRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessFreezeRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessFreezeRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessFreezeRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessFreezeRecipeStepsActionEnum(i interface{}) *InstancePreprocessFreezeRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessFreezeRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessFreezeRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessFreezeRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceFreezeRecipeStepsActionEnumSlice flattens the contents of InstanceFreezeRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsActionEnum{}
	}

	items := make([]InstanceFreezeRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceFreezeRecipeStepsActionEnum with the same value as that string.
func flattenInstanceFreezeRecipeStepsActionEnum(i interface{}) *InstanceFreezeRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceFreezeRecipeStepsActionEnumRef("")
	}

	return InstanceFreezeRecipeStepsActionEnumRef(s)
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceFreezeRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessUnfreezeRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessUnfreezeRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessUnfreezeRecipeStepsActionEnum(i interface{}) *InstancePreprocessUnfreezeRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessUnfreezeRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessUnfreezeRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessUnfreezeRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceUnfreezeRecipeStepsActionEnumSlice flattens the contents of InstanceUnfreezeRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsActionEnum{}
	}

	items := make([]InstanceUnfreezeRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceUnfreezeRecipeStepsActionEnum with the same value as that string.
func flattenInstanceUnfreezeRecipeStepsActionEnum(i interface{}) *InstanceUnfreezeRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceUnfreezeRecipeStepsActionEnumRef("")
	}

	return InstanceUnfreezeRecipeStepsActionEnumRef(s)
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceUnfreezeRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessReportInstanceHealthRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsActionEnum(i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessReportInstanceHealthRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessReportInstanceHealthRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceReportInstanceHealthRecipeStepsActionEnumSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsActionEnum{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceReportInstanceHealthRecipeStepsActionEnum with the same value as that string.
func flattenInstanceReportInstanceHealthRecipeStepsActionEnum(i interface{}) *InstanceReportInstanceHealthRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceReportInstanceHealthRecipeStepsActionEnumRef("")
	}

	return InstanceReportInstanceHealthRecipeStepsActionEnumRef(s)
}

// flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceReportInstanceHealthRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessGetRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessGetRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessGetRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessGetRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessGetRecipeStepsActionEnum(i interface{}) *InstancePreprocessGetRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessGetRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessGetRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessGetRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceNotifyKeyAvailableRecipeStepsActionEnumSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsActionEnum{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceNotifyKeyAvailableRecipeStepsActionEnum with the same value as that string.
func flattenInstanceNotifyKeyAvailableRecipeStepsActionEnum(i interface{}) *InstanceNotifyKeyAvailableRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceNotifyKeyAvailableRecipeStepsActionEnumRef("")
	}

	return InstanceNotifyKeyAvailableRecipeStepsActionEnumRef(s)
}

// flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceNotifyKeyAvailableRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsActionEnumSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsActionEnum{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceNotifyKeyUnavailableRecipeStepsActionEnum with the same value as that string.
func flattenInstanceNotifyKeyUnavailableRecipeStepsActionEnum(i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceNotifyKeyUnavailableRecipeStepsActionEnumRef("")
	}

	return InstanceNotifyKeyUnavailableRecipeStepsActionEnumRef(s)
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceNotifyKeyUnavailableRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceReadonlyRecipeStepsActionEnumSlice flattens the contents of InstanceReadonlyRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsActionEnum{}
	}

	items := make([]InstanceReadonlyRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceReadonlyRecipeStepsActionEnum with the same value as that string.
func flattenInstanceReadonlyRecipeStepsActionEnum(i interface{}) *InstanceReadonlyRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceReadonlyRecipeStepsActionEnumRef("")
	}

	return InstanceReadonlyRecipeStepsActionEnumRef(s)
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceReadonlyRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstanceReconcileRecipeStepsActionEnumSlice flattens the contents of InstanceReconcileRecipeStepsActionEnum from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsActionEnum{}
	}

	items := make([]InstanceReconcileRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceReconcileRecipeStepsActionEnum with the same value as that string.
func flattenInstanceReconcileRecipeStepsActionEnum(i interface{}) *InstanceReconcileRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceReconcileRecipeStepsActionEnumRef("")
	}

	return InstanceReconcileRecipeStepsActionEnumRef(s)
}

// flattenInstanceReconcileRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstanceReconcileRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstanceReconcileRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessPassthroughRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessPassthroughRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessPassthroughRecipeStepsActionEnum(i interface{}) *InstancePreprocessPassthroughRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessPassthroughRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessPassthroughRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessPassthroughRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// flattenInstancePreprocessReconcileRecipeStepsActionEnumSlice flattens the contents of InstancePreprocessReconcileRecipeStepsActionEnum from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsActionEnumSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsActionEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsActionEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsActionEnum{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsActionEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsActionEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsActionEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessReconcileRecipeStepsActionEnum with the same value as that string.
func flattenInstancePreprocessReconcileRecipeStepsActionEnum(i interface{}) *InstancePreprocessReconcileRecipeStepsActionEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessReconcileRecipeStepsActionEnumRef("")
	}

	return InstancePreprocessReconcileRecipeStepsActionEnumRef(s)
}

// flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnumSlice flattens the contents of InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum from a JSON
// response object.
func flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnumSlice(c *Client, i interface{}) []InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum {
	a, ok := i.([]interface{})
	if !ok {
		return []InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	if len(a) == 0 {
		return []InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum{}
	}

	items := make([]InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum, 0, len(a))
	for _, item := range a {
		items = append(items, *flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum(item.(interface{})))
	}

	return items
}

// flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum asserts that an interface is a string, and returns a
// pointer to a *InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum with the same value as that string.
func flattenInstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum(i interface{}) *InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnum {
	s, ok := i.(string)
	if !ok {
		return InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnumRef("")
	}

	return InstancePreprocessReconcileRecipeStepsRequestedTenantProjectScopeEnumRef(s)
}

// This function returns a matcher that checks whether a serialized resource matches this resource
// in its parameters (as defined by the fields in a Get, which definitionally define resource
// identity).  This is useful in extracting the element from a List call.
func (r *Instance) matcher(c *Client) func([]byte) bool {
	return func(b []byte) bool {
		cr, err := unmarshalInstance(b, c)
		if err != nil {
			c.Config.Logger.Warning("failed to unmarshal provided resource in matcher.")
			return false
		}
		nr := r.urlNormalized()
		ncr := cr.urlNormalized()
		c.Config.Logger.Infof("looking for %v\nin %v", nr, ncr)

		if nr.Project == nil && ncr.Project == nil {
			c.Config.Logger.Info("Both Project fields null - considering equal.")
		} else if nr.Project == nil || ncr.Project == nil {
			c.Config.Logger.Info("Only one Project field is null - considering unequal.")
			return false
		} else if *nr.Project != *ncr.Project {
			return false
		}
		if nr.Location == nil && ncr.Location == nil {
			c.Config.Logger.Info("Both Location fields null - considering equal.")
		} else if nr.Location == nil || ncr.Location == nil {
			c.Config.Logger.Info("Only one Location field is null - considering unequal.")
			return false
		} else if *nr.Location != *ncr.Location {
			return false
		}
		if nr.Name == nil && ncr.Name == nil {
			c.Config.Logger.Info("Both Name fields null - considering equal.")
		} else if nr.Name == nil || ncr.Name == nil {
			c.Config.Logger.Info("Only one Name field is null - considering unequal.")
			return false
		} else if *nr.Name != *ncr.Name {
			return false
		}
		return true
	}
}

type instanceDiff struct {
	// The diff should include one or the other of RequiresRecreate or UpdateOp.
	RequiresRecreate bool
	UpdateOp         instanceApiOperation
}

func convertFieldDiffToInstanceOp(ops []string, fds []*dcl.FieldDiff, opts []dcl.ApplyOption) ([]instanceDiff, error) {
	var diffs []instanceDiff
	for _, op := range ops {
		diff := instanceDiff{}
		if op == "Recreate" {
			diff.RequiresRecreate = true
		} else {
			op, err := convertOpNameToinstanceApiOperation(op, fds, opts...)
			if err != nil {
				return diffs, err
			}
			diff.UpdateOp = op
		}
		diffs = append(diffs, diff)
	}
	return diffs, nil
}

func convertOpNameToinstanceApiOperation(op string, diffs []*dcl.FieldDiff, opts ...dcl.ApplyOption) (instanceApiOperation, error) {
	switch op {

	case "updateInstanceUpdateInstanceOperation":
		return &updateInstanceUpdateInstanceOperation{Diffs: diffs}, nil

	default:
		return nil, fmt.Errorf("no such operation with name: %v", op)
	}
}
